// Copyright (c) 2013-2014, NVIDIA CORPORATION.  All rights reserved.

package icera.DebugAgent;

import icera.DebugAgent.LoggerManager.LogReason;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.res.Resources;
import android.os.AsyncTask;
import android.os.Binder;
import android.os.Bundle;
import android.os.DropBoxManager;
import android.os.Environment;
import android.os.Handler;
import android.os.IBinder;
import android.os.Message;
import android.os.StatFs;
import android.support.v4.app.NotificationCompat;
import android.support.v4.app.NotificationCompat.Builder;
import android.telephony.PhoneStateListener;
import android.telephony.ServiceState;
import android.telephony.TelephonyManager;
import android.util.Log;

import java.io.File;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Date;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import dalvik.system.DexFile;

/**
 * A service to manage all kinds of log files 1. Modem logging (Beanie logs):
 * one instance of icera_log_serial_arm, continuously running 2. Coredump (Modem
 * crashes, both full and mini): generated by modem crash. save when needed or
 * automatically 3. Logcat logs, including RIL logs: once instance of logcat,
 * continuously 4. Kernel logs: save when needed 5. User comments Events to
 * Monitor: 1. Modem crash 2. Kernel crash 3. SD low and full
 * Events to check at startup 1. coredump 2. kernel crash
 * 
 * @author
 */
public class BugReportService extends Service {

    private static final String TAG = "BugReportSvc";

    private static final int NOTIFY_ME_ID = 1336;

    public final static String TYPE_MODEM_CRASH = "type_modem_crash";

    public final static String TYPE_RIL_CRASH = "type_ril_crash";

    public final static String TYPE_APP_CRASH = "type_app_crash";

    public final static String TYPE_AUTO_SAVING = "type_auto_saving";

    public final static String CRASH = "";

    /**
     * Possible types of notifications
     */
    enum NotificationType {
        NOTIFY_STARTED, NOTIFY_CRASH_KERNEL, NOTIFY_CRASH_RIL, NOTIFY_CRASH_MODEM, NOTIFY_CRASH_APP,
        NOTIFY_AUTO_SAVING, NOTIFY_SAVING_OK, NOTIFY_SAVING_ISSUE, NOTIFY_LOGGING_STOPPED, NOTIFY_SDCARD_LOW,
        NOTIFY_SDCARD_OK, NOTIFY_DISCARD, NOTIFY_NORMAL, NOTIFY_INSUFFICIENT_SPACE, NOTIFY_MODEM_LOGGING_FAILED
    }

    private Context mThis;

    private LoggerManager mLoggerManager = null;

    // Binder given to clients
    private final IBinder mBinder = new BugReportServiceBinder();

    private boolean mRunning = false;

    private Builder mBuilder = null;

    private NotificationManager mServiceNM = null;

    private TelephonyManager mTelephonyManager = null;

    private ScheduledExecutorService EX;

    private AutoSaveScenario[] mAutoSaveScenarios;

    private AutoSaveMonitor mAutoSaveMonitor;

    private int mStorageState = STORAGE_SPACE_OK;

    public static final long LOGGING_LOW_SPACE_WARNING = (200 * 1024 * 1024L);

    public static final long LOGGING_STOP_THRESHHOLD = (32 * 3 * 1024 * 1024L);

    private static final long STORAGE_SPACE_CHECK_DELAY = 60;

    static final int STORAGE_SPACE_OK = 0;

    static final int STORAGE_SPACE_LOGGING_STOP = 1;

    static final int STORAGE_SPACE_LOW_SPACE_WARNING = 2;

    static final int MSG_AUTO_SAVING_FINISHED = 3;

    static final int MSG_CANCEL_AUTO_SAVING = 4;

    static final int MSG_APP_CRASH_DETECT = 5;

    private Runnable mSaveAutoSavingLog = null;

    public static String[] ERRORTYPES = new String[] { "SYSTEM_TOMBSTONE",
        "system_server_crash",
        "system_app_wtf",
        "system_app_crash",
        "system_app_anr",
        "data_app_wtf",
        "data_app_crash",
        "data_app_anr",
        "modem_crash"
    };

    private Runnable mExternStorageSpaceChecker = new Runnable() {

        @Override
        public void run() {
            Message msg;
            long freeSpace = 0;
            int what = STORAGE_SPACE_OK;
            String state = Environment.getExternalStorageState();

            if (Environment.MEDIA_MOUNTED.contentEquals(state)) {
                mExternStorageAvail = mExternStorageWriteable = true;
                freeSpace = Environment.getExternalStorageDirectory().getFreeSpace();
            } else {

                StatFs statefs = new StatFs("/data");
                freeSpace = statefs.getFreeBlocks() * statefs.getBlockSize();
            }

            // if (Environment.MEDIA_MOUNTED.equals(state)) {

            if (freeSpace <= LOGGING_STOP_THRESHHOLD) {
                what = STORAGE_SPACE_LOGGING_STOP;
            } else if (freeSpace <= LOGGING_LOW_SPACE_WARNING) {
                what = STORAGE_SPACE_LOW_SPACE_WARNING;
            } else
                what = STORAGE_SPACE_OK;

            if (mStorageState != what) {
                msg = Message.obtain(mHandler, what);
                mHandler.sendMessage(msg);
            }
            //
            // } else if (Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {
            // mExternStorageAvail = true;
            // mExternStorageWriteable = false;
            // } else {
            // mExternStorageAvail = mExternStorageWriteable = false;
            // }
        }

    };

    /*
     * Process the autosave message sent by AutoSaveMonitor,
     * return TRUE if found
     */
    private boolean processAutoSaveMessages(Message msg) {
        if ((msg.what == AutoSaveMonitor.CANCEL_SCENARIO) && (mSaveAutoSavingLog != null) ) {
            mHandler.removeCallbacks(mSaveAutoSavingLog);
            mAutoSaveMonitor.resumeParsing();
            return true;
        }

        for (AutoSaveScenario scenario : mAutoSaveScenarios) {
            if (scenario.id == msg.what) {

                final String dirName = LogUtil.LOG_DATE_FORMAT.format(new Date()) + scenario.dirSuffix;
                Log.i(TAG, "Received " + scenario.dirSuffix + " message, will save to " + dirName);
                mSaveAutoSavingLog = new Runnable() {
                    
                    @Override
                    public void run() {
                        storeLogsAsync(dirName, TYPE_AUTO_SAVING, false);
                        
                        mAutoSaveMonitor.resumeParsing();
                        return;
                    }
                };
                mHandler.postDelayed(mSaveAutoSavingLog, scenario.delay * 1000);
                return true;
            }
        }
        return false;
    }

    Handler mHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            
            if(mAutoSaveMonitor != null && processAutoSaveMessages(msg))
                return;

            switch (msg.what) {
                case STORAGE_SPACE_LOGGING_STOP:
                    mStorageState = msg.what;
                    Log.e(TAG, "SD space too low, logging stopped");
                    mLoggerManager.stopAllToStore(false);
                    notifyMessage(NotificationType.NOTIFY_LOGGING_STOPPED);
                    break;

                case STORAGE_SPACE_LOW_SPACE_WARNING:
                    mStorageState = msg.what;
                    Log.e(TAG, "SD space low");
                    notifyMessage(NotificationType.NOTIFY_SDCARD_LOW);
                    break;

                case STORAGE_SPACE_OK:
                    mStorageState = msg.what;
                    Log.e(TAG, "SD space OK");
                    notifyMessage(NotificationType.NOTIFY_SDCARD_OK);
                    mLoggerManager.resumeLoggers();
                    break;

                case MSG_AUTO_SAVING_FINISHED:
                    Log.e(TAG, "MSG_AUTO_SAVING_FINISHED");
                    mSaveAutoSavingLog = null;
                    break;

                case MSG_CANCEL_AUTO_SAVING:
                    Log.e(TAG, "MSG_CANCEL_AUTO_SAVING");
                    if (mSaveAutoSavingLog != null) {
                        mHandler.removeCallbacks(mSaveAutoSavingLog);
                        mAutoSaveMonitor.resumeParsing();
                    }
                    break;

                case MSG_APP_CRASH_DETECT:
                    if (mLoggerManager.handleAppCrash() == LogReason.APP_CRASH)    {
                        storeLogsAsync("", TYPE_APP_CRASH, true);
                    }
                    break;
            }
        }
    };

    boolean mExternStorageAvail = false;

    boolean mExternStorageWriteable = false;

    void handleStorageState(boolean avail, boolean writable) {

    }

    void updateStorageState(Intent intent) {
        String state = Environment.getExternalStorageState();
        if (Environment.MEDIA_MOUNTED.equals(state)) {
            mExternStorageAvail = mExternStorageWriteable = true;
        } else if (Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {
            mExternStorageAvail = true;
            mExternStorageWriteable = false;
        } else {
            mExternStorageAvail = mExternStorageWriteable = false;
        }
        handleStorageState(mExternStorageAvail, mExternStorageWriteable);
    }

    private BroadcastReceiver mExternStorageReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            Log.d(TAG, "Storage: " + intent.getData() + "," + intent.getAction());
            updateStorageState(intent);
        }
    };

    private BroadcastReceiver mStorageLowFullReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {

            if (Intent.ACTION_DEVICE_STORAGE_LOW.contentEquals(intent.getAction())) {
                Log.d(TAG, "Storage low");
                notifyMessage(NotificationType.NOTIFY_SDCARD_LOW);
            } else if (Intent.ACTION_DEVICE_STORAGE_OK.contentEquals(intent.getAction())) {
                Log.d(TAG, "Storage OK");
                notifyMessage(NotificationType.NOTIFY_SDCARD_OK);
            } else if ("android.intent.action.DEVICE_STORAGE_FULL"
                    .contentEquals(intent.getAction())) {
                Log.d(TAG, "Storage full");
                mLoggerManager.stopAllToStore(false);
                notifyMessage(NotificationType.NOTIFY_LOGGING_STOPPED);
            } else if ("android.intent.action.DEVICE_STORAGE_NOT_FULL".contentEquals(intent
                    .getAction())) {
                Log.d(TAG, "Storage not full anymore");
                notifyMessage(NotificationType.NOTIFY_SDCARD_OK);
            }

        }
    };

    /**
     * Class used for the client Binder. Because we know this service always
     * runs in the same process as its clients, we don't need to deal with IPC.
     */
    public class BugReportServiceBinder extends Binder {
        BugReportService getService() {
            // Return this instance of LocalService so clients can call public
            // methods
            return BugReportService.this;
        }
    }

    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }

    /**
     * Notify the user that the application is started by vibrating and
     * displaying a message in notification area. Also attach activity to be
     * started when clicking on the message.
     */
    public void notifyMessage(NotificationType notif) {
        CharSequence tickerMsg, notifTitle, notifText;
        int icon;
        boolean vibrate;
        Intent is = new Intent(this, SaveLogs.class);
        Intent ic = new Intent(this, Cleanup.class);
        Intent pi;
        int extra = SaveLogs.NORMAL;

        is.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
        pi = is;

        switch (notif) {
            case NOTIFY_CRASH_KERNEL:
                tickerMsg = "Icera Debug Agent - Kernel Crash detected";
                notifTitle = "Icera Debug Agent - Kernel crash";
                notifText = "Auto Saving done. Check the _KERNEL logs!";
                vibrate = true;
                icon = R.drawable.icon_red;
                extra = SaveLogs.MODEM_AUTO_SAVING;
                break;

            case NOTIFY_CRASH_MODEM:
                tickerMsg = "Icera Debug Agent - Modem Error detected.";
                notifTitle = "IDA - Modem error";
                notifText = "Auto Saving done. Check the _MODEM logs!";
                vibrate = true;
                icon = R.drawable.icon_red;
                extra = SaveLogs.MODEM_AUTO_SAVING;
                break;

            case NOTIFY_CRASH_RIL:
                tickerMsg = "Icera Debug Agent - RIL Error detected.";
                notifTitle = "IDA - RIL error";
                notifText = "Auto Saving done. Check the _RIL logs!";
                vibrate = true;
                icon = R.drawable.icon_red;
                extra = SaveLogs.MODEM_AUTO_SAVING;
                break;

            case NOTIFY_CRASH_APP:
                tickerMsg = "Icera Debug Agent - APP crash detected.";
                notifTitle = "IDA - APP Crash";
                notifText = "Auto Saving done. Check the _APP logs!";
                vibrate = true;
                icon = R.drawable.icon_red;
                extra = SaveLogs.MODEM_AUTO_SAVING;
                break;

            case NOTIFY_AUTO_SAVING:
                tickerMsg = "Icera Debug Agent - Auto Saving Detected.";
                notifTitle = "IDA - Modem Warning";
                notifText = "Auto Saving detected. Check the logs!";
                vibrate = true;
                icon = R.drawable.icon_orange2;
                extra = SaveLogs.MODEM_AUTO_SAVING;
                break;

            case NOTIFY_LOGGING_STOPPED:
                tickerMsg = "IDA - SDcard full";
                notifTitle = "IDA - Logging Stopped";
                notifText = "Delete old logs or change the log size and restart logging!";
                vibrate = true;
                icon = R.drawable.icon_red;
                pi = ic;
                break;

            case NOTIFY_SDCARD_LOW:
                tickerMsg = "IDA - SDcard almost full";
                notifTitle = "SDcard Free Space < 200Mo";
                notifText = "Delete old logs or change the log size !";
                vibrate = false;
                icon = R.drawable.icon_red;
                pi = ic;
                break;

            case NOTIFY_SDCARD_OK:
                tickerMsg = "IDA - SDcard OK";
                notifTitle = "Icera Debug Agent Running";
                notifText = "Loggers resumed";
                vibrate = false;
                icon = R.drawable.icon;
                break;

            case NOTIFY_DISCARD:
                tickerMsg = "Icera Debug Agent - Logs discarded";
                notifTitle = "Icera Debug Agent Running";
                notifText = "No error detected";
                vibrate = false;
                icon = R.drawable.icon;
                break;

            case NOTIFY_SAVING_OK:
                tickerMsg = "Icera Debug Agent - Logs saved ";
                notifTitle = "Icera Debug Agent Running";
                notifText = "No error detected";
                vibrate = false;
                icon = R.drawable.icon;
                break;

            case NOTIFY_INSUFFICIENT_SPACE:
                tickerMsg = "IDA - Insufficient space for modem logging";
                notifTitle = "IDA - Insufficient space for modem logging";
                //notifText = "At least 600M space needed for max space logging";
                notifText ="Insufficient space for modem logging";
                mStorageState = STORAGE_SPACE_LOGGING_STOP;
                vibrate = true;
                icon = R.drawable.icon_red;
                pi = ic; // new Intent(this, Settings.class);
                mBuilder.setAutoCancel(true);
                break;

            case NOTIFY_MODEM_LOGGING_FAILED:
                tickerMsg = "IDA - Modem logging failed";
                notifTitle = "IDA - Modem logging warn";
                notifText ="Modem logging failed";
                vibrate = true;
                icon = R.drawable.icon_red;
                extra = SaveLogs.MODEM_LOGGING_ISSUE;
                break;

            default:
                tickerMsg = "";
                notifTitle = "Icera Debug Agent Running";
                notifText = "No error detected";
                vibrate = false;
                icon = R.drawable.icon;
                break;
        }

        pi.putExtra("NotificationType", extra);
        mBuilder.setTicker(tickerMsg)
                .setSmallIcon(icon)
                .setWhen(System.currentTimeMillis())
                .setContentIntent(
                        PendingIntent.getActivity(this, 0, pi, PendingIntent.FLAG_CANCEL_CURRENT))
                .setContentTitle(notifTitle).setContentText(notifText).setOnlyAlertOnce(false)
                .setAutoCancel(true);

        if (vibrate)
            mBuilder.setVibrate(new long[] {
                    500L, 200L, 200L, 500L
            });

        mServiceNM.notify(NOTIFY_ME_ID, mBuilder.build());
    }

    private void notifyStartedAtForeground() {

        Intent pi = new Intent(this, SaveLogs.class);
        pi.putExtra("NotificationType", SaveLogs.NORMAL);

        mBuilder.setTicker("Icera Debug Agent - App started")
                .setContentTitle("Icera Debug Agent Running")
                .setContentText("No error detected")
                .setSmallIcon(R.drawable.icon)
                .setWhen(System.currentTimeMillis())
                .setVibrate(new long[] {
                        500L, 200L, 200L, 500L
                })
                .setContentIntent(
                        PendingIntent.getActivity(this, 0, pi, PendingIntent.FLAG_CANCEL_CURRENT));
        Notification n = mBuilder.build();
        n.flags |= Notification.FLAG_NO_CLEAR;

        // run in the foreground to avoid killing this service
        startForeground(NOTIFY_ME_ID, n);
    }

    private void stop() {

        stopForeground(true);

        mLoggerManager.stopAllAndClean(false, false);
    }

    @Override
    public void onCreate() {

        super.onCreate();

        mLoggerManager = new LoggerManager(this);

        mServiceNM = (NotificationManager)this.getSystemService(NOTIFICATION_SERVICE);
        mBuilder = new NotificationCompat.Builder(this);

        mTelephonyManager = (TelephonyManager) this.getSystemService(TELEPHONY_SERVICE);
        mTelephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_SERVICE_STATE);

        mThis = this;

        if (!mRegistered) {
            IntentFilter intentFilter;

            intentFilter = new IntentFilter();
            intentFilter.addAction(Intent.ACTION_MEDIA_MOUNTED);
            intentFilter.addAction(Intent.ACTION_MEDIA_UNMOUNTED);
            intentFilter.addAction(Intent.ACTION_MEDIA_REMOVED);
            intentFilter.addDataScheme("file");
            registerReceiver(mExternStorageReceiver, intentFilter);

            intentFilter = new IntentFilter();
            intentFilter.addAction(Intent.ACTION_DEVICE_STORAGE_LOW);
            intentFilter.addAction(Intent.ACTION_DEVICE_STORAGE_OK);
            intentFilter.addAction("android.intent.action.DEVICE_STORAGE_FULL");
            intentFilter.addAction("android.intent.action.DEVICE_STORAGE_NOT_FULL");
            intentFilter.addDataScheme("file");
            registerReceiver(mStorageLowFullReceiver, intentFilter);

            intentFilter = new IntentFilter(Intent.ACTION_SHUTDOWN);
            registerReceiver(mSystemShutdownReceiver, intentFilter);
        }

        EX = Executors.newScheduledThreadPool(1);
        EX.scheduleAtFixedRate(mExternStorageSpaceChecker, STORAGE_SPACE_CHECK_DELAY,
                STORAGE_SPACE_CHECK_DELAY, TimeUnit.SECONDS);

        notifyStartedAtForeground();
        mLoggerManager.startUserLoggers();
        mRunning = true;

        // Load CFUN states
        String[] CFUN0Keywords = new String[] {
                getString(R.string.AutoSaveCFUN0Msg)
        };
        String[] CFUN1Keywords = new String[] {
                getString(R.string.AutoSaveCFUN1Msg1),
                getString(R.string.AutoSaveCFUN1Msg2)
        };

        Resources res = getResources();
        // Load predefined scenarios
        mAutoSaveScenarios = new AutoSaveScenario[] {
                new AutoSaveScenario(R.string.AutoSaveSIMLost1, getString(R.string.AutoSaveSIMLost1), res.getInteger(R.integer.SIMLostDelay), getString(R.string.SIMLostDirName)),
                new AutoSaveScenario(R.string.AutoSaveSIMLost2, getString(R.string.AutoSaveSIMLost2), res.getInteger(R.integer.SIMLostDelay), getString(R.string.SIMLostDirName)),
                new AutoSaveScenario(R.string.AutoSaveNetworkLost, getString(R.string.AutoSaveNetworkLost), res.getInteger(R.integer.NetworkLostDelay), getString(R.string.NetworkLostDirName), getString(R.string.NetworkLostCancelKeyword), false),
                //new AutoSaveScenario(R.string.AutoSaveLocUpdateRej, getString(R.string.AutoSaveLocUpdateRej), res.getInteger(R.integer.LocUpdateRejDelay), getString(R.string.LocUpdateRejDirName)),
                //new AutoSaveScenario(R.string.AutoSaveDetach, getString(R.string.AutoSaveDetach), res.getInteger(R.integer.DetachDelay), getString(R.string.DetachDirName)),
                new AutoSaveScenario(R.string.AutoSaveDataStall, getString(R.string.AutoSaveDataStall), res.getInteger(R.integer.DataStallDelay), getString(R.string.DataStallDirName)),
                //new AutoSaveScenario(R.string.AutoSaveAttachRej, getString(R.string.AutoSaveAttachRej), res.getInteger(R.integer.AttachRejDelay), getString(R.string.AttachRejDirName)),
                //new AutoSaveScenario(R.string.AutoSavePDPActRej, getString(R.string.AutoSavePDPActRej), res.getInteger(R.integer.PDPActRejDelay), getString(R.string.PDPActRejDirName)),
                new AutoSaveScenario(R.string.AutoSaveCallDrop1, getString(R.string.AutoSaveCallDrop1), res.getInteger(R.integer.CallDropDelay), getString(R.string.CallDropDirName)),
                new AutoSaveScenario(R.string.AutoSaveCallDrop2, getString(R.string.AutoSaveCallDrop2), res.getInteger(R.integer.CallDropDelay), getString(R.string.CallDropDirName)),
        };
        
        mAutoSaveMonitor = new AutoSaveMonitor(mHandler, mAutoSaveScenarios, CFUN0Keywords, CFUN1Keywords);
        mAutoSaveMonitor.start();
        runAutoSavingMonitor(new Prefs(this).isAutoSavingEnabled());

        IntentFilter dropBoxfilter = new IntentFilter(DropBoxManager.ACTION_DROPBOX_ENTRY_ADDED);
        IntentFilter modemcrashfilter = new IntentFilter("ModemCrash");
        registerReceiver(crashReceiver, dropBoxfilter);
        registerReceiver(crashReceiver, modemcrashfilter);
    }

    @Override
    public void onDestroy() {

        Log.d(TAG, "onDestroy");

        mTelephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_NONE);

        if (mRegistered) {
            unregisterReceiver(mExternStorageReceiver);
            unregisterReceiver(mSystemShutdownReceiver);
            unregisterReceiver(mStorageLowFullReceiver);
            unregisterReceiver(crashReceiver);
            mRegistered = false;
        }

        stop();

        if (EX != null && !EX.isShutdown()) {
            EX.shutdown();
            EX = null;
        }

        mRunning = false;
    }

    @SuppressWarnings("unused")
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {

        return START_STICKY;
    }

    private Runnable mModemStateChecker = new Runnable() {

        @Override
        public void run() {

            LogReason reason = mLoggerManager.handleModemStateChange();

            switch (reason) {
                case CRASH_MODEM:
                    storeLogsAsync("", TYPE_MODEM_CRASH, true);
                    break;

                default:
                    break;
            }
        }
    };

    private Runnable mRilStateChecker = new Runnable() {

        @Override
        public void run() {

            LogReason reason = mLoggerManager.handleRilStateChange();

            switch (reason) {
                case CRASH_RIL:
                    storeLogsAsync("", TYPE_RIL_CRASH, true);
                    break;

                default:
                    break;
            }
        }
    };

    private boolean mRegistered = false;

    private BroadcastReceiver mSystemShutdownReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {

            Log.d(TAG, "System shutdown: stop logging");

            if (mLoggerManager != null) {
                mLoggerManager.stopAllAndClean(false, false);
            }

        }
    };

    /**
     * BroadcastReceiver for detecting crashes,it process crashes if its in
     * ERRORTYPES lists, else returns
     *
     */
    public BroadcastReceiver crashReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String dropBoxTag = intent.getStringExtra("tag");
            Log.i(TAG, "intent details :" + dropBoxTag);

            if (dropBoxTag.contains("modem_crash")) {
                mHandler.postDelayed(mModemStateChecker, 10);
                return;
            }
            else if (dropBoxTag.contains("data_app_wtf") || dropBoxTag.contains("system_app_wtf")) {
                DropBoxManager dbox = (DropBoxManager)getSystemService(Context.DROPBOX_SERVICE);
                DropBoxManager.Entry entry = dbox.getNextEntry("system_app_wtf", System.currentTimeMillis() - 3000);
                if (entry == null) {
                   entry = dbox.getNextEntry("data_app_wtf", System.currentTimeMillis() - 3000);
                }
                if (entry != null) {
                   String str = entry.getText(1000);
                   entry.close();
                   if (str.contains("icera.DebugAgent")) {
                      Log.e(TAG, "Detect wtf for itself, discard it.");
                      return;
                   }
                }
            }

            if (!Arrays.asList(ERRORTYPES).contains(dropBoxTag)) {
                Log.i(TAG, "Error type not in Monitoring lists");
                return;
            }
            Log.d(TAG, "BroadcastReceiver crashReceiver detect!");
            mHandler.sendEmptyMessage(MSG_APP_CRASH_DETECT);
        };
    };

    private PhoneStateListener mPhoneStateListener = new PhoneStateListener() {

        @Override
        public void onServiceStateChanged(ServiceState serviceState) {

            int state = serviceState.getState();
            Log.d(TAG, "Got SERVICE_STATE broadcast: " + state);

            switch (state) {
              case ServiceState.STATE_POWER_OFF:
                  mHandler.postDelayed(mRilStateChecker, 10000);
                  break;

              case ServiceState.STATE_OUT_OF_SERVICE:
              case ServiceState.STATE_IN_SERVICE:
              case ServiceState.STATE_EMERGENCY_ONLY:
              default:
                  break;
          }
        }
    };

    public LoggerManager getLoggerManager() {
        return mLoggerManager;
    }

    public void storeLogsAsync(String dirname, boolean crash) {

        if (!crash) {
            mLoggerManager.stopAllToStore(false);
        } else
            dirname = "";
        mHandler.sendEmptyMessage(BugReportService.MSG_CANCEL_AUTO_SAVING);

        new StoreLogsAsync().execute(dirname, null); // TODO: use the specified
                                               // directory
    }

    public void storeLogsAsync(String dirname, String notify, boolean crash) {

        if (!crash) {
            mLoggerManager.stopAllToStore(false);
        } else
            dirname = "";
        //if (notify != TYPE_AUTO_SAVING)
        //{
        //    mHandler.sendEmptyMessage(BugReportService.MSG_CANCEL_AUTO_SAVING);
        //}

        new StoreLogsAsync().execute(dirname, notify); // TODO: use the specified
    }

    public class StoreLogsAsync extends AsyncTask<String, String, Boolean> {

        private static final String TAG = "StoreLogsAsync";
        private String mType = null;
        @Override
        protected void onPreExecute() {

            mBuilder.setContentTitle("IDA - Store Logs")
                    .setContentText("Store in Progress ...")
                    .setSmallIcon(R.drawable.icon_red)
                    .setTicker("Icera Debug Agent - Storing Logs").setProgress(100, 0, false)
                    .setContentIntent(null);
            mServiceNM.notify(NOTIFY_ME_ID, mBuilder.build());
        }

        @Override
        protected Boolean doInBackground(String... dirname) {
            Log.d(TAG, "Store logs asynchrously to " + dirname[0]);
            Log.d(TAG, "Store logs asynchrously to " + dirname[1]);
            mType = dirname[1];

            LogUtil.StoreProgressListener spl = new icera.DebugAgent.LogUtil.StoreProgressListener() {

                @Override
                public void storeProgressUpdate(int progress) {

                    publishProgress(String.valueOf(progress));
                }

            };

            if (dirname[0].contentEquals("")){
                mLoggerManager.storeLogs(spl);
            }
            else
                mLoggerManager.storeLogs(dirname[0], spl);
            return true;
        }

        @Override
        protected void onProgressUpdate(String... progress) {
            mBuilder.setProgress(100, Integer.parseInt(progress[0]), false);
            mBuilder.setVibrate(null);
            mServiceNM.notify(NOTIFY_ME_ID, mBuilder.build());
        }

        @Override
        protected void onPostExecute(Boolean result) {

            if (mType == TYPE_MODEM_CRASH){
                notifyMessage(NotificationType.NOTIFY_CRASH_MODEM);
                mHandler.sendEmptyMessage(MSG_AUTO_SAVING_FINISHED);
            }
            else if (mType == TYPE_RIL_CRASH){
                notifyMessage(NotificationType.NOTIFY_CRASH_RIL);
                mHandler.sendEmptyMessage(MSG_AUTO_SAVING_FINISHED);
            }
            else if (mType == TYPE_APP_CRASH){
                notifyMessage(NotificationType.NOTIFY_CRASH_APP);
                mHandler.sendEmptyMessage(MSG_AUTO_SAVING_FINISHED);
            }
            else if (mType == TYPE_AUTO_SAVING){
                notifyMessage(NotificationType.NOTIFY_AUTO_SAVING);
                mHandler.sendEmptyMessage(MSG_AUTO_SAVING_FINISHED);
            }
            else{
                Intent pi = new Intent(mThis, SaveLogs.class);
                pi.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
                pi.putExtra("NotificationType", SaveLogs.NORMAL);
                mBuilder.setContentTitle("Icera Debug Agent Running")
                        .setContentText("No error detected")
                        .setSmallIcon(R.drawable.icon)
                        .setProgress(0, 0, false)
                        .setTicker("Icera Debug Agent - Store completed")
                        .setContentIntent(
                                PendingIntent.getActivity(mThis, 0, pi,
                                        PendingIntent.FLAG_CANCEL_CURRENT)).setOnlyAlertOnce(true)
                // .setAutoCancel(true)
                // .setDeleteIntent(PendingIntent.getActivity(mThis, 0, pi,
                // PendingIntent.FLAG_CANCEL_CURRENT))
                ;
                mServiceNM.notify(NOTIFY_ME_ID, mBuilder.build());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
            // resume loggers
            mLoggerManager.resumeLoggers();
        }
    }
    public void runAutoSavingMonitor(boolean bl){
        Prefs prefs = new Prefs(this);
        if (bl) {
            AutoSaveScenario.setEnable(getString(R.string.AutoSaveNetworkLost), prefs.isNetworkLostEnabled());
            AutoSaveScenario.setEnable(getString(R.string.AutoSaveDetach), false);
            AutoSaveScenario.setEnable(getString(R.string.AutoSaveDataStall), prefs.isDataStallEnabled());
            AutoSaveScenario.setEnable(getString(R.string.AutoSaveSIMLost1), prefs.isSimLostEnabled());
            AutoSaveScenario.setEnable(getString(R.string.AutoSaveSIMLost2), prefs.isSimLostEnabled());
            AutoSaveScenario.setEnable(getString(R.string.AutoSaveCallDrop1), prefs.isCallDropEnabled());
            AutoSaveScenario.setEnable(getString(R.string.AutoSaveCallDrop2), prefs.isCallDropEnabled());

            // For network lost, we need to check if the user has selected "unrecoverable network lost". if yes, we need to make Network lost cancelable.
            AutoSaveScenario scNetworkLost = null;
            for (AutoSaveScenario sc : mAutoSaveScenarios)
                if (sc.id == R.string.AutoSaveNetworkLost)
                    scNetworkLost = sc;

            if (scNetworkLost != null) {
                if (prefs.isNetworkLostEnabled())
                    scNetworkLost.setCancelable(false);
                if (prefs.isUnrecoverNetworkLostEnabled())
                    scNetworkLost.setCancelable(true);
            }

            mAutoSaveMonitor.resumeParsing();
        }
        else
            mAutoSaveMonitor.stopParsing();
    }
}
