/*************************************************************************************************
 *
 * Copyright (c) 2013, NVIDIA CORPORATION.  All rights reserved.
 *
 ************************************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "logging_checker.h"
#include "pattern_checker.h"
#include "getopt.h"
#include "logs.h"

#include "socket.h"
#include "iom_data.h"

//-----------------------------------------------------------------------------------------------
/* Utility to display a progress bar
 *
 * Process has done i out of n rounds,
 * and we want a bar of width w and resolution r.
 */
static inline void loadBar(int x, int n, int r, int w)
{
    int y;
    // Only update r times.
    if ( x % (n/r) != 0 ) return;

    // Calculuate the ratio of complete-to-incomplete.
    float ratio = x/(float)n;
    int   c     = (int)(ratio * (float)w);

    // Show the percentage complete.
    printf("%3d%% [", (int)(ratio*100) );

    // Show the load bar.
    for (y=0; y<c; y++)
       printf("=");

    for (y=c; y<w; y++)
       printf(" ");

    printf("]");
    printf("\r"); // Move to the first column
    fflush(stdout);
}

//-----------------------------------------------------------------------------------------------
static void usage(void)
{
    ALOGI( "This tool is used to parse a logging iom file generated by icera_log_serial.");
    ALOGI( "Or to stream in real time the content captured by icera_log_serial server socket.");
    ALOGI( "The checker can verify the integrity of the logging, and will display an error");
    ALOGI( "in the case it is badly formatted, contains gaps or corruptions.");
    ALOGI( "logging_checker -i [<iom filename>] [Options]");
    ALOGI( "logging_checker -s [<port  number>] [Options]");
    ALOGI( " Options:");
    ALOGI( "  -i<filename> IOM input file or use -s option below to use a socket");
    ALOGI( "  -s<port_num> Open a socket client as the IOM input stream.");
    ALOGI( "  -d           Specify that the logging content in the iom is filled with");
    ALOGI( "               debug information instead of normal logging data. Do not use");
    ALOGI( "               this option on normal logging as this will trigger false errors.");
    ALOGI( "  -p           Specify that the iom content is not logging but debug pattern.");
    ALOGI( "  -o<filename> Generate a txt output file with details of the checker analysis.");
    ALOGI( "               The resulting file may be really big, so use the below option");
    ALOGI( "               to reduce its size.");
    ALOGI( "  -l<size MB>  Only produce output file content when reaching the last MB");
    ALOGI( "               (specified here) of the input file.");
    ALOGI( "  -h           Display this help.");
    ALOGI( " ");
    exit(0);
}

//-----------------------------------------------------------------------------------------------
typedef struct
{
   char         in_filename[256];
   char         out_filename[256];
   unsigned int output_only_the_last_x_mbytes;
   unsigned int logging_data_is_debug;
   unsigned int logging_data_is_pattern;
   int          socket_port_num;
} t_logging_checker_args;

//-----------------------------------------------------------------------------------------------
static void ParseArgs(int argc, char * argv[], t_logging_checker_args * args)
{
    if (argc == 1)
    {
        usage();
        exit(0);
    }
    else
    {
        // Parse args
        char opt_char;
        int  getoptVal;
        while ( (getoptVal = Getopt (argc, argv, "i:dpo:l:s:h")) != -1 )
        {
            opt_char = (char)getoptVal;
            switch ( opt_char )
            {
            case 'i':
                if (optarg == NULL)
                {
                    ALOGE("The -i (input filename) must specify a filename");
                }
                else
                {
                    strcpy(args->in_filename, optarg);
                }
                break;
            case 'd':
                if (optarg == NULL)
                {
                    args->logging_data_is_debug = 1;
                }
                else
                {
                    ALOGE("The -d (logging with debug data) does not take an argument.");
                }
                break;
            case 'p':
                if (optarg == NULL)
                {
                    args->logging_data_is_pattern = 1;
                }
                else
                {
                    ALOGE("The -p (logging with pattern data) does not take an argument.");
                }
                break;
            case 'o':
                if (optarg == NULL)
                {
                    ALOGE("The -o (output filename) must specify a filename");
                }
                else
                {
                    strcpy(args->out_filename, optarg);
                }
                break;
            case 'l':
                if (optarg == NULL)
                {
                    ALOGE("The -l (process MB size for output) must specify a value");
                }
                else
                {
                    args->output_only_the_last_x_mbytes = strtol(optarg, NULL, 0);
                }
                break;
            case 's':
                if (optarg == NULL)
                {
                    ALOGE("The -s (socket mode) must specify a the port number");
                }
                else
                {
                    args->socket_port_num = strtol(optarg, NULL, 0);
                }
                break;
            case 'h':
                usage();
                break;
            default:
                usage();
                exit (EXIT_FAILURE);
                break;
            }
        } /* while */
    }
}

//-----------------------------------------------------------------------------------------------

#define DATA_READ_BUFFER_SIZE_FILE (16*0x100000)
#define DATA_READ_BUFFER_SIZE_SOCKET (20000)

//-----------------------------------------------------------------------------------------------
int main(int argc, char* argv[])
{
   t_logging_checker_args args;
   int error_detected = 0;
   t_parseContext ctx;
   IomData * iom_data;

   ALOGI("Logging checker, v1.1");

   /* Cmd line arguments */
   memset(&args, 0, sizeof(t_logging_checker_args));
   ParseArgs(argc, argv, &args);

   /* iom_data allocation */
   iom_data = new IomData((args.socket_port_num != 0) ? DATA_READ_BUFFER_SIZE_SOCKET:DATA_READ_BUFFER_SIZE_FILE);
   if (!iom_data)
   {
      ALOGE("Could not allocate iom_data");
      return 0;
   }

   if (args.socket_port_num != 0)
   {
      if (!iom_data->SetSourceIsSocket(args.socket_port_num))
      {
         ALOGE("Could not open or connect socket");
         return 0;
      }
      printf("Reading on socket port %d...\n", args.socket_port_num);
   }
   else
   {
      if (!iom_data->SetSourceIsFile(args.in_filename))
      {
         ALOGE("Could not open input file");
         return 0;
      }
   }

   /* last MB option for output file */
   if (args.socket_port_num != 0)
   {
      args.output_only_the_last_x_mbytes = 0;
      args.out_filename[0] = 0;
   }
   else
   {
      if (args.output_only_the_last_x_mbytes == 0) /* if this limit is not specified in the command line, then output everything */
      {
         args.output_only_the_last_x_mbytes = (int)(iom_data->GetFileSize()/0x100000) + 1;
      }
   }

   /* init */
   if (args.logging_data_is_pattern)
   {
      parse_pattern_init(&ctx);
   }
   else
   {
      logging_checker_init(args.out_filename, args.output_only_the_last_x_mbytes, args.logging_data_is_debug, iom_data->GetFileSize());
   }

   long long nb_read;
   int old_percent = 0, percent = 0;

   if (!args.socket_port_num)
      loadBar(0, 100, 100, 30);

   /* Checker loop */
   while(iom_data->HasData())
   {
      nb_read = iom_data->Read();
      percent = iom_data->getProgressPercent();

      if (args.socket_port_num != 0)   /* SOCKET */
      {
         int throughput_str_index = 0;
         const char * throughput_str[] = {"[   ]", "[#  ]", "[## ]", "[###]"};
         throughput_str_index = (int)((nb_read * 3) / DATA_READ_BUFFER_SIZE_SOCKET);
         printf("%s Total read: %lldKB      \r", throughput_str[throughput_str_index], iom_data->GetTotalNbRead()/1000);
      }
      else                             /* FILE */
      {
         if (old_percent != percent)
         {
            loadBar(percent, 100, 100, 30);
            old_percent = percent;
         }
      }


      if (args.logging_data_is_pattern)
      {
         if (parse_pattern(&ctx, iom_data->GetBuffer(), (int)nb_read/4) != 0)
         {
            error_detected = 1;
            break;
         }
      }
      else
      {
          if (logging_checker_process(iom_data->GetBuffer(), (int)nb_read) != 0)
          {
             error_detected = 1;
             break;
          }
      }
   }

   if (args.logging_data_is_pattern)
   {
      if (error_detected)
      {
         ALOGI("Pattern failed at 0x%08x", ctx.errorAt);
         ALOGI("expected 0x%x, got 0x%x", ctx.expected_count, ctx.errorCount);
      }
      ALOGI("Checked length 0x%08x", ctx.gFileOffset);
   }
   else
   {
      logging_checker_finish();
   }

   delete iom_data;

   if (error_detected)
   {
      ALOGE("FAILED: Errors were detected in logging");
      return 1;
   }

   ALOGI("SUCCESS : No errors in logging");
   return 0;
}