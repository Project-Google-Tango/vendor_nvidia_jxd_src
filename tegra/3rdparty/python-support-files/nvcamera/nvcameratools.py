# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_nvcameratools', [dirname(__file__)])
        except ImportError:
            import _nvcameratools
            return _nvcameratools
        if fp is not None:
            try:
                _mod = imp.load_module('_nvcameratools', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _nvcameratools = swig_import_helper()
    del swig_import_helper
else:
    import _nvcameratools
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


# Copyright (c) 2013-2014, NVIDIA Corporation.  All rights reserved.
#
# NVIDIA Corporation and its licensors retain all intellectual property
# and proprietary rights in and to this software, related documentation
# and any modifications thereto.  Any use, reproduction, disclosure or
# distribution of this software and related documentation without an express
# license agreement from NVIDIA Corporation is strictly prohibited.
#

NV_FALSE = _nvcameratools.NV_FALSE
NV_TRUE = _nvcameratools.NV_TRUE
class NvSize(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NvSize, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NvSize, name)
    __repr__ = _swig_repr
    __swig_setmethods__["width"] = _nvcameratools.NvSize_width_set
    __swig_getmethods__["width"] = _nvcameratools.NvSize_width_get
    if _newclass:width = _swig_property(_nvcameratools.NvSize_width_get, _nvcameratools.NvSize_width_set)
    __swig_setmethods__["height"] = _nvcameratools.NvSize_height_set
    __swig_getmethods__["height"] = _nvcameratools.NvSize_height_get
    if _newclass:height = _swig_property(_nvcameratools.NvSize_height_get, _nvcameratools.NvSize_height_set)
    def __init__(self):
        this = _nvcameratools.new_NvSize()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _nvcameratools.delete_NvSize
    __del__ = lambda self : None;
NvSize_swigregister = _nvcameratools.NvSize_swigregister
NvSize_swigregister(NvSize)

class PropertyData(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PropertyData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PropertyData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["u8"] = _nvcameratools.PropertyData_u8_set
    __swig_getmethods__["u8"] = _nvcameratools.PropertyData_u8_get
    if _newclass:u8 = _swig_property(_nvcameratools.PropertyData_u8_get, _nvcameratools.PropertyData_u8_set)
    __swig_setmethods__["u32"] = _nvcameratools.PropertyData_u32_set
    __swig_getmethods__["u32"] = _nvcameratools.PropertyData_u32_get
    if _newclass:u32 = _swig_property(_nvcameratools.PropertyData_u32_get, _nvcameratools.PropertyData_u32_set)
    __swig_setmethods__["i32"] = _nvcameratools.PropertyData_i32_set
    __swig_getmethods__["i32"] = _nvcameratools.PropertyData_i32_get
    if _newclass:i32 = _swig_property(_nvcameratools.PropertyData_i32_get, _nvcameratools.PropertyData_i32_set)
    __swig_setmethods__["f"] = _nvcameratools.PropertyData_f_set
    __swig_getmethods__["f"] = _nvcameratools.PropertyData_f_get
    if _newclass:f = _swig_property(_nvcameratools.PropertyData_f_get, _nvcameratools.PropertyData_f_set)
    __swig_setmethods__["u64"] = _nvcameratools.PropertyData_u64_set
    __swig_getmethods__["u64"] = _nvcameratools.PropertyData_u64_get
    if _newclass:u64 = _swig_property(_nvcameratools.PropertyData_u64_get, _nvcameratools.PropertyData_u64_set)
    __swig_setmethods__["d"] = _nvcameratools.PropertyData_d_set
    __swig_getmethods__["d"] = _nvcameratools.PropertyData_d_get
    if _newclass:d = _swig_property(_nvcameratools.PropertyData_d_get, _nvcameratools.PropertyData_d_set)
    def __init__(self):
        this = _nvcameratools.new_PropertyData()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _nvcameratools.delete_PropertyData
    __del__ = lambda self : None;
PropertyData_swigregister = _nvcameratools.PropertyData_swigregister
PropertyData_swigregister(PropertyData)

class NvMMCameraSensorMode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NvMMCameraSensorMode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NvMMCameraSensorMode, name)
    __repr__ = _swig_repr
    __swig_setmethods__["Resolution"] = _nvcameratools.NvMMCameraSensorMode_Resolution_set
    __swig_getmethods__["Resolution"] = _nvcameratools.NvMMCameraSensorMode_Resolution_get
    if _newclass:Resolution = _swig_property(_nvcameratools.NvMMCameraSensorMode_Resolution_get, _nvcameratools.NvMMCameraSensorMode_Resolution_set)
    __swig_setmethods__["FrameRate"] = _nvcameratools.NvMMCameraSensorMode_FrameRate_set
    __swig_getmethods__["FrameRate"] = _nvcameratools.NvMMCameraSensorMode_FrameRate_get
    if _newclass:FrameRate = _swig_property(_nvcameratools.NvMMCameraSensorMode_FrameRate_get, _nvcameratools.NvMMCameraSensorMode_FrameRate_set)
    def __init__(self):
        this = _nvcameratools.new_NvMMCameraSensorMode()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _nvcameratools.delete_NvMMCameraSensorMode
    __del__ = lambda self : None;
NvMMCameraSensorMode_swigregister = _nvcameratools.NvMMCameraSensorMode_swigregister
NvMMCameraSensorMode_swigregister(NvMMCameraSensorMode)

NvCameraCoreUseCase_Preview = _nvcameratools.NvCameraCoreUseCase_Preview
NvCameraCoreUseCase_Still = _nvcameratools.NvCameraCoreUseCase_Still
NvCameraCoreUseCase_Video = _nvcameratools.NvCameraCoreUseCase_Video
NvCameraCoreUseCase_VideoSnapshot = _nvcameratools.NvCameraCoreUseCase_VideoSnapshot
NvCameraCoreUseCase_ZSL = _nvcameratools.NvCameraCoreUseCase_ZSL
NvCameraCoreUseCase_Force32 = _nvcameratools.NvCameraCoreUseCase_Force32
NvError_Success = _nvcameratools.NvError_Success
NvError_NotImplemented = _nvcameratools.NvError_NotImplemented
NvError_NotSupported = _nvcameratools.NvError_NotSupported
NvError_NotInitialized = _nvcameratools.NvError_NotInitialized
NvError_BadParameter = _nvcameratools.NvError_BadParameter
NvError_Timeout = _nvcameratools.NvError_Timeout
NvError_InsufficientMemory = _nvcameratools.NvError_InsufficientMemory
NvError_ReadOnlyAttribute = _nvcameratools.NvError_ReadOnlyAttribute
NvError_InvalidState = _nvcameratools.NvError_InvalidState
NvError_InvalidAddress = _nvcameratools.NvError_InvalidAddress
NvError_InvalidSize = _nvcameratools.NvError_InvalidSize
NvError_BadValue = _nvcameratools.NvError_BadValue
NvError_AlreadyAllocated = _nvcameratools.NvError_AlreadyAllocated
NvError_Busy = _nvcameratools.NvError_Busy
NvError_ModuleNotPresent = _nvcameratools.NvError_ModuleNotPresent
NvError_ResourceError = _nvcameratools.NvError_ResourceError
NvError_CountMismatch = _nvcameratools.NvError_CountMismatch
NvError_InsufficientVideoMemory = _nvcameratools.NvError_InsufficientVideoMemory
NvError_BadSurfaceColorScheme = _nvcameratools.NvError_BadSurfaceColorScheme
NvError_InvalidSurface = _nvcameratools.NvError_InvalidSurface
NvError_SurfaceNotSupported = _nvcameratools.NvError_SurfaceNotSupported
NvError_DispInitFailed = _nvcameratools.NvError_DispInitFailed
NvError_DispAlreadyAttached = _nvcameratools.NvError_DispAlreadyAttached
NvError_DispTooManyDisplays = _nvcameratools.NvError_DispTooManyDisplays
NvError_DispNoDisplaysAttached = _nvcameratools.NvError_DispNoDisplaysAttached
NvError_DispModeNotSupported = _nvcameratools.NvError_DispModeNotSupported
NvError_DispNotFound = _nvcameratools.NvError_DispNotFound
NvError_DispAttachDissallowed = _nvcameratools.NvError_DispAttachDissallowed
NvError_DispTypeNotSupported = _nvcameratools.NvError_DispTypeNotSupported
NvError_DispAuthenticationFailed = _nvcameratools.NvError_DispAuthenticationFailed
NvError_DispNotAttached = _nvcameratools.NvError_DispNotAttached
NvError_DispSamePwrState = _nvcameratools.NvError_DispSamePwrState
NvError_DispEdidFailure = _nvcameratools.NvError_DispEdidFailure
NvError_DispDsiReadAckError = _nvcameratools.NvError_DispDsiReadAckError
NvError_DispDsiReadInvalidResp = _nvcameratools.NvError_DispDsiReadInvalidResp
NvError_FileWriteFailed = _nvcameratools.NvError_FileWriteFailed
NvError_FileReadFailed = _nvcameratools.NvError_FileReadFailed
NvError_EndOfFile = _nvcameratools.NvError_EndOfFile
NvError_FileOperationFailed = _nvcameratools.NvError_FileOperationFailed
NvError_DirOperationFailed = _nvcameratools.NvError_DirOperationFailed
NvError_EndOfDirList = _nvcameratools.NvError_EndOfDirList
NvError_ConfigVarNotFound = _nvcameratools.NvError_ConfigVarNotFound
NvError_InvalidConfigVar = _nvcameratools.NvError_InvalidConfigVar
NvError_LibraryNotFound = _nvcameratools.NvError_LibraryNotFound
NvError_SymbolNotFound = _nvcameratools.NvError_SymbolNotFound
NvError_MemoryMapFailed = _nvcameratools.NvError_MemoryMapFailed
NvError_IoctlFailed = _nvcameratools.NvError_IoctlFailed
NvError_AccessDenied = _nvcameratools.NvError_AccessDenied
NvError_DeviceNotFound = _nvcameratools.NvError_DeviceNotFound
NvError_KernelDriverNotFound = _nvcameratools.NvError_KernelDriverNotFound
NvError_FileNotFound = _nvcameratools.NvError_FileNotFound
NvError_SpiReceiveError = _nvcameratools.NvError_SpiReceiveError
NvError_SpiTransmitError = _nvcameratools.NvError_SpiTransmitError
NvError_HsmmcCardNotPresent = _nvcameratools.NvError_HsmmcCardNotPresent
NvError_HsmmcControllerBusy = _nvcameratools.NvError_HsmmcControllerBusy
NvError_HsmmcAutoDetectCard = _nvcameratools.NvError_HsmmcAutoDetectCard
NvError_SdioCardNotPresent = _nvcameratools.NvError_SdioCardNotPresent
NvError_SdioInstanceTaken = _nvcameratools.NvError_SdioInstanceTaken
NvError_SdioControllerBusy = _nvcameratools.NvError_SdioControllerBusy
NvError_SdioReadFailed = _nvcameratools.NvError_SdioReadFailed
NvError_SdioWriteFailed = _nvcameratools.NvError_SdioWriteFailed
NvError_SdioBadBlockSize = _nvcameratools.NvError_SdioBadBlockSize
NvError_SdioClockNotConfigured = _nvcameratools.NvError_SdioClockNotConfigured
NvError_SdioSdhcPatternIntegrityFailed = _nvcameratools.NvError_SdioSdhcPatternIntegrityFailed
NvError_SdioCommandFailed = _nvcameratools.NvError_SdioCommandFailed
NvError_SdioCardAlwaysPresent = _nvcameratools.NvError_SdioCardAlwaysPresent
NvError_SdioAutoDetectCard = _nvcameratools.NvError_SdioAutoDetectCard
NvError_UsbInvalidEndpoint = _nvcameratools.NvError_UsbInvalidEndpoint
NvError_UsbfTxfrActive = _nvcameratools.NvError_UsbfTxfrActive
NvError_UsbfTxfrComplete = _nvcameratools.NvError_UsbfTxfrComplete
NvError_UsbfTxfrFail = _nvcameratools.NvError_UsbfTxfrFail
NvError_UsbfEpStalled = _nvcameratools.NvError_UsbfEpStalled
NvError_UsbfCableDisConnected = _nvcameratools.NvError_UsbfCableDisConnected
NvError_UartOverrun = _nvcameratools.NvError_UartOverrun
NvError_UartFraming = _nvcameratools.NvError_UartFraming
NvError_UartParity = _nvcameratools.NvError_UartParity
NvError_UartBreakReceived = _nvcameratools.NvError_UartBreakReceived
NvError_I2cReadFailed = _nvcameratools.NvError_I2cReadFailed
NvError_I2cWriteFailed = _nvcameratools.NvError_I2cWriteFailed
NvError_I2cDeviceNotFound = _nvcameratools.NvError_I2cDeviceNotFound
NvError_I2cInternalError = _nvcameratools.NvError_I2cInternalError
NvError_I2cArbitrationFailed = _nvcameratools.NvError_I2cArbitrationFailed
NvError_IdeHwError = _nvcameratools.NvError_IdeHwError
NvError_IdeReadError = _nvcameratools.NvError_IdeReadError
NvError_IdeWriteError = _nvcameratools.NvError_IdeWriteError
NvError_OwrReadFailed = _nvcameratools.NvError_OwrReadFailed
NvError_OwrWriteFailed = _nvcameratools.NvError_OwrWriteFailed
NvError_OwrBitTransferFailed = _nvcameratools.NvError_OwrBitTransferFailed
NvError_OwrInvalidOffset = _nvcameratools.NvError_OwrInvalidOffset
NvError_InvalidOperation = _nvcameratools.NvError_InvalidOperation
NvError_RmInitFailed = _nvcameratools.NvError_RmInitFailed
NvError_RmChannelInitFailure = _nvcameratools.NvError_RmChannelInitFailure
NvError_RmStreamInitFailure = _nvcameratools.NvError_RmStreamInitFailure
NvError_RmSyncPointAllocFailure = _nvcameratools.NvError_RmSyncPointAllocFailure
NvError_ResourceAlreadyInUse = _nvcameratools.NvError_ResourceAlreadyInUse
NvError_DmaBusy = _nvcameratools.NvError_DmaBusy
NvError_InvalidSourceId = _nvcameratools.NvError_InvalidSourceId
NvError_DmaChannelNotAvailable = _nvcameratools.NvError_DmaChannelNotAvailable
NvError_NoConnectedImager = _nvcameratools.NvError_NoConnectedImager
NvError_UnsupportedResolution = _nvcameratools.NvError_UnsupportedResolution
NvError_I2CCommunicationError = _nvcameratools.NvError_I2CCommunicationError
NvError_IspConfigFileParseError = _nvcameratools.NvError_IspConfigFileParseError
NvError_TooDark = _nvcameratools.NvError_TooDark
NvError_InvalidIspConfigAttribute = _nvcameratools.NvError_InvalidIspConfigAttribute
NvError_InvalidIspConfigAttributeElement = _nvcameratools.NvError_InvalidIspConfigAttributeElement
NvError_IspConfigSyntaxError = _nvcameratools.NvError_IspConfigSyntaxError
NvError_ImagerVersionNotSupported = _nvcameratools.NvError_ImagerVersionNotSupported
NvError_CorruptedBuffer = _nvcameratools.NvError_CorruptedBuffer
NvError_UnderConfident = _nvcameratools.NvError_UnderConfident
NvError_TestApplicationFailed = _nvcameratools.NvError_TestApplicationFailed
NvError_TestNoUserInput = _nvcameratools.NvError_TestNoUserInput
NvError_TestCommandLineError = _nvcameratools.NvError_TestCommandLineError
NvError_TestDataVerificationFailed = _nvcameratools.NvError_TestDataVerificationFailed
NvError_TestServerFileReadFailed = _nvcameratools.NvError_TestServerFileReadFailed
NvError_TestServerInvalidAddress = _nvcameratools.NvError_TestServerInvalidAddress
NvError_TestServerMemoryLimitExceeded = _nvcameratools.NvError_TestServerMemoryLimitExceeded
NvError_ColorFormatNotSupported = _nvcameratools.NvError_ColorFormatNotSupported
NvError_TransportPortAlreadyExist = _nvcameratools.NvError_TransportPortAlreadyExist
NvError_TransportMessageBoxEmpty = _nvcameratools.NvError_TransportMessageBoxEmpty
NvError_TransportMessageBoxFull = _nvcameratools.NvError_TransportMessageBoxFull
NvError_TransportConnectionFailed = _nvcameratools.NvError_TransportConnectionFailed
NvError_TransportNotConnected = _nvcameratools.NvError_TransportNotConnected
NvError_NandReadFailed = _nvcameratools.NvError_NandReadFailed
NvError_NandProgramFailed = _nvcameratools.NvError_NandProgramFailed
NvError_NandEraseFailed = _nvcameratools.NvError_NandEraseFailed
NvError_NandCopyBackFailed = _nvcameratools.NvError_NandCopyBackFailed
NvError_NandOperationFailed = _nvcameratools.NvError_NandOperationFailed
NvError_NandBusy = _nvcameratools.NvError_NandBusy
NvError_NandNotOpened = _nvcameratools.NvError_NandNotOpened
NvError_NandAlreadyOpened = _nvcameratools.NvError_NandAlreadyOpened
NvError_NandBadOperationRequest = _nvcameratools.NvError_NandBadOperationRequest
NvError_NandCommandQueueError = _nvcameratools.NvError_NandCommandQueueError
NvError_NandReadEccFailed = _nvcameratools.NvError_NandReadEccFailed
NvError_NandFlashNotSupported = _nvcameratools.NvError_NandFlashNotSupported
NvError_NandLockFailed = _nvcameratools.NvError_NandLockFailed
NvError_NandErrorThresholdReached = _nvcameratools.NvError_NandErrorThresholdReached
NvError_NandWriteFailed = _nvcameratools.NvError_NandWriteFailed
NvError_NandBadBlock = _nvcameratools.NvError_NandBadBlock
NvError_NandBadState = _nvcameratools.NvError_NandBadState
NvError_NandBlockIsLocked = _nvcameratools.NvError_NandBlockIsLocked
NvError_NandNoFreeBlock = _nvcameratools.NvError_NandNoFreeBlock
NvError_NandTTFailed = _nvcameratools.NvError_NandTTFailed
NvError_NandTLFailed = _nvcameratools.NvError_NandTLFailed
NvError_NandTLNoBlockAssigned = _nvcameratools.NvError_NandTLNoBlockAssigned
NvError_WinSysBadDisplay = _nvcameratools.NvError_WinSysBadDisplay
NvError_WinSysNoDevice = _nvcameratools.NvError_WinSysNoDevice
NvError_WinSysBadDrawable = _nvcameratools.NvError_WinSysBadDrawable
NvError_BLServerFileReadFailed = _nvcameratools.NvError_BLServerFileReadFailed
NvError_BLServerInvalidAddress = _nvcameratools.NvError_BLServerInvalidAddress
NvError_BLServerInvalidElfFile = _nvcameratools.NvError_BLServerInvalidElfFile
NvError_BLServerConnectionFailed = _nvcameratools.NvError_BLServerConnectionFailed
NvError_BLServerMemoryLimitExceeded = _nvcameratools.NvError_BLServerMemoryLimitExceeded
NvError_AudioMixerPinTypeNotSupported = _nvcameratools.NvError_AudioMixerPinTypeNotSupported
NvError_AudioMixerDirectionNotSupported = _nvcameratools.NvError_AudioMixerDirectionNotSupported
NvError_AudioMixerNoMorePinsAvailable = _nvcameratools.NvError_AudioMixerNoMorePinsAvailable
NvError_AudioMixerBadPinNumber = _nvcameratools.NvError_AudioMixerBadPinNumber
NvError_VideoEncResolutionNotSupported = _nvcameratools.NvError_VideoEncResolutionNotSupported
NvError_JPEGEncHWError = _nvcameratools.NvError_JPEGEncHWError
NvError_VideoDecRetainLock = _nvcameratools.NvError_VideoDecRetainLock
NvError_VideoDecMataDataFound = _nvcameratools.NvError_VideoDecMataDataFound
NvError_VideoDecFrameDecoded = _nvcameratools.NvError_VideoDecFrameDecoded
NvError_VideoDecDecodedPartialFrame = _nvcameratools.NvError_VideoDecDecodedPartialFrame
NvError_VideoDecInsufficientBitstream = _nvcameratools.NvError_VideoDecInsufficientBitstream
NvError_VideoDecOutputSurfaceUnavailable = _nvcameratools.NvError_VideoDecOutputSurfaceUnavailable
NvError_VideoDecUnsupportedStreamFormat = _nvcameratools.NvError_VideoDecUnsupportedStreamFormat
NvError_VideoDecFrameDecodedPlusVideoDecEvent = _nvcameratools.NvError_VideoDecFrameDecodedPlusVideoDecEvent
NvError_VideoDecFailed = _nvcameratools.NvError_VideoDecFailed
NvError_VideoDecDecodingComplete = _nvcameratools.NvError_VideoDecDecodingComplete
NvError_VideoDecProvideNextIPBuffer = _nvcameratools.NvError_VideoDecProvideNextIPBuffer
NvError_VideoDecProvideCurrentIPBuffer = _nvcameratools.NvError_VideoDecProvideCurrentIPBuffer
NvError_VideoDecBypassMoreWork = _nvcameratools.NvError_VideoDecBypassMoreWork
NvError_PipeNotConnected = _nvcameratools.NvError_PipeNotConnected
NvError_ReadQNotCreated = _nvcameratools.NvError_ReadQNotCreated
NvError_ParserEndOfStream = _nvcameratools.NvError_ParserEndOfStream
NvError_ParserFailedToGetData = _nvcameratools.NvError_ParserFailedToGetData
NvError_InSufficientBufferSize = _nvcameratools.NvError_InSufficientBufferSize
NvError_ParserReadFailure = _nvcameratools.NvError_ParserReadFailure
NvError_ParserOpenFailure = _nvcameratools.NvError_ParserOpenFailure
NvError_UnSupportedStream = _nvcameratools.NvError_UnSupportedStream
NvError_ParserFailure = _nvcameratools.NvError_ParserFailure
NvError_ParserHeaderDecodeNotComplete = _nvcameratools.NvError_ParserHeaderDecodeNotComplete
NvError_ParserCloseFailure = _nvcameratools.NvError_ParserCloseFailure
NvError_ParserMarkerHit = _nvcameratools.NvError_ParserMarkerHit
NvError_ParserCorruptedStream = _nvcameratools.NvError_ParserCorruptedStream
NvError_ParserDRMLicenseNotFound = _nvcameratools.NvError_ParserDRMLicenseNotFound
NvError_ParserDRMFailure = _nvcameratools.NvError_ParserDRMFailure
NvError_ParserSeekUnSupported = _nvcameratools.NvError_ParserSeekUnSupported
NvError_ParserTrickModeUnSupported = _nvcameratools.NvError_ParserTrickModeUnSupported
NvError_ParserCoreNotCreated = _nvcameratools.NvError_ParserCoreNotCreated
NvError_UnSupported_VideoStream = _nvcameratools.NvError_UnSupported_VideoStream
NvError_UnSupported_AudioStream = _nvcameratools.NvError_UnSupported_AudioStream
NvError_ParserTruncatedFile = _nvcameratools.NvError_ParserTruncatedFile
NvError_ParserOffsetsNotFound = _nvcameratools.NvError_ParserOffsetsNotFound
NvError_WriterOpenFailure = _nvcameratools.NvError_WriterOpenFailure
NvError_WriterUnsupportedStream = _nvcameratools.NvError_WriterUnsupportedStream
NvError_WriterUnsupportedUserData = _nvcameratools.NvError_WriterUnsupportedUserData
NvError_WriterFileSizeLimitExceeded = _nvcameratools.NvError_WriterFileSizeLimitExceeded
NvError_WriterInsufficientMemory = _nvcameratools.NvError_WriterInsufficientMemory
NvError_WriterFailure = _nvcameratools.NvError_WriterFailure
NvError_WriterCloseFailure = _nvcameratools.NvError_WriterCloseFailure
NvError_WriterInitFailure = _nvcameratools.NvError_WriterInitFailure
NvError_WriterFileWriteLimitExceeded = _nvcameratools.NvError_WriterFileWriteLimitExceeded
NvError_WriterTimeLimitExceeded = _nvcameratools.NvError_WriterTimeLimitExceeded
NvError_ContentPipeNoData = _nvcameratools.NvError_ContentPipeNoData
NvError_ContentPipeNoFreeBuffers = _nvcameratools.NvError_ContentPipeNoFreeBuffers
NvError_ContentPipeSpareAreaInUse = _nvcameratools.NvError_ContentPipeSpareAreaInUse
NvError_ContentPipeEndOfStream = _nvcameratools.NvError_ContentPipeEndOfStream
NvError_ContentPipeNotReady = _nvcameratools.NvError_ContentPipeNotReady
NvError_ContentPipeInNonCachingMode = _nvcameratools.NvError_ContentPipeInNonCachingMode
NvError_ContentPipeInsufficientMemory = _nvcameratools.NvError_ContentPipeInsufficientMemory
NvError_ContentPipeNotInvalidated = _nvcameratools.NvError_ContentPipeNotInvalidated
NvError_UnSupportedMetadata = _nvcameratools.NvError_UnSupportedMetadata
NvError_MetadataSuccess = _nvcameratools.NvError_MetadataSuccess
NvError_MetadataFailure = _nvcameratools.NvError_MetadataFailure
NvError_NewMetaDataAvailable = _nvcameratools.NvError_NewMetaDataAvailable
NvError_RefURLAvailable = _nvcameratools.NvError_RefURLAvailable
NvError_TrackListInvalidTrackIndex = _nvcameratools.NvError_TrackListInvalidTrackIndex
NvError_TrackListError = _nvcameratools.NvError_TrackListError
NvError_TrackListItemStillPlayingError = _nvcameratools.NvError_TrackListItemStillPlayingError
NvError_TrackListNotPlaying = _nvcameratools.NvError_TrackListNotPlaying
NvError_Nv3pUnrecoverableProtocol = _nvcameratools.NvError_Nv3pUnrecoverableProtocol
NvError_Nv3pBadPacketType = _nvcameratools.NvError_Nv3pBadPacketType
NvError_Nv3pPacketNacked = _nvcameratools.NvError_Nv3pPacketNacked
NvError_Nv3pBadReceiveLength = _nvcameratools.NvError_Nv3pBadReceiveLength
NvError_Nv3pBadReturnData = _nvcameratools.NvError_Nv3pBadReturnData
NvError_AesClearSbkFailed = _nvcameratools.NvError_AesClearSbkFailed
NvError_AesLockSskFailed = _nvcameratools.NvError_AesLockSskFailed
NvError_AesDisableCryptoFailed = _nvcameratools.NvError_AesDisableCryptoFailed
NvError_AesKeyUnWrapFailed = _nvcameratools.NvError_AesKeyUnWrapFailed
NvError_AesPermissionDenied = _nvcameratools.NvError_AesPermissionDenied
NvError_BlockDriverIllegalIoctl = _nvcameratools.NvError_BlockDriverIllegalIoctl
NvError_BlockDriverOverlappedPartition = _nvcameratools.NvError_BlockDriverOverlappedPartition
NvError_BlockDriverNoPartition = _nvcameratools.NvError_BlockDriverNoPartition
NvError_BlockDriverIllegalPartId = _nvcameratools.NvError_BlockDriverIllegalPartId
NvError_BlockDriverWriteVerifyFailed = _nvcameratools.NvError_BlockDriverWriteVerifyFailed
NvError_NandBlockDriverEraseFailure = _nvcameratools.NvError_NandBlockDriverEraseFailure
NvError_NandBlockDriverWriteFailure = _nvcameratools.NvError_NandBlockDriverWriteFailure
NvError_NandBlockDriverReadFailure = _nvcameratools.NvError_NandBlockDriverReadFailure
NvError_NandBlockDriverLockFailure = _nvcameratools.NvError_NandBlockDriverLockFailure
NvError_NandRegionIllegalAddress = _nvcameratools.NvError_NandRegionIllegalAddress
NvError_NandRegionTableOpFailure = _nvcameratools.NvError_NandRegionTableOpFailure
NvError_NandBlockDriverMultiInterleave = _nvcameratools.NvError_NandBlockDriverMultiInterleave
NvError_NandTagAreaSearchFailure = _nvcameratools.NvError_NandTagAreaSearchFailure
NvError_EmmcBlockDriverLockNotSupported = _nvcameratools.NvError_EmmcBlockDriverLockNotSupported
NvError_EmmcBlockDriverLockUnaligned = _nvcameratools.NvError_EmmcBlockDriverLockUnaligned
NvError_EmmcBlockDriverIllegalStateRead = _nvcameratools.NvError_EmmcBlockDriverIllegalStateRead
NvError_EmmcBlockDriverIllegalStateWrite = _nvcameratools.NvError_EmmcBlockDriverIllegalStateWrite
NvError_EmmcCommandFailed = _nvcameratools.NvError_EmmcCommandFailed
NvError_EmmcReadFailed = _nvcameratools.NvError_EmmcReadFailed
NvError_EmmcWriteFailed = _nvcameratools.NvError_EmmcWriteFailed
NvError_EmmcBlockDriverEraseFailure = _nvcameratools.NvError_EmmcBlockDriverEraseFailure
NvError_EmmcBlockDriverIllegalAddress = _nvcameratools.NvError_EmmcBlockDriverIllegalAddress
NvError_EmmcBlockDriverLockFailure = _nvcameratools.NvError_EmmcBlockDriverLockFailure
NvError_EmmcBlockDriverBlockIsLocked = _nvcameratools.NvError_EmmcBlockDriverBlockIsLocked
NvError_MipiHsiTxFifoEmpty = _nvcameratools.NvError_MipiHsiTxFifoEmpty
NvError_MipiHsiRxFifoEmpty = _nvcameratools.NvError_MipiHsiRxFifoEmpty
NvError_MipiHsiBusy = _nvcameratools.NvError_MipiHsiBusy
NvError_MipiHsiHandleNotConfigured = _nvcameratools.NvError_MipiHsiHandleNotConfigured
NvError_MipiHsiTransmitError = _nvcameratools.NvError_MipiHsiTransmitError
NvError_MipiHsiReceiveError = _nvcameratools.NvError_MipiHsiReceiveError
NvError_MipiHsiTransferIncomplete = _nvcameratools.NvError_MipiHsiTransferIncomplete
NvError_SCCompileFail = _nvcameratools.NvError_SCCompileFail
NvError_DrmFailure = _nvcameratools.NvError_DrmFailure
NvError_DrmInvalidArg = _nvcameratools.NvError_DrmInvalidArg
NvError_DrmOutOfMemory = _nvcameratools.NvError_DrmOutOfMemory
NvError_DrmFileNotFound = _nvcameratools.NvError_DrmFileNotFound
NvError_DrmBufferTooSmall = _nvcameratools.NvError_DrmBufferTooSmall
NvError_DrmInvalidLicense = _nvcameratools.NvError_DrmInvalidLicense
NvError_DrmLicenseExpired = _nvcameratools.NvError_DrmLicenseExpired
NvError_DrmRightsNotAvailable = _nvcameratools.NvError_DrmRightsNotAvailable
NvError_DrmLicenseNotFound = _nvcameratools.NvError_DrmLicenseNotFound
NvError_DrmInvalidBindId = _nvcameratools.NvError_DrmInvalidBindId
NvError_DrmVersionNotSupported = _nvcameratools.NvError_DrmVersionNotSupported
NvError_DrmMeteringNotSupported = _nvcameratools.NvError_DrmMeteringNotSupported
NvError_DrmDecryptionFailed = _nvcameratools.NvError_DrmDecryptionFailed
NvError_SysUpdateInvalidBLVersion = _nvcameratools.NvError_SysUpdateInvalidBLVersion
NvError_SysUpdateInvalidChecksum = _nvcameratools.NvError_SysUpdateInvalidChecksum
NvError_SysUpdateBLUpdateNotAllowed = _nvcameratools.NvError_SysUpdateBLUpdateNotAllowed
NvSuccess = _nvcameratools.NvSuccess
NvError_Force32 = _nvcameratools.NvError_Force32

def getErrorString(*args):
  return _nvcameratools.getErrorString(*args)
getErrorString = _nvcameratools.getErrorString
PROP_TYPE_NULL = _nvcameratools.PROP_TYPE_NULL
PROP_TYPE_BOOL = _nvcameratools.PROP_TYPE_BOOL
PROP_TYPE_UINT8 = _nvcameratools.PROP_TYPE_UINT8
PROP_TYPE_UINT32 = _nvcameratools.PROP_TYPE_UINT32
PROP_TYPE_SINT32 = _nvcameratools.PROP_TYPE_SINT32
PROP_TYPE_UINT64 = _nvcameratools.PROP_TYPE_UINT64
PROP_TYPE_FLOAT = _nvcameratools.PROP_TYPE_FLOAT
PROP_NONE = _nvcameratools.PROP_NONE
PROP_SPECIAL_EFFECT = _nvcameratools.PROP_SPECIAL_EFFECT
PROP_EXPOSURE_TIME = _nvcameratools.PROP_EXPOSURE_TIME
PROP_SENSOR_SENSITIVITY = _nvcameratools.PROP_SENSOR_SENSITIVITY
PROP_NOISE_REDUCTION_MODE = _nvcameratools.PROP_NOISE_REDUCTION_MODE
PROP_AWB_MODE = _nvcameratools.PROP_AWB_MODE
PROP_AWB_LOCK = _nvcameratools.PROP_AWB_LOCK
PROP_AE_MODE = _nvcameratools.PROP_AE_MODE
PROP_AE_LOCK = _nvcameratools.PROP_AE_LOCK
PROP_AE_STATE = _nvcameratools.PROP_AE_STATE
PROP_AF_MODE = _nvcameratools.PROP_AF_MODE
PROP_AF_TRIGGER = _nvcameratools.PROP_AF_TRIGGER
PROP_AF_STATE = _nvcameratools.PROP_AF_STATE
PROP_EXPOSURE_TIMERANGE = _nvcameratools.PROP_EXPOSURE_TIMERANGE
PROP_FRAME_RATE = _nvcameratools.PROP_FRAME_RATE
PROP_PAUSE_AFTER_CAPTURE = _nvcameratools.PROP_PAUSE_AFTER_CAPTURE
PROP_AUTOFOCUS = _nvcameratools.PROP_AUTOFOCUS
PROP_CONTINUOUS_AUTOFOCUS = _nvcameratools.PROP_CONTINUOUS_AUTOFOCUS
PROP_AUTOEXPOSURE = _nvcameratools.PROP_AUTOEXPOSURE
PROP_AUTOWHITEBALANCE = _nvcameratools.PROP_AUTOWHITEBALANCE
PROP_AWB_STATE = _nvcameratools.PROP_AWB_STATE
PROP_FOCUS_DISTANCE = _nvcameratools.PROP_FOCUS_DISTANCE
PROP_FOCUS_POS = _nvcameratools.PROP_FOCUS_POS
PROP_CONCURRENT_RAW_DUMP_FLAG = _nvcameratools.PROP_CONCURRENT_RAW_DUMP_FLAG
PROP_FOCUSINFO_PHYSRANGE = _nvcameratools.PROP_FOCUSINFO_PHYSRANGE
PROP_FOCUSINFO_INF = _nvcameratools.PROP_FOCUSINFO_INF
PROP_FOCUSINFO_INF_OFFSET = _nvcameratools.PROP_FOCUSINFO_INF_OFFSET
PROP_FOCUSINFO_MACRO = _nvcameratools.PROP_FOCUSINFO_MACRO
PROP_FOCUSINFO_MACRO_OFFSET = _nvcameratools.PROP_FOCUSINFO_MACRO_OFFSET
PROP_CROP_REGION = _nvcameratools.PROP_CROP_REGION
PROP_GAIN_RANGE = _nvcameratools.PROP_GAIN_RANGE
PROP_FUSE_ID = _nvcameratools.PROP_FUSE_ID
PROP_AOHDR_MODE = _nvcameratools.PROP_AOHDR_MODE
PROP_WB_MANUAL_MODE = _nvcameratools.PROP_WB_MANUAL_MODE
PROP_WB_GAINS = _nvcameratools.PROP_WB_GAINS
PROP_SENSOR_ANALOG_GAIN = _nvcameratools.PROP_SENSOR_ANALOG_GAIN
PROP_SCALE_SIZE = _nvcameratools.PROP_SCALE_SIZE
NUM_PROPERTIES = _nvcameratools.NUM_PROPERTIES
class CamProperty(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CamProperty, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CamProperty, name)
    __repr__ = _swig_repr
    def __init__(self, *args):
        this = _nvcameratools.new_CamProperty(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["id"] = _nvcameratools.CamProperty_id_set
    __swig_getmethods__["id"] = _nvcameratools.CamProperty_id_get
    if _newclass:id = _swig_property(_nvcameratools.CamProperty_id_get, _nvcameratools.CamProperty_id_set)
    __swig_setmethods__["type"] = _nvcameratools.CamProperty_type_set
    __swig_getmethods__["type"] = _nvcameratools.CamProperty_type_get
    if _newclass:type = _swig_property(_nvcameratools.CamProperty_type_get, _nvcameratools.CamProperty_type_set)
    __swig_setmethods__["count"] = _nvcameratools.CamProperty_count_set
    __swig_getmethods__["count"] = _nvcameratools.CamProperty_count_get
    if _newclass:count = _swig_property(_nvcameratools.CamProperty_count_get, _nvcameratools.CamProperty_count_set)
    __swig_setmethods__["value"] = _nvcameratools.CamProperty_value_set
    __swig_getmethods__["value"] = _nvcameratools.CamProperty_value_get
    if _newclass:value = _swig_property(_nvcameratools.CamProperty_value_get, _nvcameratools.CamProperty_value_set)
    def getFloatElementAtIndex(self, index = 0): return _nvcameratools.CamProperty_getFloatElementAtIndex(self, index)
    def getUint32ElementAtIndex(self, index = 0): return _nvcameratools.CamProperty_getUint32ElementAtIndex(self, index)
    def getSint32ElementAtIndex(self, index = 0): return _nvcameratools.CamProperty_getSint32ElementAtIndex(self, index)
    def getUint8Pointer(self): return _nvcameratools.CamProperty_getUint8Pointer(self)
    __swig_destroy__ = _nvcameratools.delete_CamProperty
    __del__ = lambda self : None;
CamProperty_swigregister = _nvcameratools.CamProperty_swigregister
CamProperty_swigregister(CamProperty)

NoiseReductionMode_Off = _nvcameratools.NoiseReductionMode_Off
NoiseReductionMode_Fast = _nvcameratools.NoiseReductionMode_Fast
NoiseReductionMode_HighQuality = _nvcameratools.NoiseReductionMode_HighQuality
NoiseReductionMode_Force32 = _nvcameratools.NoiseReductionMode_Force32
SpecialEffectsMode_Off = _nvcameratools.SpecialEffectsMode_Off
SpecialEffectsMode_Mono = _nvcameratools.SpecialEffectsMode_Mono
SpecialEffectsMode_Negative = _nvcameratools.SpecialEffectsMode_Negative
SpecialEffectsMode_Solarize = _nvcameratools.SpecialEffectsMode_Solarize
SpecialEffectsMode_Sepia = _nvcameratools.SpecialEffectsMode_Sepia
SpecialEffectsMode_Posterize = _nvcameratools.SpecialEffectsMode_Posterize
SpecialEffectsMode_Aqua = _nvcameratools.SpecialEffectsMode_Aqua
SpecialEffectsMode_Force32 = _nvcameratools.SpecialEffectsMode_Force32
AwbMode_Off = _nvcameratools.AwbMode_Off
AwbMode_Auto = _nvcameratools.AwbMode_Auto
AwbMode_Incandescent = _nvcameratools.AwbMode_Incandescent
AwbMode_Fluorescent = _nvcameratools.AwbMode_Fluorescent
AwbMode_WarmFluorescent = _nvcameratools.AwbMode_WarmFluorescent
AwbMode_Daylight = _nvcameratools.AwbMode_Daylight
AwbMode_CloudyDaylight = _nvcameratools.AwbMode_CloudyDaylight
AwbMode_Twilight = _nvcameratools.AwbMode_Twilight
AwbMode_Shade = _nvcameratools.AwbMode_Shade
AwbMode_Manual = _nvcameratools.AwbMode_Manual
AwbMode_Num_Total_Modes = _nvcameratools.AwbMode_Num_Total_Modes
AwbMode_Force32 = _nvcameratools.AwbMode_Force32
AeMode_Off = _nvcameratools.AeMode_Off
AeMode_On = _nvcameratools.AeMode_On
AeMode_OnAutoFlash = _nvcameratools.AeMode_OnAutoFlash
AeMode_OnAlwaysFlash = _nvcameratools.AeMode_OnAlwaysFlash
AeMode_On_AutoFlashRedEye = _nvcameratools.AeMode_On_AutoFlashRedEye
AeMode_Force32 = _nvcameratools.AeMode_Force32
AfMode_Off = _nvcameratools.AfMode_Off
AfMode_Auto = _nvcameratools.AfMode_Auto
AfMode_Macro = _nvcameratools.AfMode_Macro
AfMode_ContinuousVideo = _nvcameratools.AfMode_ContinuousVideo
AfMode_ContinuousPicture = _nvcameratools.AfMode_ContinuousPicture
AfMode_ExtDepthOfField = _nvcameratools.AfMode_ExtDepthOfField
AfMode_Force32 = _nvcameratools.AfMode_Force32
ConcurrentRawDumpFlag_Off = _nvcameratools.ConcurrentRawDumpFlag_Off
ConcurrentRawDumpFlag_Header = _nvcameratools.ConcurrentRawDumpFlag_Header
ConcurrentRawDumpFlag_RawBuffer = _nvcameratools.ConcurrentRawDumpFlag_RawBuffer
ConcurrentRawDumpFlag_WholeFile = _nvcameratools.ConcurrentRawDumpFlag_WholeFile
ConcurrentRawDumpFlag_Force32 = _nvcameratools.ConcurrentRawDumpFlag_Force32
NvCamAoHdrMode_Off = _nvcameratools.NvCamAoHdrMode_Off
NvCamAoHdrMode_RowInterleaved = _nvcameratools.NvCamAoHdrMode_RowInterleaved
NvCamAoHdrMode_Preprocessed = _nvcameratools.NvCamAoHdrMode_Preprocessed
WbManualMode_AlgControlOff = _nvcameratools.WbManualMode_AlgControlOff
WbManualMode_ResetReinitAlgs = _nvcameratools.WbManualMode_ResetReinitAlgs
WbManualMode_RestoreAlgs = _nvcameratools.WbManualMode_RestoreAlgs
WbManualMode_Force32 = _nvcameratools.WbManualMode_Force32

def new_f32p():
  return _nvcameratools.new_f32p()
new_f32p = _nvcameratools.new_f32p

def copy_f32p(*args):
  return _nvcameratools.copy_f32p(*args)
copy_f32p = _nvcameratools.copy_f32p

def delete_f32p(*args):
  return _nvcameratools.delete_f32p(*args)
delete_f32p = _nvcameratools.delete_f32p

def f32p_assign(*args):
  return _nvcameratools.f32p_assign(*args)
f32p_assign = _nvcameratools.f32p_assign

def f32p_value(*args):
  return _nvcameratools.f32p_value(*args)
f32p_value = _nvcameratools.f32p_value
class uint64pc(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uint64pc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uint64pc, name)
    __repr__ = _swig_repr
    def __init__(self):
        this = _nvcameratools.new_uint64pc()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _nvcameratools.delete_uint64pc
    __del__ = lambda self : None;
    def assign(self, *args): return _nvcameratools.uint64pc_assign(self, *args)
    def value(self): return _nvcameratools.uint64pc_value(self)
    def cast(self): return _nvcameratools.uint64pc_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _nvcameratools.uint64pc_frompointer
    if _newclass:frompointer = staticmethod(_nvcameratools.uint64pc_frompointer)
uint64pc_swigregister = _nvcameratools.uint64pc_swigregister
uint64pc_swigregister(uint64pc)

def uint64pc_frompointer(*args):
  return _nvcameratools.uint64pc_frompointer(*args)
uint64pc_frompointer = _nvcameratools.uint64pc_frompointer

class uint32pc(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uint32pc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uint32pc, name)
    __repr__ = _swig_repr
    def __init__(self):
        this = _nvcameratools.new_uint32pc()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _nvcameratools.delete_uint32pc
    __del__ = lambda self : None;
    def assign(self, *args): return _nvcameratools.uint32pc_assign(self, *args)
    def value(self): return _nvcameratools.uint32pc_value(self)
    def cast(self): return _nvcameratools.uint32pc_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _nvcameratools.uint32pc_frompointer
    if _newclass:frompointer = staticmethod(_nvcameratools.uint32pc_frompointer)
uint32pc_swigregister = _nvcameratools.uint32pc_swigregister
uint32pc_swigregister(uint32pc)

def uint32pc_frompointer(*args):
  return _nvcameratools.uint32pc_frompointer(*args)
uint32pc_frompointer = _nvcameratools.uint32pc_frompointer

class f32pc(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, f32pc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, f32pc, name)
    __repr__ = _swig_repr
    def __init__(self):
        this = _nvcameratools.new_f32pc()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _nvcameratools.delete_f32pc
    __del__ = lambda self : None;
    def assign(self, *args): return _nvcameratools.f32pc_assign(self, *args)
    def value(self): return _nvcameratools.f32pc_value(self)
    def cast(self): return _nvcameratools.f32pc_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _nvcameratools.f32pc_frompointer
    if _newclass:frompointer = staticmethod(_nvcameratools.f32pc_frompointer)
f32pc_swigregister = _nvcameratools.f32pc_swigregister
f32pc_swigregister(f32pc)

def f32pc_frompointer(*args):
  return _nvcameratools.f32pc_frompointer(*args)
f32pc_frompointer = _nvcameratools.f32pc_frompointer

class uint32_array(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uint32_array, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uint32_array, name)
    __repr__ = _swig_repr
    def __init__(self, *args):
        this = _nvcameratools.new_uint32_array(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _nvcameratools.delete_uint32_array
    __del__ = lambda self : None;
    def __getitem__(self, *args): return _nvcameratools.uint32_array___getitem__(self, *args)
    def __setitem__(self, *args): return _nvcameratools.uint32_array___setitem__(self, *args)
    def cast(self): return _nvcameratools.uint32_array_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _nvcameratools.uint32_array_frompointer
    if _newclass:frompointer = staticmethod(_nvcameratools.uint32_array_frompointer)
uint32_array_swigregister = _nvcameratools.uint32_array_swigregister
uint32_array_swigregister(uint32_array)

def uint32_array_frompointer(*args):
  return _nvcameratools.uint32_array_frompointer(*args)
uint32_array_frompointer = _nvcameratools.uint32_array_frompointer

class sint32_array(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, sint32_array, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, sint32_array, name)
    __repr__ = _swig_repr
    def __init__(self, *args):
        this = _nvcameratools.new_sint32_array(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _nvcameratools.delete_sint32_array
    __del__ = lambda self : None;
    def __getitem__(self, *args): return _nvcameratools.sint32_array___getitem__(self, *args)
    def __setitem__(self, *args): return _nvcameratools.sint32_array___setitem__(self, *args)
    def cast(self): return _nvcameratools.sint32_array_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _nvcameratools.sint32_array_frompointer
    if _newclass:frompointer = staticmethod(_nvcameratools.sint32_array_frompointer)
sint32_array_swigregister = _nvcameratools.sint32_array_swigregister
sint32_array_swigregister(sint32_array)

def sint32_array_frompointer(*args):
  return _nvcameratools.sint32_array_frompointer(*args)
sint32_array_frompointer = _nvcameratools.sint32_array_frompointer

class f32_array(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, f32_array, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, f32_array, name)
    __repr__ = _swig_repr
    def __init__(self, *args):
        this = _nvcameratools.new_f32_array(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _nvcameratools.delete_f32_array
    __del__ = lambda self : None;
    def __getitem__(self, *args): return _nvcameratools.f32_array___getitem__(self, *args)
    def __setitem__(self, *args): return _nvcameratools.f32_array___setitem__(self, *args)
    def cast(self): return _nvcameratools.f32_array_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _nvcameratools.f32_array_frompointer
    if _newclass:frompointer = staticmethod(_nvcameratools.f32_array_frompointer)
f32_array_swigregister = _nvcameratools.f32_array_swigregister
f32_array_swigregister(f32_array)

def f32_array_frompointer(*args):
  return _nvcameratools.f32_array_frompointer(*args)
f32_array_frompointer = _nvcameratools.f32_array_frompointer

INVCAMERATOOLS_VERSION_MAJOR = _nvcameratools.INVCAMERATOOLS_VERSION_MAJOR
INVCAMERATOOLS_VERSION_MINOR = _nvcameratools.INVCAMERATOOLS_VERSION_MINOR
class Version(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Version, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Version, name)
    __repr__ = _swig_repr
    __swig_getmethods__["major"] = _nvcameratools.Version_major_get
    if _newclass:major = _swig_property(_nvcameratools.Version_major_get)
    __swig_getmethods__["minor"] = _nvcameratools.Version_minor_get
    if _newclass:minor = _swig_property(_nvcameratools.Version_minor_get)
    def __init__(self, *args):
        this = _nvcameratools.new_Version(*args)
        try: self.this.append(this)
        except: self.this = this
    def isCompatible(self, *args): return _nvcameratools.Version_isCompatible(self, *args)
    __swig_destroy__ = _nvcameratools.delete_Version
    __del__ = lambda self : None;
Version_swigregister = _nvcameratools.Version_swigregister
Version_swigregister(Version)

CamConst_CAP_READY = _nvcameratools.CamConst_CAP_READY
CamConst_CAP_FILE_READY = _nvcameratools.CamConst_CAP_FILE_READY
CamConst_AF_READY = _nvcameratools.CamConst_AF_READY
CamConst_AF_TIMEOUT = _nvcameratools.CamConst_AF_TIMEOUT
CamConst_AE_READY = _nvcameratools.CamConst_AE_READY
CamConst_AE_TIMEOUT = _nvcameratools.CamConst_AE_TIMEOUT
CamConst_AWB_READY = _nvcameratools.CamConst_AWB_READY
CamConst_AWB_TIMEOUT = _nvcameratools.CamConst_AWB_TIMEOUT
CamConst_PREVIEW_PAUSED = _nvcameratools.CamConst_PREVIEW_PAUSED
CamConst_PREVIEW_EOS = _nvcameratools.CamConst_PREVIEW_EOS
CamConst_FIRST_PREVIEW_FRAME = _nvcameratools.CamConst_FIRST_PREVIEW_FRAME
CamConst_ALL_CAPTURE_DONE = _nvcameratools.CamConst_ALL_CAPTURE_DONE
CamConst_POWER_ON_COMPLETE = _nvcameratools.CamConst_POWER_ON_COMPLETE
CamConst_AF_CANCEL = _nvcameratools.CamConst_AF_CANCEL
CamConst_AE_CANCEL = _nvcameratools.CamConst_AE_CANCEL
CamConst_AWB_CANCEL = _nvcameratools.CamConst_AWB_CANCEL
CamConst_LAST = _nvcameratools.CamConst_LAST
CamConst_ALGS = _nvcameratools.CamConst_ALGS
class ICaptureHandler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICaptureHandler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ICaptureHandler, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def nextPreviewFrame(self, *args): return _nvcameratools.ICaptureHandler_nextPreviewFrame(self, *args)
    def nextCapture(self, *args): return _nvcameratools.ICaptureHandler_nextCapture(self, *args)
ICaptureHandler_swigregister = _nvcameratools.ICaptureHandler_swigregister
ICaptureHandler_swigregister(ICaptureHandler)

class INvCameraTools(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, INvCameraTools, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, INvCameraTools, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def openImager(self, *args): return _nvcameratools.INvCameraTools_openImager(self, *args)
    def getSupportedModes(self): return _nvcameratools.INvCameraTools_getSupportedModes(self)
    def setSensorMode(self, *args): return _nvcameratools.INvCameraTools_setSensorMode(self, *args)
    def setJpegResolution(self, *args): return _nvcameratools.INvCameraTools_setJpegResolution(self, *args)
    def setJpegQuality(self, *args): return _nvcameratools.INvCameraTools_setJpegQuality(self, *args)
    def initialize(self): return _nvcameratools.INvCameraTools_initialize(self)
    def shutdown(self): return _nvcameratools.INvCameraTools_shutdown(self)
    def startPreview(self): return _nvcameratools.INvCameraTools_startPreview(self)
    def stopPreview(self): return _nvcameratools.INvCameraTools_stopPreview(self)
    def setProperty(self, *args): return _nvcameratools.INvCameraTools_setProperty(self, *args)
    def getProperty(self, *args): return _nvcameratools.INvCameraTools_getProperty(self, *args)
    def setRawImage(self, *args): return _nvcameratools.INvCameraTools_setRawImage(self, *args)
    def loadNVRawFile(self, *args): return _nvcameratools.INvCameraTools_loadNVRawFile(self, *args)
    def loadNVRawData(self, *args): return _nvcameratools.INvCameraTools_loadNVRawData(self, *args)
    def setHostInputIteration(self, *args): return _nvcameratools.INvCameraTools_setHostInputIteration(self, *args)
    def captureRequest(self, *args): return _nvcameratools.INvCameraTools_captureRequest(self, *args)
    def registerCaptureHandler(self, *args): return _nvcameratools.INvCameraTools_registerCaptureHandler(self, *args)
    def closeImager(self): return _nvcameratools.INvCameraTools_closeImager(self)
    __swig_destroy__ = _nvcameratools.delete_INvCameraTools
    __del__ = lambda self : None;
    def halfPress(self, *args): return _nvcameratools.INvCameraTools_halfPress(self, *args)
    def halfPressRelease(self): return _nvcameratools.INvCameraTools_halfPressRelease(self)
    def waitForEvent(self, *args): return _nvcameratools.INvCameraTools_waitForEvent(self, *args)
    def captureRequestGeneric(self, *args): return _nvcameratools.INvCameraTools_captureRequestGeneric(self, *args)
    def captureRequestBayer(self, *args): return _nvcameratools.INvCameraTools_captureRequestBayer(self, *args)
INvCameraTools_swigregister = _nvcameratools.INvCameraTools_swigregister
INvCameraTools_swigregister(INvCameraTools)
NV_IMAGER_AUTO_BACK = _nvcameratools.NV_IMAGER_AUTO_BACK
NV_IMAGER_AUTO_FRONT = _nvcameratools.NV_IMAGER_AUTO_FRONT


def getNvCameraToolsVersion():
  return _nvcameratools.getNvCameraToolsVersion()
getNvCameraToolsVersion = _nvcameratools.getNvCameraToolsVersion

def createNvCameraTools(*args):
  return _nvcameratools.createNvCameraTools(*args)
createNvCameraTools = _nvcameratools.createNvCameraTools

def createCameraTools():
  return _nvcameratools.createCameraTools()
createCameraTools = _nvcameratools.createCameraTools

def deleteCameraTools(*args):
  return _nvcameratools.deleteCameraTools(*args)
deleteCameraTools = _nvcameratools.deleteCameraTools
class PropertyInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PropertyInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PropertyInfo, name)
    __repr__ = _swig_repr
    __swig_setmethods__["propId"] = _nvcameratools.PropertyInfo_propId_set
    __swig_getmethods__["propId"] = _nvcameratools.PropertyInfo_propId_get
    if _newclass:propId = _swig_property(_nvcameratools.PropertyInfo_propId_get, _nvcameratools.PropertyInfo_propId_set)
    __swig_setmethods__["propType"] = _nvcameratools.PropertyInfo_propType_set
    __swig_getmethods__["propType"] = _nvcameratools.PropertyInfo_propType_get
    if _newclass:propType = _swig_property(_nvcameratools.PropertyInfo_propType_get, _nvcameratools.PropertyInfo_propType_set)
    __swig_setmethods__["count"] = _nvcameratools.PropertyInfo_count_set
    __swig_getmethods__["count"] = _nvcameratools.PropertyInfo_count_get
    if _newclass:count = _swig_property(_nvcameratools.PropertyInfo_count_get, _nvcameratools.PropertyInfo_count_set)
    __swig_setmethods__["name"] = _nvcameratools.PropertyInfo_name_set
    __swig_getmethods__["name"] = _nvcameratools.PropertyInfo_name_get
    if _newclass:name = _swig_property(_nvcameratools.PropertyInfo_name_get, _nvcameratools.PropertyInfo_name_set)
    def __init__(self):
        this = _nvcameratools.new_PropertyInfo()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _nvcameratools.delete_PropertyInfo
    __del__ = lambda self : None;
PropertyInfo_swigregister = _nvcameratools.PropertyInfo_swigregister
PropertyInfo_swigregister(PropertyInfo)


def getPropertyInfo(*args):
  return _nvcameratools.getPropertyInfo(*args)
getPropertyInfo = _nvcameratools.getPropertyInfo

def getPropertyString(*args):
  return _nvcameratools.getPropertyString(*args)
getPropertyString = _nvcameratools.getPropertyString

def getHostSensorGuid():
  return _nvcameratools.getHostSensorGuid()
getHostSensorGuid = _nvcameratools.getHostSensorGuid
class CaptureHandler(ICaptureHandler):
    __swig_setmethods__ = {}
    for _s in [ICaptureHandler]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CaptureHandler, name, value)
    __swig_getmethods__ = {}
    for _s in [ICaptureHandler]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CaptureHandler, name)
    __repr__ = _swig_repr
    def __init__(self, *args):
        this = _nvcameratools.new_CaptureHandler(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _nvcameratools.delete_CaptureHandler
    __del__ = lambda self : None;
    def nextPreviewFrame(self, *args): return _nvcameratools.CaptureHandler_nextPreviewFrame(self, *args)
    def nextCapture(self, *args): return _nvcameratools.CaptureHandler_nextCapture(self, *args)
CaptureHandler_swigregister = _nvcameratools.CaptureHandler_swigregister
CaptureHandler_swigregister(CaptureHandler)
cvar = _nvcameratools.cvar

attr_anr = _nvcameratools.attr_anr
attr_autofocus = _nvcameratools.attr_autofocus
attr_crop = _nvcameratools.attr_crop
attr_bayergains = _nvcameratools.attr_bayergains
attr_exposuretime = _nvcameratools.attr_exposuretime
attr_exposuretimerange = _nvcameratools.attr_exposuretimerange
attr_focuspos = _nvcameratools.attr_focuspos
attr_pauseaftercapture = _nvcameratools.attr_pauseaftercapture
attr_concurrentrawdumpflag = _nvcameratools.attr_concurrentrawdumpflag
attr_continuousautofocus = _nvcameratools.attr_continuousautofocus
attr_focuspositionphysicalrange = _nvcameratools.attr_focuspositionphysicalrange
attr_focuspositioninf = _nvcameratools.attr_focuspositioninf
attr_focuspositioninfoffset = _nvcameratools.attr_focuspositioninfoffset
attr_focuspositionmacro = _nvcameratools.attr_focuspositionmacro
attr_focuspositionmacrooffset = _nvcameratools.attr_focuspositionmacrooffset
attr_gainrange = _nvcameratools.attr_gainrange
attr_fuseid = _nvcameratools.attr_fuseid
attr_aeoverride = _nvcameratools.attr_aeoverride
attr_enableaohdr = _nvcameratools.attr_enableaohdr
attr_scalesize = _nvcameratools.attr_scalesize
import array
import sys
import os.path
from operator import itemgetter, attrgetter

TRUE_CONCURRENT_RAW_DISABLED = False

class Singleton(object):
    """ A Pythonic Singleton """
    def __new__(cls, *args, **kwargs):
        if '_inst' not in vars(cls):
            cls._inst = object.__new__(cls, *args, **kwargs)
        return cls._inst

class NvCamera(Singleton):
    """ A singleton wrapper class around NvCameraTools API"""
    _nvcameraToolsOb = None
    _isCaptureHandlerInitialized = False

    def getNvCameraTools(self):
        if (self._nvcameraToolsOb == None):
            self._nvcameraToolsOb = createCameraTools()

        return self._nvcameraToolsOb

    def deleteNvCameraTools(self):
        if (self._nvcameraToolsOb == None):
            return
        deleteCameraTools(self._nvcameraToolsOb)
        self._nvcameraToolsOb = None

    def setCaptureHandlerInitFlag(self, value):
         "set to True or False"
         self._isCaptureHandlerInitialized = value

    def getCaptureHandlerInitFlag(self):
         return self._isCaptureHandlerInitialized

class Graph:
    "nvcamera Graph class"

    def __init__(self):
        self._sensorModes = None

    def setImager(self, imagerId):
        "Sets the camera imager/sensor GUID"

        # This function also creates NvCameraTools API object
        # because this is the first operation expected from the
        # client scripts

        if (NvCamera().getNvCameraTools() == None):
            raise NvCameraException(NvError_InvalidState, "Couldn't initialize NvCameraTools API")

        if (imagerId == "host"):
            imagerId = getHostSensorGuid()
        elif (imagerId == "primary"):
            imagerId = _nvcameratools.NV_IMAGER_AUTO_BACK
        elif (imagerId == "secondary"):
            imagerId = _nvcameratools.NV_IMAGER_AUTO_FRONT

        return NvCamera().getNvCameraTools().openImager(imagerId)

    def preview(self, previewWidth = 0, previewHeight = 0):
        "Set preview mode"

        previewMode = None

        if (previewWidth == 0 or previewHeight == 0):
            # get the sensor modes
            sensorModesList = self.getSupportedModes()

            # find the maximum sensor resolution
            # rather than previous choice which
            # is "largest sensor resolutoon with 30 fps"
            #
            #for mode in sensorModesList:
            #    if (mode.FrameRate == 30):
            #        previewMode = mode
            #        break
            #
            currMaxWidth = 0
            currMaxHeight = 0
            for mode in sensorModesList:
                if((currMaxWidth < mode.Resolution.width) or (currMaxHeight < mode.Resolution.height)):
                    previewMode = mode
                    currMaxWidth = mode.Resolution.width
                    currMaxHeight = mode.Resolution.height
                    break
        else:
            previewMode = NvMMCameraSensorMode()
            previewMode.Resolution.width = previewWidth
            previewMode.Resolution.height = previewHeight

        print "Picking the preview resolution of %dx%d\n" % (previewMode.Resolution.width, previewMode.Resolution.height)
        err =  NvCamera().getNvCameraTools().setSensorMode(NvCameraCoreUseCase_Preview, previewMode)
        if (err != NvSuccess):
            raise NvCameraException(err, "Couldn't set preview sensor mode!")

        # set jpeg resolution
        jpegResolutionPreview = NvSize()
        jpegResolutionPreview.width = previewMode.Resolution.width
        jpegResolutionPreview.height = previewMode.Resolution.height
        err = NvCamera().getNvCameraTools().setJpegResolution(NvCameraCoreUseCase_Preview, jpegResolutionPreview)
        if (err != NvSuccess):
            raise NvCameraExpcetion(err, "Couldn't set preview jpeg resolution!")

    def run(self):
        "Inialize NvCameraTools API"

        # HACK to disable early graph
        #if (sys.platform.startswith("linux-arm")):
        #    print "disabling early graph"
        #    _disable_early_graph(1)

        return NvCamera().getNvCameraTools().initialize()

    def still(self, stillWidth = 0, stillHeight = 0, graphType = "Jpeg"):
        "Set still capture sensor mode"

        stillMode = None

        if (stillWidth == 0 or stillHeight == 0):
            # get the supported sensor modes
            sensorModesList = self.getSupportedModes()

            # get the largest resolution mode
            stillMode = sensorModesList[0]
        else:
            stillMode = NvMMCameraSensorMode()
            stillMode.Resolution.width = stillWidth
            stillMode.Resolution.height = stillHeight

        print "Picking the still resolution of %dx%d\n" % (stillMode.Resolution.width, stillMode.Resolution.height)
        # set jpeg resolution
        jpegResolutionStill = NvSize()
        jpegResolutionStill.width = stillMode.Resolution.width
        jpegResolutionStill.height = stillMode.Resolution.height
        err = NvCamera().getNvCameraTools().setJpegResolution(NvCameraCoreUseCase_Still, jpegResolutionStill)
        if (err != NvSuccess):
            raise NvCameraException(err, "Couldn't set still jpeg resolution!")

        # set jpeg quality
        err = NvCamera().getNvCameraTools().setJpegQuality(NvCameraCoreUseCase_Still, 90)
        if (err != NvSuccess):
            raise NvCameraException(err, "Couldn't set still jpeg quality!")

        return NvCamera().getNvCameraTools().setSensorMode(NvCameraCoreUseCase_Still, stillMode)

    def video(self, *args):
        "Add video capture graph"
        return NvError_NotImplemented

    def stop(self):
        "shutdown NvCameraTools API"
        err = NvCamera().getNvCameraTools().shutdown()

        NvCamera().setCaptureHandlerInitFlag(False)

        # HACK to enable early graph
        if (sys.platform.startswith("linux-arm")):
            print "Enabling early graph"
            _disable_early_graph(0)

        return err

    def close(self):
        "Closes the graph"

        err = NvCamera().getNvCameraTools().closeImager()
        if (err != NvSuccess):
            raise NvCameraException(err, "Couldn't close the imager")

        # this function also deletes NvCameaTools API object
        # because this is the last call expected from the
        # client scripts
        NvCamera().deleteNvCameraTools()

    def getSupportedModes(self):
        """ Gets sorted list supported sensor modes and store
            it locally as well. Sort order is descending with
            respect to (width, height) key
        """
        (err, modesList) = NvCamera().getNvCameraTools().getSupportedModes()
        if (err != NvSuccess):
            raise NvCameraException(err, "Couldn't get supported sensor modes!!")

        modesList.sort(key = attrgetter('Resolution.width', 'Resolution.height'), reverse = True)

        return modesList

class NvCameraPropertyOperationType:
    PROP_OP_TYPE_GET = 1
    PROP_OP_TYPE_SET = 2

class Camera:
    "nvcamera Camera Class"
    __concurrentRawImageDir = "/data/raw"

    def __init__(self):

        self._stillImageName = None

        NvCamera().getNvCameraTools()
        self.registerCaptureHandler()
        self._propertyManager = NvCameraPropertyManager()

    def registerCaptureHandler(self):
        print "Registering capture handler...\n"
        self._captureHandler = CaptureHandler(self.__nextPreviewFrame, self.__nextStillFrame)
        NvCamera().getNvCameraTools().registerCaptureHandler(self._captureHandler)
        NvCamera().setCaptureHandlerInitFlag(True)

    def startPreview(self, *args):
        "Start camera preview"

        if (not NvCamera().getCaptureHandlerInitFlag()):
            self.registerCaptureHandler()

        err = NvCamera().getNvCameraTools().startPreview()
        if (err != NvSuccess):
            raise NvCameraException(err, "Failed to start preview!")

    def setAttr(self, attrID, *args):
        "Sets camera attribute"
        if (args == None):
            raise NvCameraException(NvError_BadValue, "Invalid attribute value!")

        propertyId = self._propertyManager._getPropertyIdFromAttributeId(attrID)

        if (propertyId == PROP_NONE):
            # this is NOOP property. dont't do anything
            return

        retVal =  self._propertyManager.handleProperty( \
                   NvCameraPropertyOperationType.PROP_OP_TYPE_SET, \
                   propertyId, \
                   *args \
               )
        return retVal

    def getAttr(self, attrID):
        "Gets camera attribute"
        propertyId = self._propertyManager._getPropertyIdFromAttributeId(attrID)

        if (propertyId == PROP_NONE):
            # this is NOOP property. dont't do anything
            return

        return self._propertyManager.handleProperty( \
                      NvCameraPropertyOperationType.PROP_OP_TYPE_GET, \
                      propertyId \
               )

    def stopPreview(self):
        "Stops the camera preview"
        err = NvCamera().getNvCameraTools().stopPreview()
        if (err != NvSuccess):
            raise NvCameraException(err, "Failed to stop preview!")

    def setRawImage(self, header, pixelData, iteration):
        "Sets the raw image header and data"
        return NvCamera().getNvCameraTools().setRawImage(header, pixelData, iteration)

    def still(self, imageName, timeout = 10000):
        "capture still image"

        self._stillImageName = imageName
        # parse "imageName" to get the capture type (Bayer or YUV).
        basename = os.path.basename(imageName)
        name, suffix = os.path.splitext(basename)

        if (not NvCamera().getCaptureHandlerInitFlag()):
            self.registerCaptureHandler()

        if (TRUE_CONCURRENT_RAW_DISABLED):
            print "True concurrent raw is disabled...\n"
            # special HACK for concurrent raw dump
            # suffix will be .jpg and we need raw capture followed
            # by jpeg capture
            if (self.getAttr(_nvcameratools.attr_concurrentrawdumpflag) == 7):
                self._stillImageName = Camera.__concurrentRawImageDir + "/" + name + "." + "nvraw"

                err = NvCamera().getNvCameraTools().captureRequestBayer(timeout)
                if (err != NvSuccess):
                    raise NvCameraException(err, "ERROR: Couldn't capture Bayer image during \
                                            concurrent raw capture!")
                self.waitForEvent(12000, _nvcameratools.CamConst_CAP_READY)

            # reset the _stillImageName back to what it was
            self._stillImageName = imageName

        if (suffix == ".jpg" or suffix == ".jpeg" or suffix == ".yuv"):
            # do a YUV capture
            err = NvCamera().getNvCameraTools().captureRequest(timeout)
            if (err != NvSuccess):
                raise NvCameraException(err, "ERROR: Couldn't capture YUV image!")
        elif (suffix == ".nvraw"):
            # do a Bayer capture
            err = NvCamera().getNvCameraTools().captureRequestBayer(timeout)
            if (err != NvSuccess):
                raise NvCameraException(err, "ERROR: Couldn't capture Bayer image!")
        else:
            # unrecognized file format
            raise NvCameraException(NvError_BadValue, "ERROR: unrecognized file format!")

    def waitForEvent(self, *args):
        "wait for event(s)"
        # combine the list of events into event mask
        eventMask = 0
        timeout = args[0]
        for event in args[1:]:
            eventMask = eventMask | event

        # clear and ignore CAP_FILE_READY event because it is not going to be
        # sent by nvcameratools API
        if ((eventMask != _nvcameratools.CamConst_ALGS) and \
            (eventMask & _nvcameratools.CamConst_CAP_FILE_READY)):
            eventMask = eventMask & ~_nvcameratools.CamConst_CAP_FILE_READY

        err = NvCamera().getNvCameraTools().waitForEvent(timeout, eventMask)
        if (err != NvSuccess):
            raise NvCameraException(err, "Failed to wait for event(s)!")

    def halfpress(self, *args):
        "execute halfpress"
        err = NvCamera().getNvCameraTools().halfPress(args[0])
        if (err != NvSuccess):
            raise NvCameraException(err, "halfpress failure!")

    def hp_release(self):
        "releases half press"
        err = NvCamera().getNvCameraTools().halfPressRelease()
        if (err != NvSuccess):
            raise NvCameraException(err, "halfpress release failure!")

    def startVideoRecording(self):
        "start video recording"
        #return self._oCameraImpl.operation(_nvcameratools.cop_start_video)
        pass

    def stopVideoRecording(self):
        "stop video recording"
        #return self._oCameraImpl.operation(_nvcameratools.cop_stop_video)
        pass

    def __nextStillFrame(self, data):
        f = open(self._stillImageName, "w")
        f.write(data)
        f.close()

        if (not TRUE_CONCURRENT_RAW_DISABLED):
            # special handling for concurrent raw capture
            # two consecutive buffers will be send by Tools API
            # jpeg buffer followed by raw buffer

            if (self.getAttr(_nvcameratools.attr_concurrentrawdumpflag) == 7):
                # for now we use the hardcoded raw dump directory
                self._stillImageName = Camera.__concurrentRawImageDir + "/" + "NvCameraToolsRawDump" + "." +"nvraw"

    def __nextPreviewFrame(self, data):
        pass

class NvCameraException(Exception):
    """ this exception is raised when error occurs during
        graph/camera operations
    """

    def __init__(self, errorCode, msg = ""):
        self.value = errorCode
        self.msg = msg

    def __str__(self):
        return "ERROR: %s\nErrorCode: %s: %s" % \
                (self.msg, repr(self.value), _nvcameratools.getErrorString(self.value))

def _disable_early_graph(state):
    """disables early graph if it is not already disabled.
       This function assumes that if the nv-camera-disable-early-graph
       property is set to 1 that means that the functionality is
       disabled in mediaserver and hence it won't restart media server
       in that case
    """
    earlyGraphState = 0
    try:
        earlyGraphState = _execute_cmd(["getprop", "nv-camera-disable-early-graph"])
        if (earlyGraphState.strip() == ""):
            earlyGraphState = 0
    except RuntimeError, err:
        pass

    if (state == int(earlyGraphState)):
        return

    _execute_cmd(["setprop", "nv-camera-disable-early-graph", str(state)])
    _restart_media_server()

def _restart_media_server():
    import re
    task_info = _execute_cmd(['ps', 'mediaserver'])

    m = re.search('^\S+\s+(\d+)\s+',task_info,re.MULTILINE)

    if (m == None):
        return

    pid = m.group(1)
    print "restarting media server"
    try:
        _execute_cmd(['kill', pid])
    except RuntimeError, err:
       # HACK
       # ignore run time error while killing the media server
       # sometimes it seems to exit with 255 status code
       print "WARNING: %s" % str(err)

def _execute_cmd(args, silent = False):
    """Execute the command as a subprocess.

       Returns the exit code of the process on success
       Exit the script on failure
    """
    import subprocess

    sys.stdout.flush()

    # For Windows we need to use the shell so the path is searched (Python/Windows bug)
    # For Android, using the shell complicates things
    p = subprocess.Popen(args, shell=sys.platform.startswith('win'), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (std_out_str, std_err_str) = p.communicate()
    returncode = p.returncode

    clean_std_out_str = std_out_str.translate(None,'\r')
    clean_std_err_str = std_err_str.translate(None,'\r')

    if (returncode != 0):
        raise RuntimeError("Error (%d) executing command: %s" % (returncode, " ".join(args)))

    return clean_std_out_str


class NvCameraPropertyManager(object):
    """Property manager class
    """
    def __init__(self):
        self.__initPropHandlerDict()

    def __initPropHandlerDict(self):
        self.propHandlerDict = { \
            PROP_EXPOSURE_TIME     : self._exposureTimeHandler, \
            PROP_FUSE_ID           : self._fuseIdHandler, \
            PROP_SENSOR_ANALOG_GAIN: self._sensorAnalogGainHandler \
        }

    def setPropery(self, camProp):
        return NvCamera().getNvCameraTools().setProperty(camProp)

    def getPropery(self, camProp):
        return NvCamera().getNvCameraTools().getProperty(camProp)

    def createCamPropertyObject(self, propertyId, type, count):
        # create the CamProperty Object
        camProp = CamProperty()
        camProp.id = propertyId
        camProp.type = type
        camProp.count = count

        return camProp

    def handleProperty(self, propOpType, propertyId, value = None):
        """ creates CamProperty object for a given
        Operation type (get/set), NVCS attribute and value
        """

        # check for property specific handler if any
        # call property specific handler if found or call
        # default property handler
        if (propertyId in self.propHandlerDict and self.propHandlerDict[propertyId] != None):
            return self.propHandlerDict[propertyId](propertyId, value, propOpType)
        else:
            return self._genericPropertyHandler(propertyId, value, propOpType)

    def convertCamPropertyToPyType(self, camProp):
        if(camProp.count > 1):
            retListVal = []
            for i in range(camProp.count):
                if(camProp.type == PROP_TYPE_UINT32):
                    retListVal.append(camProp.getUint32ElementAtIndex(i))
                if(camProp.type == PROP_TYPE_SINT32):
                    retListVal.append(camProp.getSint32ElementAtIndex(i))
                elif(camProp.type == PROP_TYPE_FLOAT):
                    retListVal.append(camProp.getFloatElementAtIndex(i))
            return retListVal
        elif(camProp.type == PROP_TYPE_UINT32):
            return camProp.getUint32ElementAtIndex(0)
        elif(camProp.type == PROP_TYPE_SINT32):
            return camProp.getSint32ElementAtIndex(0)
        elif(camProp.type == PROP_TYPE_UINT8):
            return camProp.value.u8 # this is not tested..
        elif(camProp.type == PROP_TYPE_FLOAT):
            return camProp.getFloatElementAtIndex(0)

    def checkPropertyType(self, propValue, propType):
        nativePropType = self.__getNativeTypeFromPropertyType(propType)
        if (isinstance(propValue, list)):
            # assumes list of homegeneous types
            if (isinstance(propValue[0], nativePropType)):
                return True
            else:
                return False
        elif (isinstance(propValue, nativePropType)):
            return True
        else:
            return False

    def assignPyTypeToCamProperty(self, propType, propValueArray, camProp):
        if (propType == PROP_TYPE_UINT32):
            camProp.value.u32 = propValueArray.cast()
        elif (propType == PROP_TYPE_UINT64):
            camProp.value.u64 = propValueArray.cast()
        elif (propType == PROP_TYPE_UINT8):
            camProp.value.u8 = propValueArray.cast()
        elif (propType == PROP_TYPE_FLOAT):
            camProp.value.f = propValueArray.cast()
        elif (propType == PROP_TYPE_BOOL):
            # at present we pass 1 for True and 0 for False
            camProp.value.u32 = propValueArray.cast()
        elif (propType == PROP_TYPE_SINT32):
            camProp.value.i32 = propValueArray.cast()

    def __getNativeTypeFromPropertyType(self, propType):
        if (propType == PROP_TYPE_UINT32 or propType == PROP_TYPE_SINT32):
            return int
        elif (propType == PROP_TYPE_UINT64):
            return long
        elif (propType == PROP_TYPE_UINT8):
            return str
        elif (propType == PROP_TYPE_FLOAT):
            return float
        elif (propType == PROP_TYPE_BOOL):
             # at present we pass 1 for True and 0 for False
             return int

    def getPropertyString(self, propertyId):
        return getPropertyString(propertyId)

    ####################Property Handler Functions #####################
    #handler functions are called to handle special cases like setting the
    #dependent properties etc..

    def _genericPropertyHandler(self, propertyId, value, propOpType):
        # get the property info [type, count, handler]
        propInfo = self._getPropertyInfo(propertyId)

        # check the property type
        if (propOpType == NvCameraPropertyOperationType.PROP_OP_TYPE_SET):
            bType = self.checkPropertyType(value, propInfo.propType)
            if (bType == False):
                raise NvCameraException(NvError_BadValue, "Invalid property type!")

        camProp = self.createCamPropertyObject(propertyId, propInfo.propType, propInfo.count)

        # create an array
        propValueArray = None
        if (propInfo.propType == PROP_TYPE_FLOAT):
            propValueArray = f32_array(propInfo.count)
        elif (propInfo.propType == PROP_TYPE_SINT32):
            propValueArray = sint32_array(propInfo.count)
        elif (propInfo.propType == PROP_TYPE_UINT32 or propInfo.propType == PROP_TYPE_BOOL):
            propValueArray = uint32_array(propInfo.count)

        # assign the value
        if (propOpType == NvCameraPropertyOperationType.PROP_OP_TYPE_SET):
            if(propInfo.count > 1):
                # array of values
                for i in range(propInfo.count):
                    propValueArray[i] = value[i]
            else:
                propValueArray[0] = value

        self.assignPyTypeToCamProperty(propInfo.propType, propValueArray, camProp)

        if (propOpType == NvCameraPropertyOperationType.PROP_OP_TYPE_SET):
            err = NvCamera().getNvCameraTools().setProperty(camProp)
            if (err != NvSuccess):
                raise NvCameraException(NvError_InvalidState, "Unable to set property %s" % self.getPropertyString(propertyId))
        else:
            err = NvCamera().getNvCameraTools().getProperty(camProp)
            if (err != NvSuccess):
                raise NvCameraException(NvError_InvalidState, "Unable to get property %s" % self.getPropertyString(propertyId))
            return self.convertCamPropertyToPyType(camProp)

    def _exposureTimeHandler(self, propertyId, value, propOpType):
        # dependent property PROP_AE_MODE
        # PROP_AE_MODE should be off in order to set manual exposure time

        if (propOpType == NvCameraPropertyOperationType.PROP_OP_TYPE_SET):
            # set PROP_AE_MODE to AeMode_Off
            self._genericPropertyHandler( \
                PROP_AE_MODE, \
                AeMode_Off, \
                NvCameraPropertyOperationType.PROP_OP_TYPE_SET \
             )

        # set exposure time
        return self._genericPropertyHandler(propertyId, value, propOpType)

    def _fuseIdHandler(self, propertyId, value, propOpType):
        # client scripts expects fuse id in the form
        # [x, [i1, i2, ...]] where x is the size of the fuzeId bytes
        # and i1, i2 are the fuze id unsinged integers
        # and tools API retuns in the form [x, i1, i2, ...], so we need
        # to convert it to the client expected form

        if (propOpType == NvCameraPropertyOperationType.PROP_OP_TYPE_GET):
            fuseIdData = self._genericPropertyHandler(propertyId, value, propOpType)

            retList = []
            retList.append(fuseIdData[0])
            retList.append(fuseIdData[1:])
            return retList
        else:
            return self._genericPropertyHandler(propertyId, value, propOpType)

    def _sensorAnalogGainHandler(self, propertyId, value, propOpType):
        # driver only sets single gain for all four channels

        if (propOpType == NvCameraPropertyOperationType.PROP_OP_TYPE_GET):
            channelGain = self._genericPropertyHandler(propertyId, value, propOpType)
            retList = [channelGain] * 4
            return retList
        else:
            # send in the first gain value for all four channels
            # sensor driver is writing second channel gain so we are using
            # 1 as index and not 0
            return self._genericPropertyHandler(propertyId, float(value[1]), propOpType)

    ######################################################################
    def _getPropertyIdFromAttributeId(self, attributeId):
        # attribute id to property id mapping
        # attribute id which maps to property id PROP_NONE are not supported
        # right now
        if (attributeId == attr_anr): return PROP_NOISE_REDUCTION_MODE
        elif (attributeId == attr_autofocus): return PROP_AUTOFOCUS
        elif (attributeId == attr_exposuretime): return PROP_EXPOSURE_TIME
        elif (attributeId == attr_exposuretimerange): return PROP_EXPOSURE_TIMERANGE
        elif (attributeId == attr_focuspos): return PROP_FOCUS_POS
        elif (attributeId == attr_pauseaftercapture): return PROP_PAUSE_AFTER_CAPTURE
        elif (attributeId == attr_concurrentrawdumpflag): return PROP_CONCURRENT_RAW_DUMP_FLAG
        elif (attributeId == attr_continuousautofocus): return PROP_CONTINUOUS_AUTOFOCUS
        elif (attributeId == attr_focuspositionphysicalrange): return PROP_FOCUSINFO_PHYSRANGE
        elif (attributeId == attr_focuspositioninf): return PROP_FOCUSINFO_INF
        elif (attributeId == attr_focuspositioninfoffset):return PROP_FOCUSINFO_INF_OFFSET
        elif (attributeId == attr_focuspositionmacro): return PROP_FOCUSINFO_MACRO
        elif (attributeId == attr_focuspositionmacrooffset): return PROP_FOCUSINFO_MACRO_OFFSET
        elif (attributeId == attr_gainrange): return PROP_GAIN_RANGE
        elif (attributeId == attr_crop): return PROP_CROP_REGION
        elif (attributeId == attr_fuseid): return PROP_FUSE_ID
        elif (attributeId == attr_enableaohdr): return PROP_AOHDR_MODE
        elif (attributeId == attr_bayergains): return PROP_SENSOR_ANALOG_GAIN
        elif (attributeId == attr_scalesize): return PROP_SCALE_SIZE
        elif (attributeId == attr_aeoverride): \
            raise NvCameraException(NvError_NotImplemented, "attribute is not implemented!")
        else:
            raise NvCameraException(NvError_BadParameter, "Invalid attribute id!")

    def _getPropertyInfo(self, propertyId):
        """ function to NvCameraTools property info
        from property id
        """
        retList = []
        # this information might need to be implemented and requested from
        # NvCameraTools(?)
        # property type, count

        propInfo = getPropertyInfo(propertyId)
        if (propInfo != None):
            return propInfo
        else:
            raise NvCameraException(NvError_BadValue, "Invalid property id!")

# This file is compatible with both classic and new-style classes.


