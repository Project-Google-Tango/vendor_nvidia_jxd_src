/*
 * Copyright (c) 2007-2012, NVIDIA CORPORATION.  All rights reserved.
 *
 * NVIDIA Corporation and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA CORPORATION is strictly prohibited.
 */

/*
 * Generate SWI stubs for a subset of the NVOS API
 */
#include <stdio.h>
#include "nvcommon.h"
#include "nvassert.h"
#include "nvos.h"
#include "nvrm_memmgr.h"

#if NVOS_TRACE || NV_DEBUG
#undef NvOsAlloc
#undef NvOsFree
#undef NvOsRealloc
#undef NvOsSharedMemAlloc
#undef NvOsSharedMemMap
#undef NvOsSharedMemUnmap
#undef NvOsSharedMemFree
#undef NvOsMutexCreate
#undef NvOsExecAlloc
#undef NvOsExecFree
#undef NvOsPageAlloc
#undef NvOsPageLock
#undef NvOsPageFree
#undef NvOsPageLock
#undef NvOsPageMap
#undef NvOsPageMapIntoPtr
#undef NvOsPageUnmap
#undef NvOsPageAddress
#undef NvOsIntrMutexCreate
#undef NvOsIntrMutexLock
#undef NvOsIntrMutexUnlock
#undef NvOsIntrMutexDestroy
#undef NvOsInterruptRegister
#undef NvOsInterruptUnregister
#undef NvOsInterruptEnable
#undef NvOsInterruptDone
#undef NvOsPhysicalMemMapIntoCaller
#undef NvOsMutexLock
#undef NvOsMutexUnlock
#undef NvOsMutexDestroy
#undef NvOsPhysicalMemMap
#undef NvOsPhysicalMemUnmap
#undef NvOsSemaphoreCreate
#undef NvOsSemaphoreWait
#undef NvOsSemaphoreWaitTimeout
#undef NvOsSemaphoreSignal
#undef NvOsSemaphoreDestroy
#undef NvOsSemaphoreClone
#undef NvOsSemaphoreUnmarshal
#undef NvOsThreadCreate
#undef NvOsThreadJoin
#undef NvOsThreadYield
#undef NvOsFopen
#endif

// Include autogenerated SWIs
#include "nvos_swi_client.h"

__swi(0x65) void NvOsDebugString_swi(const char* Msg);

__swi(0x82) NvU32 NvOsGetTimeUS_swi(void);

__swi(0x78) void *NvOsAlloc_swi(size_t size);

__swi(0x79) void *NvOsRealloc_swi(void *ptr, size_t size);

__swi(0x7A) void NvOsFree_swi(void *ptr);

__swi(0x8A) NvS32 NvOsSnprintf_swi(char* str, size_t size, const char* Msg);

// FIXME: put in swi handlers for trace logging
#if NVOS_TRACE
void
NvOsTraceLogPrintf( const char *format, ... )
{
}
void
NvOsTraceLogStart( void )
{
}
void
NvOsTraceLogEnd( void )
{
}
#endif

void NvOsDebugPrintf(const char *format, ...)
{
    va_list ap;
    char buffer[1024];
    va_start(ap, format);
    vsprintf(buffer, format, ap);
    NvOsDebugString_swi(buffer);
    va_end(ap);
}

NvS32
NvOsSnprintf( char *str, size_t size, const char *format, ... )
{
    int n;
    va_list ap;
    char buffer[1024];

    if (size > 1024)
        return -1;
    va_start( ap, format );
    vsprintf(buffer, format, ap);
    n = NvOsSnprintf_swi( str, size, buffer );
    va_end( ap );

    return n;
}

void NvOsDebugVprintf(const char *format, va_list ap)
{
    char buffer[1024];
    vsprintf(buffer, format, ap);
    NvOsDebugString_swi(buffer);
}

NvS32
NvOsDebugNprintf( const char *format, ...)
{
    va_list ap;
    char buffer[256];
    int msgSize = 256;
    int n;

    va_start(ap, format);
    n = vsprintf(buffer, format, ap);
    // output longer than msgSize + null termination, crop it
    if ((n < 0) || (n == msgSize))
    {
        n = msgSize - 1;
        buffer[n] = 0;
    }
    NvOsDebugString_swi(buffer);
    va_end(ap);

    return n;
}

void
NvOsDebugString(const char *str)
{
    NvOsDebugString_swi(str);
}

NvU64 NvOsGetTimeUS()
{
    return NvOsGetTimeUS_swi();
}


#if NV_DEBUG
void *NvOsAllocLeak(size_t size, const char *FileName, int LineNum)
#else
void *NvOsAlloc(size_t size)
#endif
{
    NvU32 additionalWords= 4;
    NvU32 *pAllocatedBuf = NULL;

     //This is to ensure that all allocations are aligned to 4 bytes always.
    pAllocatedBuf = (NvU32*)NvOsAlloc_swi(size + additionalWords);

    if (!pAllocatedBuf)
    {
        pAllocatedBuf = (NvU32*)NvRmHostAlloc(size + additionalWords);
        // Let the additional bytes be stored in the first word for host side
        // allocation. This serves a way to distinguish the same.
        *pAllocatedBuf = size + additionalWords;
    }
    else
    {
        // Null for OsAlloc
        *pAllocatedBuf = 0;
    }
    return (void*)(pAllocatedBuf + 1);
}

#if NV_DEBUG
void NvOsFreeLeak(void *ptr, const char *FileName, int LineNum)
#else
void NvOsFree(void *ptr)
#endif
{
    NvU32 *pAllocatedBuf;
    NvU32 additionalWords = 1;
    pAllocatedBuf =((NvU32*)ptr);
    pAllocatedBuf = pAllocatedBuf - additionalWords;
    if(!ptr){
        NvOsFree_swi(ptr);
        return;
    }
        // Null for NvOsAlloc
    if (*pAllocatedBuf == 0){
         NvOsFree_swi((void*)pAllocatedBuf);
    }else{
        NvRmHostFree((void*)pAllocatedBuf);
    }
}

#if NV_DEBUG
void *NvOsReallocLeak(void *ptr, size_t size, const char *FileName, int LineNum)
#else
void *NvOsRealloc(void *ptr, size_t size)
#endif
{
     void *lptr = NULL;
     if (!ptr)
#if NV_DEBUG
       return NvOsAllocLeak(size, FileName, LineNum);
#else
       return NvOsAlloc(size);
#endif
    if (!size){
#if NV_DEBUG
        NvOsFreeLeak(ptr, FileName, LineNum);
#else
        NvOsFree(ptr);
#endif
        return (void *)lptr;
    }
    if(ptr){
#if NV_DEBUG
        lptr = NvOsAllocLeak(size, FileName, LineNum);
#else
        lptr = NvOsAlloc(size);
#endif
        NvOsMemcpy((void *)lptr,( const void *) ptr, size);
#if NV_DEBUG
        NvOsFreeLeak(ptr, FileName, LineNum);
#else
        NvOsFree(ptr);
#endif
        return (void *)lptr;
    }
    return (void *)lptr;
}

void NvOsSetResourceAllocFileLine(void* ptr, const char* f, int l)
{
} 
