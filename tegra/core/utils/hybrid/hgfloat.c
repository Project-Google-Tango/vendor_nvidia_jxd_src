/*------------------------------------------------------------------------
 *
 * Hybrid Compatibility Header
 * -----------------------------------------
 *
 * (C) 2004 Hybrid Graphics, Ltd.
 * All Rights Reserved.
 *
 * This file consists of unpublished, proprietary source code of
 * Hybrid Graphics, and is considered Confidential Information for
 * purposes of non-disclosure agreement. Disclosure outside the terms
 * outlined in signed agreement may result in irreparable harm to
 * Hybrid Graphics and legal action against the party in breach.
 *
 * $Id: //hybrid/libs/hg/main/hgFloat.c#2 $
 * $Date: 2005/12/07 $
 * $Author: tero $ 
 *
 *//**
 * \file
 * \brief   Implementation of HG emulated floating-point math
 * \author  wili@hybrid.fi
 *//*-------------------------------------------------------------------*/

/*----------------------------------------------------------------------*
 * Lint suppressions for LINT level 2
 *----------------------------------------------------------------------*/

/*lint -e502 */ /* expected unsigned type   */
/*lint -e528 */ /* unreferenced functions   */

/*----------------------------------------------------------------------*
 * Lint suppressions for LINT level 3
 *----------------------------------------------------------------------*/

/*lint -e701 */ /* shift left of signed quantity    */
/*lint -e702 */ /* shift right of signed quantity   */
/*lint -e755 */ /* global macro not referenced      */
/*lint -e756 */ /* global typedef not referenced    */

/* FIX THESE: */

/*lint -e713 */ 
/*lint -e732 */ /* Loss of sign */
/*lint -e737 */ /* Loss of sign in promotion from int to unsigned int */

#include "hgfloat.h"

#if (HG_COMPILER == HG_COMPILER_INTELC)
#       pragma warning (disable:981)
#       pragma warning (disable:279) /* controlling expression is constant (caused by some of our macros) */
#endif


/*@-shiftnegative -shiftimplementation -predboolint -boolops@*/

#include "hgint64.h"

#define IUNITSCALAR_HALF    0x10000000
#define IUNITSCALAR_ONE     0x20000000
#define IUNITSCALAR_TWO     0x40000000
#define IUNITSCALAR_THREE   0x60000000

/*-------------------------------------------------------------------*//*!
 * \brief   Lookup table for computing reciprocals 
 *//*-------------------------------------------------------------------*/

static const HGuint8 s_rcpTable[256] = /*@-type@*/ 
{
    0xff,0xfe,0xfd,0xfc,0xfb,0xfa,0xf9,0xf8,
    0xf7,0xf6,0xf5,0xf4,0xf3,0xf2,0xf1,0xf0,
    0xf0,0xef,0xee,0xed,0xec,0xeb,0xea,0xea,
    0xe9,0xe8,0xe7,0xe6,0xe5,0xe5,0xe4,0xe3,
    0xe2,0xe1,0xe1,0xe0,0xdf,0xde,0xde,0xdd,
    0xdc,0xdb,0xdb,0xda,0xd9,0xd9,0xd8,0xd7,
    0xd6,0xd6,0xd5,0xd4,0xd4,0xd3,0xd2,0xd2,
    0xd1,0xd0,0xd0,0xcf,0xce,0xce,0xcd,0xcc,
    0xcc,0xcb,0xca,0xca,0xc9,0xc9,0xc8,0xc7,
    0xc7,0xc6,0xc5,0xc5,0xc4,0xc4,0xc3,0xc3,
    0xc2,0xc1,0xc1,0xc0,0xc0,0xbf,0xbf,0xbe,
    0xbd,0xbd,0xbc,0xbc,0xbb,0xbb,0xba,0xba,
    0xb9,0xb9,0xb8,0xb8,0xb7,0xb7,0xb6,0xb6,
    0xb5,0xb5,0xb4,0xb4,0xb3,0xb3,0xb2,0xb2,
    0xb1,0xb1,0xb0,0xb0,0xaf,0xaf,0xae,0xae,
    0xad,0xad,0xac,0xac,0xac,0xab,0xab,0xaa,
    0xaa,0xa9,0xa9,0xa8,0xa8,0xa8,0xa7,0xa7,
    0xa6,0xa6,0xa5,0xa5,0xa5,0xa4,0xa4,0xa3,
    0xa3,0xa3,0xa2,0xa2,0xa1,0xa1,0xa1,0xa0,
    0xa0,0x9f,0x9f,0x9f,0x9e,0x9e,0x9d,0x9d,
    0x9d,0x9c,0x9c,0x9c,0x9b,0x9b,0x9a,0x9a,
    0x9a,0x99,0x99,0x99,0x98,0x98,0x98,0x97,
    0x97,0x97,0x96,0x96,0x95,0x95,0x95,0x94,
    0x94,0x94,0x93,0x93,0x93,0x92,0x92,0x92,
    0x91,0x91,0x91,0x90,0x90,0x90,0x90,0x8f,
    0x8f,0x8f,0x8e,0x8e,0x8e,0x8d,0x8d,0x8d,
    0x8c,0x8c,0x8c,0x8c,0x8b,0x8b,0x8b,0x8a,
    0x8a,0x8a,0x89,0x89,0x89,0x89,0x88,0x88,
    0x88,0x87,0x87,0x87,0x87,0x86,0x86,0x86,
    0x86,0x85,0x85,0x85,0x84,0x84,0x84,0x84,
    0x83,0x83,0x83,0x83,0x82,0x82,0x82,0x82,
    0x81,0x81,0x81,0x81,0x80,0x80,0x80,0x80
}; /*@=type@*/

#   define F0(X) ((HGint32)((X) * (1<<30)))
#   define F1(X) ((HGint32)((X) * (1<<27)))
#   define F2(X) ((HGint32)((X) * (1<<24)))

static const HGint32 s_log2lut[64][3] = {
    { F0(-0.177758380771f), F1(+1.432355165482f), F2(-1.153676748276f)},
    { F0(-0.172045901418f), F1(+1.409151554108f), F2(-1.130113840103f)},
    { F0(-0.167079374194f), F1(+1.388660430908f), F2(-1.108977913857f)},
    { F0(-0.162124589086f), F1(+1.367919921875f), F2(-1.087273120880f)},
    { F0(-0.157425448298f), F1(+1.347949385643f), F2(-1.066055297852f)},
    { F0(-0.153002709150f), F1(+1.328877806664f), F2(-1.045495390892f)},
    { F0(-0.148211166263f), F1(+1.307903409004f), F2(-1.022541999817f)},
    { F0(-0.144491747022f), F1(+1.291389703751f), F2(-1.004212379456f)},
    { F0(-0.140533164144f), F1(+1.273576736450f), F2(-0.984173476696f)},
    { F0(-0.136735051870f), F1(+1.256248474121f), F2(-0.964409172535f)},
    { F0(-0.133169248700f), F1(+1.239758253098f), F2(-0.945344150066f)},
    { F0(-0.129829466343f), F1(+1.224113106728f), F2(-0.927021861076f)},
    { F0(-0.126220792532f), F1(+1.206982016563f), F2(-0.906690657139f)},
    { F0(-0.123123750091f), F1(+1.192078948021f), F2(-0.888762056828f)},
    { F0(-0.119870960712f), F1(+1.176229834557f), F2(-0.869455933571f)},
    { F0(-0.116712301970f), F1(+1.160629510880f), F2(-0.850193738937f)},
    { F0(-0.113988518715f), F1(+1.147005796432f), F2(-0.833158135414f)},
    { F0(-0.111369997263f), F1(+1.133749961853f), F2(-0.816381692886f)},
    { F0(-0.108198471367f), F1(+1.117491483688f), F2(-0.795544743538f)},
    { F0(-0.106380671263f), F1(+1.108064651489f), F2(-0.783323049545f)},
    { F0(-0.103099152446f), F1(+1.090839147568f), F2(-0.760717630386f)},
    { F0(-0.101046130061f), F1(+1.079927444458f), F2(-0.746218800545f)},
    { F0(-0.098723269999f), F1(+1.067442417145f), F2(-0.729442477226f)},
    { F0(-0.096463933587f), F1(+1.055157661438f), F2(-0.712743401527f)},
    { F0(-0.094311550260f), F1(+1.043318748474f), F2(-0.696463882923f)},
    { F0(-0.092215768993f), F1(+1.031661272049f), F2(-0.680253028870f)},
    { F0(-0.090189084411f), F1(+1.020261406898f), F2(-0.664222359657f)},
    { F0(-0.088110566139f), F1(+1.008434176445f), F2(-0.647397518158f)},
    { F0(-0.086331121624f), F1(+0.998201131821f), F2(-0.632685661316f)},
    { F0(-0.084494315088f), F1(+0.987524926662f), F2(-0.617172181606f)},
    { F0(-0.082715511322f), F1(+0.977074682713f), F2(-0.601823687553f)},
    { F0(-0.080992296338f), F1(+0.966843307018f), F2(-0.586636781693f)},
    { F0(-0.079322375357f), F1(+0.956824004650f), F2(-0.571608126163f)},
    { F0(-0.077703572810f), F1(+0.947010219097f), F2(-0.556734383106f)},
    { F0(-0.076133824885f), F1(+0.937395691872f), F2(-0.542012453079f)},
    { F0(-0.074611164629f), F1(+0.927974402905f), F2(-0.527439177036f)},
    { F0(-0.073133736849f), F1(+0.918740630150f), F2(-0.513011693954f)},
    { F0(-0.071699760854f), F1(+0.909688830376f), F2(-0.498727053404f)},
    { F0(-0.070307545364f), F1(+0.900813639164f), F2(-0.484582483768f)},
    { F0(-0.069011136889f), F1(+0.892470479012f), F2(-0.471159219742f)},
    { F0(-0.067642070353f), F1(+0.883572876453f), F2(-0.456702709198f)},
    { F0(-0.066365815699f), F1(+0.875197589397f), F2(-0.442962288857f)},
    { F0(-0.065125353634f), F1(+0.866979658604f), F2(-0.429351478815f)},
    { F0(-0.063919335604f), F1(+0.858914554119f), F2(-0.415867924690f)},
    { F0(-0.062746517360f), F1(+0.850998163223f), F2(-0.402509212494f)},
    { F0(-0.061875291169f), F1(+0.845068752766f), F2(-0.392420649529f)},
    { F0(-0.060495682061f), F1(+0.835595190525f), F2(-0.376157224178f)},
    { F0(-0.059415414929f), F1(+0.828100979328f), F2(-0.363159596920f)},
    { F0(-0.058363825083f), F1(+0.820739924908f), F2(-0.350277990103f)},
    { F0(-0.057339906693f), F1(+0.813508629799f), F2(-0.337510406971f)},
    { F0(-0.056342702359f), F1(+0.806403636932f), F2(-0.324854820967f)},
    { F0(-0.055371284485f), F1(+0.799421668053f), F2(-0.312309294939f)},
    { F0(-0.054424777627f), F1(+0.792559564114f), F2(-0.299871921539f)},
    { F0(-0.053502328694f), F1(+0.785814285278f), F2(-0.287540853024f)},
    { F0(-0.052603140473f), F1(+0.779182851315f), F2(-0.275314301252f)},
    { F0(-0.051726426929f), F1(+0.772662401199f), F2(-0.263190478086f)},
    { F0(-0.050871454179f), F1(+0.766250193119f), F2(-0.251167714596f)},
    { F0(-0.050037503242f), F1(+0.759943485260f), F2(-0.239244312048f)},
    { F0(-0.049223892391f), F1(+0.753739774227f), F2(-0.227418646216f)},
    { F0(-0.048429962248f), F1(+0.747636556625f), F2(-0.215689122677f)},
    { F0(-0.047655090690f), F1(+0.741631329060f), F2(-0.204054206610f)},
    { F0(-0.046898666769f), F1(+0.735721886158f), F2(-0.192512363195f)},
    { F0(-0.046160109341f), F1(+0.729905784130f), F2(-0.181062132120f)},
    { F0(-0.045438863337f), F1(+0.724180996418f), F2(-0.169702067971f)}
};

#   undef F0
#   undef F1
#   undef F2

#   define F0(X) ((HGint32)((X) * (1<<30)))
#   define F1(X) ((HGint32)((X) * (1<<28)))
#   define F2(X) ((HGint32)((X) * (1<<26)))

/*----------------------------------------------------------------
 * Lookup table containing coefficients of the polynomials for
 * the exp2 function
 *--------------------------------------------------------------*/

static const HGint32 s_exp2lut[32][3] = {
    { F0(+0.485689550638f), F1(+0.414860606194f), F2(+1.099449872971f)},
    { F0(+0.496324777603f), F1(+0.392924576998f), F2(+1.110761046410f)},
    { F0(+0.507192850113f), F1(+0.369828939438f), F2(+1.123031139374f)},
    { F0(+0.518298923969f), F1(+0.345533460379f), F2(+1.136318206787f)},
    { F0(+0.529908835888f), F1(+0.319393068552f), F2(+1.151032567024f)},
    { F0(+0.541245996952f), F1(+0.293175786734f), F2(+1.166189551353f)},
    { F0(+0.553097724915f), F1(+0.265026897192f), F2(+1.182903647423f)},
    { F0(+0.564514040947f), F1(+0.237212076783f), F2(+1.199845790863f)},
    { F0(+0.577585458755f), F1(+0.204562455416f), F2(+1.220233917236f)},
    { F0(+0.590232968330f), F1(+0.172152236104f), F2(+1.240997314453f)},
    { F0(+0.602964460850f), F1(+0.138733461499f), F2(+1.262927532196f)},
    { F0(+0.616364777088f), F1(+0.102728463709f), F2(+1.287112832069f)},
    { F0(+0.629951059818f), F1(+0.065357066691f), F2(+1.312811970711f)},
    { F0(+0.643653571606f), F1(+0.026819942519f), F2(+1.339907646179f)},
    { F0(+0.657747745514f), F1(-0.013702013530f), F2(+1.369033694267f)},
    { F0(+0.672127068043f), F1(-0.055953182280f), F2(+1.400070786476f)},
    { F0(+0.686247169971f), F1(-0.098293267190f), F2(+1.431810975075f)},
    { F0(+0.702121853828f), F1(-0.146891072392f), F2(+1.469004869461f)},
    { F0(+0.717693507671f), F1(-0.195581138134f), F2(+1.507066607475f)},
    { F0(+0.732615709305f), F1(-0.243145361543f), F2(+1.544969320297f)},
    { F0(+0.748992443085f), F1(-0.296356528997f), F2(+1.588192939758f)},
    { F0(+0.765706479549f), F1(-0.351731091738f), F2(+1.634057998657f)},
    { F0(+0.782278120518f), F1(-0.407676696777f), F2(+1.681276082993f)},
    { F0(+0.799255311489f), F1(-0.466034740210f), F2(+1.731426954269f)},
    { F0(+0.816804170609f), F1(-0.527457416058f), F2(+1.785173535347f)},
    { F0(+0.834477543831f), F1(-0.590411901474f), F2(+1.841236591339f)},
    { F0(+0.853258311749f), F1(-0.658496737480f), F2(+1.902943015099f)},
    { F0(+0.871441066265f), F1(-0.725547075272f), F2(+1.964756727219f)},
    { F0(+0.890853106976f), F1(-0.798335909843f), F2(+2.032990694046f)},
    { F0(+0.910079956055f), F1(-0.871640682220f), F2(+2.102861881256f)},
    { F0(+0.930340886116f), F1(-0.950150609016f), F2(+2.178917646408f)},
    { F0(+0.950195968151f), F1(-1.028325557709f), F2(+2.255867004395f)}
};

#   undef F0
#   undef F1
#   undef F2

/*----------------------------------------------------------------
 * Lookup table for square root
 *--------------------------------------------------------------*/

#    define F0(X) ((HGint32)((X)*(1<<30)))
#    define F1(X) ((HGint32)((X)*(1<<28)))
#    define F2(X) ((HGint32)((X)*(1<<26)))
#    define F3(X) ((HGint32)((X)*(1<<30)))
#    define F4(X) ((HGint32)((X)*(1<<27)))
#    define F5(X) ((HGint32)((X)*(1<<24)))
   
static const HGint32 s_sqrtlut[64][3] = {
    { F0(-0.121923886240f), F1(+0.743807792664f), F2(+0.378116190434f)},
    { F0(-0.116560123861f), F1(+0.732734739780f), F2(+0.383831143379f)},
    { F0(-0.111665345728f), F1(+0.722329318523f), F2(+0.389361321926f)},
    { F0(-0.107254542410f), F1(+0.712695896626f), F2(+0.394621312618f)},
    { F0(-0.102594681084f), F1(+0.702216446400f), F2(+0.400513112545f)},
    { F0(-0.098709732294f), F1(+0.693242132664f), F2(+0.405695855618f)},
    { F0(-0.094428181648f), F1(+0.683065056801f), F2(+0.411743581295f)},
    { F0(-0.090902730823f), F1(+0.674455285072f), F2(+0.417000353336f)},
    { F0(-0.087709493935f), F1(+0.666464865208f), F2(+0.421999037266f)},
    { F0(-0.084806129336f), F1(+0.659029960632f), F2(+0.426758885384f)},
    { F0(-0.081869192421f), F1(+0.651332616806f), F2(+0.431802332401f)},
    { F0(-0.078673861921f), F1(+0.642742693424f), F2(+0.437575459480f)},
    { F0(-0.076437719166f), F1(+0.636597573757f), F2(+0.441797316074f)},
    { F0(-0.073876932263f), F1(+0.629408001900f), F2(+0.446843624115f)},
    { F0(-0.071668498218f), F1(+0.623074293137f), F2(+0.451384782791f)},
    { F0(-0.069212421775f), F1(+0.615869760513f), F2(+0.456668138504f)},
    { F0(-0.067035391927f), F1(+0.609342694283f), F2(+0.461560487747f)},
    { F0(-0.064668916166f), F1(+0.602089762688f), F2(+0.467117905617f)},
    { F0(-0.062988281250f), F1(+0.596824645996f), F2(+0.471241474152f)},
    { F0(-0.061358049512f), F1(+0.591631591320f), F2(+0.475377082825f)},
    { F0(-0.059153761715f), F1(+0.584457516670f), F2(+0.481214404106f)},
    { F0(-0.057809762657f), F1(+0.579999029636f), F2(+0.484912037849f)},
    { F0(-0.056281633675f), F1(+0.574844717979f), F2(+0.489258348942f)},
    { F0(-0.054757460952f), F1(+0.569604814053f), F2(+0.493761897087f)},
    { F0(-0.053333144635f), F1(+0.564623355865f), F2(+0.498117506504f)},
    { F0(-0.051657937467f), F1(+0.558649420738f), F2(+0.503443479538f)},
    { F0(-0.050589986145f), F1(+0.554769814014f), F2(+0.506966948509f)},
    { F0(-0.048884443939f), F1(+0.548469066620f), F2(+0.512786269188f)},
    { F0(-0.048339843750f), F1(+0.546424865723f), F2(+0.514704465866f)},
    { F0(-0.046875000000f), F1(+0.540847778320f), F2(+0.520012855530f)},
    { F0(-0.045898437500f), F1(+0.537063598633f), F2(+0.523678779602f)},
    { F0(-0.044885635376f), F1(+0.533084213734f), F2(+0.527587652206f)},

    { F3(-0.043194618076f), F4(+0.526308774948f), F5(+0.534374594688f)},
    { F3(-0.041248757392f), F4(+0.518283784389f), F5(+0.542648792267f)},
    { F3(-0.039506904781f), F4(+0.510883212090f), F5(+0.550509572029f)},
    { F3(-0.037853199989f), F4(+0.503652334213f), F5(+0.558413982391f)},
    { F3(-0.036262698472f), F4(+0.496496081352f), F5(+0.566463828087f)},
    { F3(-0.034931831062f), F4(+0.490348100662f), F5(+0.573564052582f)},
    { F3(-0.033423401415f), F4(+0.483185499907f), F5(+0.582066893578f)},
    { F3(-0.032233495265f), F4(+0.477380514145f), F5(+0.589146852493f)},
    { F3(-0.030977860093f), F4(+0.471098840237f), F5(+0.597003459930f)},
    { F3(-0.029980376363f), F4(+0.465988814831f), F5(+0.603548049927f)},
    { F3(-0.028825229034f), F4(+0.459923088551f), F5(+0.611510992050f)},
    { F3(-0.027842888609f), F4(+0.454638272524f), F5(+0.618618965149f)},
    { F3(-0.027055926621f), F4(+0.450315654278f), F5(+0.624554753304f)},
    { F3(-0.026082254946f), F4(+0.444846332073f), F5(+0.632235407829f)},
    { F3(-0.025204662234f), F4(+0.439799517393f), F5(+0.639491200447f)},
    { F3(-0.024453025311f), F4(+0.435383737087f), F5(+0.645976781845f)},
    { F3(-0.023748265579f), F4(+0.431160449982f), F5(+0.652303814888f)},
    { F3(-0.022947432473f), F4(+0.426256954670f), F5(+0.659809947014f)},
    { F3(-0.022287566215f), F4(+0.422131150961f), F5(+0.666259169579f)},
    { F3(-0.021697435528f), F4(+0.418372601271f), F5(+0.672243833542f)},
    { F3(-0.021000415087f), F4(+0.413843870163f), F5(+0.679600000381f)},
    { F3(-0.020399093628f), F4(+0.409855335951f), F5(+0.686213970184f)},
    { F3(-0.019878791645f), F4(+0.406339943409f), F5(+0.692151904106f)},
    { F3(-0.019299130887f), F4(+0.402352094650f), F5(+0.699010729790f)},
    { F3(-0.018833069131f), F4(+0.399086415768f), F5(+0.704731345177f)},
    { F3(-0.018355362117f), F4(+0.395682752132f), F5(+0.710794210434f)},
    { F3(-0.017900746316f), F4(+0.392389357090f), F5(+0.716758847237f)},
    { F3(-0.017427470535f), F4(+0.388900011778f), F5(+0.723190426826f)},
    { F3(-0.017062200233f), F4(+0.386164933443f), F5(+0.728310346603f)},
    { F3(-0.016664490104f), F4(+0.383140891790f), F5(+0.734058737755f)},
    { F3(-0.016156014055f), F4(+0.379202395678f), F5(+0.741685390472f)},
    { F3(-0.015804255381f), F4(+0.376429170370f), F5(+0.747151374817f)}

};

#   undef F0
#   undef F1
#   undef F2
#   undef F3
#   undef F4
#   undef F5

/*----------------------------------------------------------------
 * Lookup table for reciprocal square root
 *--------------------------------------------------------------*/

#    define F0(X) ((HGint32)((X)*(1<<30)))
#    define F1(X) ((HGint32)((X)*(1<<28)))
#    define F2(X) ((HGint32)((X)*(1<<26)))
#    define F3(X) ((HGint32)((X)*(1<<30)))
#    define F4(X) ((HGint32)((X)*(1<<27)))
#    define F5(X) ((HGint32)((X)*(1<<24)))

static const HGint32 s_rsqlut[128][3] = {
        /* odd exponents */
    { F0(+0.36779087182731), F1(-1.23554436635219), F2(+1.86775349452488)},
    { F0(+0.35391291097221), F1(-1.20735621790263), F2(+1.85343994156165)},
    { F0(+0.34075716168081), F1(-1.18022384760802), F2(+1.83945051572886)},
    { F0(+0.32827601045938), F1(-1.15409271068978), F2(+1.82577316532057)},
    { F0(+0.31642562493744), F1(-1.12891183276912), F2(+1.81239645681049)},
    { F0(+0.30516560407250), F1(-1.10463352833783), F2(+1.79930953468388)},
    { F0(+0.29445866515471), F1(-1.08121314506462), F2(+1.78650208439902)},
    { F0(+0.28427036329413), F1(-1.05860883125854), F2(+1.77396429820379)},
    { F0(+0.27456883963441), F1(-1.03678132412993), F2(+1.76168684356594)},
    { F0(+0.26532459499595), F1(-1.01569375671468), F2(+1.74966083397471)},
    { F0(+0.25651028607081), F1(-0.99531148157639), F2(+1.73787780189930)},
    { F0(+0.24810054166846), F1(-0.97560190965289), F2(+1.72632967373289)},
    { F0(+0.24007179678665), F1(-0.95653436272227), F2(+1.71500874652751)},
    { F0(+0.23240214259931), F1(-0.93807993823904), F2(+1.70390766640627)},
    { F0(+0.22507119062720), F1(-0.92021138529823), F2(+1.69301940847604)},
    { F0(+0.21805994961414), F1(-0.90290299074044), F2(+1.68233725815337)},
    { F0(+0.21135071375920), F1(-0.88613047440622), F2(+1.67185479375893)},
    { F0(+0.20492696113160), F1(-0.86987089269951), F2(+1.66156587027800)},
    { F0(+0.19877326125425), F1(-0.85410254977107), F2(+1.65146460423477)},
    { F0(+0.19287519090722), F1(-0.83880491558092), F2(+1.64154535955767)},
    { F0(+0.18721925731461), F1(-0.82395855018446), F2(+1.63180273432770)},
    { F0(+0.18179282805886), F1(-0.80954503388529), F2(+1.62223154846473)},
    { F0(+0.17658406697410), F1(-0.79554690250474), F2(+1.61282683212302)},
    { F0(+0.17158187550012), F1(-0.78194758747948), F2(+1.60358381483930)},
    { F0(+0.16677583897490), F1(-0.76873136037558), F2(+1.59449791537695)},
    { F0(+0.16215617739272), F1(-0.75588328143056), F2(+1.58556473220351)},
    { F0(+0.15771370016682), F1(-0.74338915166241), F2(+1.57678003446553)},
    { F0(+0.15343976464646), F1(-0.73123546858706), F2(+1.56813975365821)},
    { F0(+0.14932623788263), F1(-0.71940938479285), F2(+1.55963997561837)},
    { F0(+0.14536546151339), F1(-0.70789866960700), F2(+1.55127693314556)},
    { F0(+0.14155021935403), F1(-0.69669167322020), F2(+1.54304699893099)},
    { F0(+0.13787370755563), F1(-0.68577729337174), F2(+1.53494667898518)},
    { F0(+0.13432950702918), F1(-0.67514494416804), F2(+1.52697260636413)},
    { F0(+0.13091155801885), F1(-0.66478452710680), F2(+1.51912153534900)},
    { F0(+0.12761413654425), F1(-0.65468640385181), F2(+1.51139033583405)},
    { F0(+0.12443183264622), F1(-0.64484137090601), F2(+1.50377598811919)},
    { F0(+0.12135953021971), F1(-0.63524063584482), F2(+1.49627557793208)},
    { F0(+0.11839238834273), F1(-0.62587579512029), F2(+1.48888629176111)},
    { F0(+0.11552582394506), F1(-0.61673881321795), F2(+1.48160541239949)},
    { F0(+0.11275549574111), F1(-0.60782200317435), F2(+1.47443031476968)},
    { F0(+0.11007728929599), F1(-0.59911800826742), F2(+1.46735846194009)},
    { F0(+0.10748730314299), F1(-0.59061978482252), F2(+1.46038740134122)},
    { F0(+0.10498183588061), F1(-0.58232058609410), F2(+1.45351476120121)},
    { F0(+0.10255737416173), F1(-0.57421394711447), F2(+1.44673824715992)},
    { F0(+0.10021058150778), F1(-0.56629367044994), F2(+1.44005563905700)},
    { F0(+0.09793828786951), F1(-0.55855381275211), F2(+1.43346478784027)},
    { F0(+0.09573747992272), F1(-0.55098867220453), F2(+1.42696361271849)},
    { F0(+0.09360529197147), F1(-0.54359277655996), F2(+1.42055009833576)},
    { F0(+0.09153899750072), F1(-0.53636087202938), F2(+1.41422229222391)},
    { F0(+0.08953600123095), F1(-0.52928791262349), F2(+1.40797830222031)},
    { F0(+0.08759383173856), F1(-0.52236905026820), F2(+1.40181629415853)},
    { F0(+0.08571013451819), F1(-0.51559962535539), F2(+1.39573448956407)},
    { F0(+0.08388266550719), F1(-0.50897515788451), F2(+1.38973116351627)},
    { F0(+0.08210928502012), F1(-0.50249133909199), F2(+1.38380464261028)},
    { F0(+0.08038795203902), F1(-0.49614402344423), F2(+1.37795330292694)},
    { F0(+0.07871671890825), F1(-0.48992922124326), F2(+1.37217556825950)},
    { F0(+0.07709372631143), F1(-0.48384309146111), F2(+1.36646990826618)},
    { F0(+0.07551719857565), F1(-0.47788193502700), F2(+1.36083483677052)},
    { F0(+0.07398543926865), F1(-0.47204218849727), F2(+1.35526891016438)},
    { F0(+0.07249682705151), F1(-0.46632041802008), F2(+1.34977072584717)},
    { F0(+0.07104981176781), F1(-0.46071331356781), F2(+1.34433892068823)},
    { F0(+0.06964291080476), F1(-0.45521768362102), F2(+1.33897216970515)},
    { F0(+0.06827470561984), F1(-0.44983044993550), F2(+1.33366918461623)},
    { F0(+0.06694383850390), F1(-0.44454864270499), F2(+1.32842871258091)},

        /* even exponents */
    { F3(+0.06501685488183), F4(-0.43683089995196), F5(+1.32070116156313)},
    { F3(+0.06256355482446), F4(-0.42686488449328), F5(+1.31057995120017)},
    { F3(+0.06023792494102), F4(-0.41727214298263), F5(+1.30068793333082)},
    { F3(+0.05803154827413), F4(-0.40803339092317), F5(+1.29101658610641)},
    { F3(+0.05593667628364), F4(-0.39913060615648), F5(+1.28155782480927)},
    { F3(+0.05394616700642), F4(-0.39054692930806), F5(+1.27230397342990)},
    { F3(+0.05205342972727), F4(-0.38226657339055), F5(+1.26324773848128)},
    { F3(+0.05025237539348), F4(-0.37427474160154), F5(+1.25438218484062)},
    { F3(+0.04853737210146), F4(-0.36655755244747), F5(+1.24570071340981)},
    { F3(+0.04690320508416), F4(-0.35910197149026), F5(+1.23719704047930)},
    { F3(+0.04534504068124), F4(-0.35189574900797), F5(+1.22886517859682)},
    { F3(+0.04385839385805), F4(-0.34492736302983), F5(+1.22069941886337)},
    { F3(+0.04243909887009), F4(-0.33818596716049), F5(+1.21269431446511)},
    { F3(+0.04108328274856), F4(-0.33166134281191), F5(+1.20484466543158)},
    { F3(+0.03978734128555), F4(-0.32534385533467), F5(+1.19714550441379)},
    { F3(+0.03854791726940), F4(-0.31922441375337), F5(+1.18959208348338)},
    { F3(+0.03736188072708), F4(-0.31329443373505), F5(+1.18217986182706)},
    { F3(+0.03622631096596), F4(-0.30754580349195), F5(+1.17490449426125)},
    { F3(+0.03513848023817), F4(-0.30197085238755), F5(+1.16776182054607)},
    { F3(+0.03409583885309), F4(-0.29656232194893), F5(+1.16074785536722)},
    { F3(+0.03309600160378), F4(-0.29131333912505), F5(+1.15385877900056)},
    { F3(+0.03213673537311), F4(-0.28621739156937), F5(+1.14709092857587)},
    { F3(+0.03121594780168), F4(-0.28126830475632), F5(+1.14044078987353)},
    { F3(+0.03033167692365), F4(-0.27646022081927), F5(+1.13390498967342)},
    { F3(+0.02948208166936), F4(-0.27178757891645), F5(+1.12748028855126)},
    { F3(+0.02866543316100), F4(-0.26724509704016), F5(+1.12116357414799)},
    { F3(+0.02788010671861), F4(-0.26282775510116), F5(+1.11495185481107)},
    { F3(+0.02712457452117), F4(-0.25853077924028), F5(+1.10884225365888)},
    { F3(+0.02639739885444), F4(-0.25434962722085), F5(+1.10283200297330)},
    { F3(+0.02569722589669), F4(-0.25027997483652), F5(+1.09691843892621)},
    { F3(+0.02502277999588), F4(-0.24631770326486), F5(+1.09109899663330)},
    { F3(+0.02437285838960), F4(-0.24245888726118), F5(+1.08537120546679)},
    { F3(+0.02374632633382), F4(-0.23869978415479), F5(+1.07973268464960)},
    { F3(+0.02314211260250), F4(-0.23503682357130), F5(+1.07418113908989)},
    { F3(+0.02255920533139), F4(-0.23146659785689), F5(+1.06871435548770)},
    { F3(+0.02199664816521), F4(-0.22798585308056), F5(+1.06333019858758)},
    { F3(+0.02145353669471), F4(-0.22459148064378), F5(+1.05802660767680)},
    { F3(+0.02092901515880), F4(-0.22128050945058), F5(+1.05280159331291)},
    { F3(+0.02042227337824), F4(-0.21805009852249), F5(+1.04765323414846)},
    { F3(+0.01993254391368), F4(-0.21489753009971), F5(+1.04257967396102)},
    { F3(+0.01945909942901), F4(-0.21182020318881), F5(+1.03757911886990)},
    { F3(+0.01900125023576), F4(-0.20881562747412), F5(+1.03264983464554)},
    { F3(+0.01855834201319), F4(-0.20588141762614), F5(+1.02779014420063)},
    { F3(+0.01812975368284), F4(-0.20301528792982), F5(+1.02299842517134)},
    { F3(+0.01771489543262), F4(-0.20021504725853), F5(+1.01827310766219)},
    { F3(+0.01731320687281), F4(-0.19747859432889), F5(+1.01361267207668)},
    { F3(+0.01692415531670), F4(-0.19480391323594), F5(+1.00901564705891)},
    { F3(+0.01654723417710), F4(-0.19218906925550), F5(+1.00448060754966)},
    { F3(+0.01618196146910), F4(-0.18963220488865), F5(+1.00000617293864)},
    { F3(+0.01582787840766), F4(-0.18713153610793), F5(+0.99559100526325)},
    { F3(+0.01548454810313), F4(-0.18468534886345), F5(+0.99123380757754)},
    { F3(+0.01515155433344), F4(-0.18229199573220), F5(+0.98693332230522)},
    { F3(+0.01482850040111), F4(-0.17994989279835), F5(+0.98268832974961)},
    { F3(+0.01451500805865), F4(-0.17765751667697), F5(+0.97849764662211)},
    { F3(+0.01421071650338), F4(-0.17541340171324), F5(+0.97436012466165)},
    { F3(+0.01391528143336), F4(-0.17321613732248), F5(+0.97027464929705)},
    { F3(+0.01362837416536), F4(-0.17106436550065), F5(+0.96624013842132)},
    { F3(+0.01334968080255), F4(-0.16895677843423), F5(+0.96225554115941)},
    { F3(+0.01307890145404), F4(-0.16689211624670), F5(+0.95831983670935)},
    { F3(+0.01281574950553), F4(-0.16486916489292), F5(+0.95443203329178)},
    { F3(+0.01255995092583), F4(-0.16288675410393), F5(+0.95059116703277)},
    { F3(+0.01231124362289), F4(-0.16094375550212), F5(+0.94679630101837)},
    { F3(+0.01206937683173), F4(-0.15903908076605), F5(+0.94304652430019)},
    { F3(+0.01183411054103), F4(-0.15717167991070), F5(+0.93934095098631)}
};

#   undef F0
#   undef F1
#   undef F2

#if 0
#    define F0(X) ((HGint32)((X)*(1<<30)))
#    define F1(X) ((HGint32)((X)*(1<<28)))
#    define F2(X) ((HGint32)((X)*(1<<26)))

static const HGint32 s_rcplut[64][3] = {
    { F0(+0.97667689696650), F1(-2.95321561834293), F2(+2.97653859622991)},
    { F0(+0.93310339846460), F1(-2.86471165276815), F2(+2.93159737917440)},
    { F0(+0.89125905519768), F1(-2.77841450285356), F2(+2.88710372066178)},
    { F0(+0.85267298256326), F1(-2.69762826671113), F2(+2.84481874568899)},
    { F0(+0.81425112610099), F1(-2.61597401889223), F2(+2.80143556757841)},
    { F0(+0.78024580845833), F1(-2.54262230856501), F2(+2.76187937201294)},
    { F0(+0.74725046242897), F1(-2.47042519090344), F2(+2.72238563393302)},
    { F0(+0.71720454819024), F1(-2.40375586854411), F2(+2.68540223469774)},
    { F0(+0.68793365874080), F1(-2.33789954337763), F2(+2.64835983834489)},
    { F0(+0.66023417882570), F1(-2.27471306923482), F2(+2.61232549295240)},
    { F0(+0.63400205574817), F1(-2.21405405405673), F2(+2.57725860088432)},
    { F0(+0.60914139653778), F1(-2.15578947368441), F2(+2.54312071569665)},
    { F0(+0.58559200769400), F1(-2.09985509159960), F2(+2.50990689814469)},
    { F0(+0.56313509904139), F1(-2.04582019662708), F2(+2.47740264076926)},
    { F0(+0.54184483333887), F1(-1.99392640307407), F2(+2.44578050559523)},
    { F0(+0.52202400023302), F1(-1.94499898042909), F2(+2.41558627774270)},
    { F0(+0.50228204643570), F1(-1.89564667424713), F2(+2.38474259438207)},
    { F0(+0.48370127172758), F1(-1.84860408050097), F2(+2.35496702732865)},
    { F0(+0.46701327835276), F1(-1.80583522805432), F2(+2.32756443481846)},
    { F0(+0.44984293669337), F1(-1.76129813829426), F2(+2.29868382375637)},
    { F0(+0.43413194546915), F1(-1.72004566370511), F2(+2.27160453992287)},
    { F0(+0.41942704458415), F1(-1.68098495212175), F2(+2.24566523467903)},
    { F0(+0.40504764421166), F1(-1.64234161988890), F2(+2.21970262348405)},
    { F0(+0.39131810718027), F1(-1.60501567398144), F2(+2.19433348260951)},
    { F0(+0.37820213177292), F1(-1.56894790602668), F2(+2.16953769267623)},
    { F0(+0.36566582274918), F1(-1.53408239700286), F2(+2.14529603358868)},
    { F0(+0.35367750726982), F1(-1.50036630036956), F2(+2.12159013485211)},
    { F0(+0.34220756672676), F1(-1.46774964166356), F2(+2.09840242912295)},
    { F0(+0.33122828298110), F1(-1.43618513323885), F2(+2.07571610881498)},
    { F0(+0.32071369759706), F1(-1.40562800274819), F2(+2.05351508545222)},
    { F0(+0.31063948286828), F1(-1.37603583426757), F2(+2.03178395160556)},
    { F0(+0.30098282354993), F1(-1.34736842104937), F2(+2.01050794525338)},
    { F0(+0.29172230828044), F1(-1.31958762886353), F2(+1.98967291633097)},
    { F0(+0.28283782981816), F1(-1.29265726909162), F2(+1.96926529533184)},
    { F0(+0.27431049331062), F1(-1.26654298083132), F2(+1.94927206384986)},
    { F0(+0.26612253185158), F1(-1.24121212121338), F2(+1.92968072686764)},
    { F0(+0.25825722870832), F1(-1.21663366336750), F2(+1.91047928673556)},
    { F0(+0.25069884560162), F1(-1.19277810133916), F2(+1.89165621864967)},
    { F0(+0.24343255654094), F1(-1.16961736150610), F2(+1.87320044759428)},
    { F0(+0.23644438671909), F1(-1.14712471994129), F2(+1.85510132660912)},
    { F0(+0.22972115603807), F1(-1.12527472527839), F2(+1.83734861629897)},
    { F0(+0.22325042688044), F1(-1.10404312668300), F2(+1.81993246551816)},
    { F0(+0.21702045577331), F1(-1.08340680655711), F2(+1.80284339316116)},
    { F0(+0.21102014859844), F1(-1.06334371754765), F2(+1.78607227092199)},
    { F0(+0.20523901908928), F1(-1.04383282364935), F2(+1.76961030704743)},
    { F0(+0.19966715032751), F1(-1.02485404503948), F2(+1.75344903096735)},
    { F0(+0.19429515899992), F1(-1.00638820638434), F2(+1.73758027875342)},
    { F0(+0.18911416220817), F1(-0.98841698841643), F2(+1.72199617939481)},
    { F0(+0.18411574659331), F1(-0.97092288242619), F2(+1.70668914173241)},
    { F0(+0.17929193964483), F1(-0.95388914764371), F2(+1.69165184216654)},
    { F0(+0.17463518298337), F1(-0.93729977116803), F2(+1.67687721296874)},
    { F0(+0.17013830746964), F1(-0.92113943028487), F2(+1.66235843117404)},
    { F0(+0.16579451003054), F1(-0.90539345711912), F2(+1.64808890811693)},
    { F0(+0.16159733202676), F1(-0.89004780530311), F2(+1.63406227942930)},
    { F0(+0.15754063908389), F1(-0.87508901866030), F2(+1.62027239559385)},
    { F0(+0.15361860225312), F1(-0.86050420168255), F2(+1.60671331294199)},
    { F0(+0.14982568041796), F1(-0.84628099173572), F2(+1.59337928511842)},
    { F0(+0.14615660384788), F1(-0.83240753285315), F2(+1.58026475496116)},
    { F0(+0.14260635881692), F1(-0.81887245101922), F2(+1.56736434677794)},
    { F0(+0.13917017320910), F1(-0.80566483084282), F2(+1.55467285899281)},
    { F0(+0.13584350304518), F1(-0.79277419355128), F2(+1.54218525716048)},
    { F0(+0.13262201985708), F1(-0.78019047619048), F2(+1.52989666729907)},
    { F0(+0.12950159886168), F1(-0.76790401199958), F2(+1.51780236956653)},
    { F0(+0.12647830785863), F1(-0.75590551181125), F2(+1.50589779218797)}
};

#   undef F0
#   undef F1
#   undef F2
#endif

/*-------------------------------------------------------------------*//*!
 * \brief   Extract mantissa of a float (and adds the hidden bit)
 *          and returns the bit pattern
 * \param   a   Floating point value
 * \return  Mantissa of the float (with the hidden bit)
 *//*-------------------------------------------------------------------*/

HG_INLINE HGuint32 extractMantissa (HGifloat a)
{
    return (a & F_MANTISSA_MASK) | F_HIDDEN_BIT_MASK; 

/*      return ((a<<8)|(1<<31))>>8;*/
}

/*-------------------------------------------------------------------*//*!
 * \brief   Extracts the exponent of an IEEE floating-point value
 * \param   a   Floating point value
 * \return  Exponent (with bias still included)
 * \note        Depending on the platform, we may want slightly different
 *                      implementations.
 *//*-------------------------------------------------------------------*/

HG_INLINE HGint32 extractBiasedExponent (HGifloat a)
{
        return ((a+a) >> (F_EXPONENT_SHIFT + 1));
}

/*-------------------------------------------------------------------*//*!
 * \brief   Performs a signed logical shift right operation
 * \param   x           Integer value to be shifted
 * \param       shift   Shift value (positive if to right, negative if to left)
 * \return      Shifted value
 * \todo        Figure out the optimal way to do this on each platform
 *//*-------------------------------------------------------------------*/

HG_INLINE HGuint32 lsrSigned (
        HGuint32 x,
        HGint32  shift)
{
        if (shift >= 0)
                x >>= shift;
        else
                x <<= (-shift);         /*lint !e504 */ /* unusual shift */

        return x;
}

/*-------------------------------------------------------------------*//*!
 * \brief   Performs an arithmetic right shift operation as if the
 *                      underlying shifter unit was a modulo-256 one
 * \param   x           Integer value to be shifted
 * \param       shift   Shift value [0,255]
 * \return      Shifted value
 *//*-------------------------------------------------------------------*/

HG_INLINE HGint32 asrMod256 (
        HGint32 x,
        HGint32 shift)
{
        HG_ASSERT (shift <= 255);

#if (HG_SHIFTER_MODULO < 256)
        if (shift >= 31)
                shift = 31;
#endif
        return x >> shift;
}


/*-------------------------------------------------------------------*//*!
 * \internal
 * \brief   Internal function for aligning input floats into a format
 *          where they can be added together
 * \param   a                   Floating point value
 * \param   dstExponent         Exponent of the target format
 * \param   hiddenBitPosition   Where should the hidden bit go
 * \return  Signed mantissa in fixed-point format (actual format 
 *          determined by hiddenBitPosition)
 *//*-------------------------------------------------------------------*/

HG_INLINE HGint32 floatAlignMantissa (
    HGifloat a,
    HGint32  dstExponent,
    HGint32  hiddenBitPosition)
{
    HGint32 d;
    HGint32 shift;
    HGint32 exponent;

    HG_ASSERT (hiddenBitPosition >= F_EXPONENT_SHIFT);

    /*-------------------------------------------------------------------
     * Extract sign, exponent and mantissa
     *-----------------------------------------------------------------*/

    d           = (HGint32)(extractMantissa(a) << (hiddenBitPosition - F_EXPONENT_SHIFT));         
    exponent    = extractBiasedExponent(a);
    shift       = dstExponent - exponent;

    /*-------------------------------------------------------------------
     * Handle zeroes and denormals, shift mantissa into place and then
         * apply sign
     *-----------------------------------------------------------------*/
    
    if (exponent == 0)                  
        d = 0;

    d = hgCopySign32 (asrMod256(d,shift), (HGint32)(a));     

    return d;
}

/*-------------------------------------------------------------------*//*!
 * \internal
 * \brief   Internal function for aligning input floats into a format
 *          where they can be added together (unsigned)
 * \param   a                   Floating point value
 * \param   dstExponent         Exponent of the target format
 * \param   hiddenBitPosition   Where should the hidden bit go
 * \return  Unsigned mantissa in fixed-point format (actual format 
 *          determined by hiddenBitPosition)
 *//*-------------------------------------------------------------------*/

HG_INLINE HGuint32 floatAlignMantissaUnsigned (
    HGifloat a,
    HGint32  dstExponent,
    HGint32  hiddenBitPosition)
{
    /*-------------------------------------------------------------------
     * Extract exponent and mantissa
     *-----------------------------------------------------------------*/

    HGuint32    d           = extractMantissa(a) << (hiddenBitPosition - F_EXPONENT_SHIFT); 
    HGint32     exponent    = (HGint32)(a >> F_EXPONENT_SHIFT);
    HGint32     shift       = dstExponent - exponent;

    /*-------------------------------------------------------------------
     * Handle zeroes and denormals
     *-----------------------------------------------------------------*/

    if (exponent == 0)  
        d = 0;
    
    HG_ASSERT (hiddenBitPosition >= F_EXPONENT_SHIFT);
    HG_ASSERT (!(a & F_SIGN_MASK));

    /*-------------------------------------------------------------------
     * Shift mantissa in place
     *-----------------------------------------------------------------*/
    
    HG_ASSERT (shift >= 0);

#if (HG_SHIFTER_MODULO < 256)
    shift = hgMin32(shift, HG_SHIFTER_MODULO-1);
#endif

    return d >> shift;
}

/*-------------------------------------------------------------------*//*!
 * \internal
 * \brief   Returns larger of two unsigned integers
 * \param   a   Unsigned 32-bit integer
 * \param   b   Unsigned 32-bit integer
 * \return  Larger of the two
 *//*-------------------------------------------------------------------*/

HG_INLINE HGuint32 maxu (HGuint32 a, HGuint32 b)
{
    return a > b ? a : b;
}

/*-------------------------------------------------------------------*//*!
 * \brief       Builds a float out of components
 * \param       signMask    Either 0 or 0x80000000 (=negative)
 * \param       exponent    Biased exponent
 * \param       mantissa    23-bit mantissa (can contain hidden bit)
 * \note        Handles clamping of exponent and flushes denormalized
 *              values to zero
 * \return      IEEE floating-point value
 *//*-------------------------------------------------------------------*/

HG_INLINE HGifloat buildFloat (
    HGuint32 signMask,
    int      exponent,
    HGuint32 mantissa)
{
    HGifloat retValue;

    HG_ASSERT (signMask == 0 || signMask == 0x80000000u);
    HG_ASSERT (mantissa < (1u<<24));

    retValue = (exponent << F_EXPONENT_SHIFT) | (mantissa & F_MANTISSA_MASK);                                    

        if (exponent >= 255)                    /* handle overflow      */
                retValue = F_FLOAT_MAX;

        retValue |= signMask;                   /* apply sign           */

        if (exponent <= 0)                              /* handle underflow */
                retValue = 0;

    /*-------------------------------------------------------------------
     * Validate result and return it
     *-----------------------------------------------------------------*/

    HG_ASSERT (F_ISVALID(retValue));

    return retValue;
}

/*-------------------------------------------------------------------*//*!
 * \brief       Builds a float out of components, exponent is guaranteed
 *              to be in range
 * \param       signMask    Either 0 or 0x80000000 (=negative)
 * \param       exponent    Biased exponent [0,255]
 * \param       mantissa    23-bit mantissa (can contain hidden bit)
 * \return      IEEE floating-point value
 *//*-------------------------------------------------------------------*/

HG_INLINE HGifloat buildFloatUnchecked (
    HGuint32 signMask,
    int      exponent,
    HGuint32 mantissa)
{
    HGifloat retValue;

    HG_ASSERT (signMask == 0 || signMask == 0x80000000u);
    HG_ASSERT (mantissa < (1u<<24));
    HG_ASSERT (exponent >= 0 && exponent <= 255);

    /*-------------------------------------------------------------------
     * Pack the floating point value
     *-----------------------------------------------------------------*/

    retValue = signMask | (exponent << F_EXPONENT_SHIFT) | (mantissa & F_MANTISSA_MASK);                                    

    /*-------------------------------------------------------------------
     * Validate result and return it
     *-----------------------------------------------------------------*/

    HG_ASSERT (F_ISVALID(retValue));
        HG_ASSERT (F_FINITE(retValue));

    return retValue;
}


/*-------------------------------------------------------------------*//*!
 * \brief   Performs addition of two Floats
 * \param   a   Floating point value
 * \param   b   Floating point value
 * \return  a+b
 * \note    This function is bit-exact to x87 when rounding mode = CHOP
 *          and the FPU is in 24-bit precision.
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_ADD (
    HGifloat a, 
    HGifloat b)
{
#if 1
    HGuint32 sign, exponent, diffExponent, mantissa, bMantissa, overflow, diffSign;

    /*-------------------------------------------------------------------
     * DiffSign = 0x80000000 if a and b have different signs, 0 otherwise
     * Sign contains the sign mask of A.
     *-----------------------------------------------------------------*/

    HG_ASSERT (F_ISVALID(a) && F_ISVALID(b));

    diffSign = (a ^ b)  & F_SIGN_MASK;
    sign     = (a)      & F_SIGN_MASK;      

    /*-------------------------------------------------------------------
     * From now on we can operate using the absolute values of a and b.
     *-----------------------------------------------------------------*/

    a   = F_ABS(a);
    b   = F_ABS(b);

    /*-------------------------------------------------------------------
     * Sort a and b so that a >= b. Keep track of sign.
     *-----------------------------------------------------------------*/

    if (a <= b)         /* can make comparison as both are unsigned */
    {
        HGifloat tmp;
        tmp     = a;
        a       = b;
        b       = tmp;
        sign    ^= diffSign;

        /*--------------------------------------------------------------
         * If we're performing the subtraction (a-a), we need to early-exit
         * here
         *------------------------------------------------------------*/

        if (a == b && diffSign)
            return F_ZERO;
    }

    /*-------------------------------------------------------------------
     * If smaller component is zero or denormal, just return the
     * larger component.
     *-----------------------------------------------------------------*/

    if (b < F_FLOAT_MIN)    
        return a ^ sign;

    /*-------------------------------------------------------------------
     * Compute difference in exponents and clamp the value to 31.
     * Note: if diffExponent > 24 we could early-exit (see if this
     * is a good idea).
     *-----------------------------------------------------------------*/
    
    exponent        = a >> F_EXPONENT_SHIFT;                    
    diffExponent    = exponent - (b >> F_EXPONENT_SHIFT);

    if (diffExponent > 31u)
                diffExponent = 31;
        /*      return (a + (diffSign>>31)) ^ sign; */

    /*-------------------------------------------------------------------
     * Extract mantissas and align them
     *-----------------------------------------------------------------*/

    mantissa  = extractMantissa(a) << 7;
    bMantissa = extractMantissa(b) << 7;

    /*-------------------------------------------------------------------
     * Normalize mantissa (we have two separate cases here).
     *-----------------------------------------------------------------*/

    if (diffSign)               
    {
        /*-------------------------------------------------------------------
         * To maintain the rules of chop-rounding, we need to detect if
         * carry occurs in the shift. In assembler this would be a single
         * conditional addition.
         *-----------------------------------------------------------------*/

        HGuint32 oldBMantissa = bMantissa;
        bMantissa >>= diffExponent;
        if ((bMantissa << diffExponent) != oldBMantissa)
            bMantissa++;

        mantissa    -=  bMantissa;

        /* todo: for vast majority of cases, overflow is zero.. could we
           make the hgClz32 operation conditional altogether -- would
           save cycles in the average case 
        */

        overflow    =   (HGuint32)(hgClz32(mantissa) - 1);
        exponent    -=  overflow;
        mantissa    <<= overflow;
    } else                      
    {
        bMantissa >>= diffExponent;
        mantissa    +=  bMantissa;
        overflow    =   mantissa >> 31;                                     
        exponent    +=  overflow;
        mantissa    >>= overflow;
    }

    /*-------------------------------------------------------------------
     * Construct the final floating point value (handle underflows,
     * overflows etc.)
     *-----------------------------------------------------------------*/

    return buildFloat (sign, (HGint32)exponent, mantissa >> 7);
#else
    HGint32 mantissa, exponent, sign, overflow;

    /*-------------------------------------------------------------------
     * Find the largest exponent
     *-----------------------------------------------------------------*/

    exponent = maxu(a << 1,b << 1) >> 24; 

    /*-------------------------------------------------------------------
     * Extract mantissas, convert them into signed format, handle
     * zero cases and shift the mantissas, then sum them together.
     *-----------------------------------------------------------------*/
        
    mantissa =  floatAlignMantissa (a, exponent, 29) +
                floatAlignMantissa (b, exponent, 29);


    sign     = mantissa & F_SIGN_MASK;

        if (sign)                                                                                                  /* absolute value    */
                mantissa = -mantissa;   

    /*-------------------------------------------------------------------
     * Update the exponent and normalize the mantissa.
     *-----------------------------------------------------------------*/

    overflow    = hgClz32(mantissa);
    exponent    += 2 - overflow;
    mantissa  <<= overflow;

    if (mantissa == 0)                                                                             /* zero                              */
        exponent = 0;

    /*-------------------------------------------------------------------
     * Construct the final float and return.
     *-----------------------------------------------------------------*/

    return buildFloat (sign, exponent, (HGuint32)(mantissa) >> 8);


#endif
}

/*-------------------------------------------------------------------*//*!
 * \brief   Adds four floats together
 * \param   a   Floating point value
 * \param   b   Floating point value
 * \param   c   Floating point value
 * \param   d   Floating point value
 * \return  (a+b+c+d)
 * \note    The resulting value is not necessarily the same as
 *          computing (a+b)+(b+c).
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_ADD4 (
    HGifloat a, 
    HGifloat b,
    HGifloat c,
    HGifloat d)
{
    HGint32 mantissa, exponent, sign, overflow;

    /*-------------------------------------------------------------------
     * Find the largest exponent
     *-----------------------------------------------------------------*/

    exponent = (HGint32)(maxu(maxu(a << 1,b << 1),maxu(c << 1,d << 1)) >> 24); 

    /*-------------------------------------------------------------------
     * Extract mantissas, convert them into signed format, handle
     * zero cases and shift the mantissas, then sum them together. We
     * set the hidden bits to position 28, as this is the largest value
     * we can use without having to worry about overflows.
     *-----------------------------------------------------------------*/
        
    mantissa =  floatAlignMantissa (a, exponent, 28) +
                floatAlignMantissa (b, exponent, 28) +
                floatAlignMantissa (c, exponent, 28) +
                floatAlignMantissa (d, exponent, 28);

    sign     = (HGint32)(mantissa & F_SIGN_MASK);

    /*-------------------------------------------------------------------
     * If the output of the addition is zero, we should exit here.
     *-----------------------------------------------------------------*/

    if (mantissa == 0)
        return F_ZERO;

    /*-------------------------------------------------------------------
     * Update the exponent and normalize the mantissa.
     *-----------------------------------------------------------------*/

    mantissa    = hgAbs32(mantissa);
    overflow    = hgClz32((HGuint32)mantissa);
    mantissa  <<= overflow;
    exponent    += 3 - overflow;

    /*-------------------------------------------------------------------
     * Construct the final float and return.
     * \todo: do we want to have some special rounding rules here?
     *-----------------------------------------------------------------*/

    return buildFloat ((HGuint32)sign, exponent, (HGuint32)(mantissa) >> 8);
}

/*-------------------------------------------------------------------*//*!
 * \brief   Adds three floats together
 * \param   a   Floating point value
 * \param   b   Floating point value
 * \param   c   Floating point value
 * \return  (a+b+c)
 * \note    The resulting value is not necessarily the same as
 *          computing (a+b)+c.
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_ADD3 (
    HGifloat a, 
    HGifloat b,
    HGifloat c)
{
    HGint32 mantissa, exponent, sign, overflow;

    /*-------------------------------------------------------------------
     * Find the largest exponent
     *-----------------------------------------------------------------*/

    exponent = (HGint32)(maxu(maxu(a << 1,b << 1),(c << 1)) >> 24); 

    /*-------------------------------------------------------------------
     * Extract mantissas, convert them into signed format, handle
     * zero cases and shift the mantissas, then sum them together. We
     * set the hidden bits to position 28, as this is the largest value
     * we can use without having to worry about overflows.
     *-----------------------------------------------------------------*/
        
    mantissa =  floatAlignMantissa (a, exponent, 28) +
                floatAlignMantissa (b, exponent, 28) +
                floatAlignMantissa (c, exponent, 28);

    sign     = (HGint32)(mantissa & F_SIGN_MASK);

    /*-------------------------------------------------------------------
     * If the output of the addition is zero, we should exit here.
     *-----------------------------------------------------------------*/

    if (mantissa == 0)
        return F_ZERO;

    /*-------------------------------------------------------------------
     * Update the exponent and normalize the mantissa.
     *-----------------------------------------------------------------*/

    mantissa    = hgAbs32(mantissa);
    overflow    = hgClz32((HGuint32)mantissa);
    mantissa  <<= overflow;
    exponent    += 3 - overflow;

    /*-------------------------------------------------------------------
     * Construct the final float and return.
     * \todo: do we want to have some special rounding rules here?
     *-----------------------------------------------------------------*/

    return buildFloat ((HGuint32)sign, exponent, (HGuint32)(mantissa) >> 8);
}

/*-------------------------------------------------------------------*//*!
 * \brief   Takes absolute values of four floats and adds them together
 * \param   a   Floating point value
 * \param   b   Floating point value
 * \param   c   Floating point value
 * \param   d   Floating point value
 * \return  fabs(a) + fabs(b) + fabs(c) + fabs(d)
 * \note    This function is somewhat faster than F_ADD4, and is useful
 *          in operations such as normalization etc.
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_ADDABS4 (
    HGifloat a, 
    HGifloat b,
    HGifloat c,
    HGifloat d)
{
    HGint32     exponent, overflow;
    HGuint32    mantissa;

    /*-------------------------------------------------------------------
     * Get rid of signs and find largest exponent
     *-----------------------------------------------------------------*/

    a           = F_ABS(a);
    b           = F_ABS(b);
    exponent    = (HGint32)maxu(a,b);
    c           = F_ABS(c);
    exponent    = (HGint32)maxu ((HGuint32)exponent,c);
    d           = F_ABS(d);
    exponent    = (HGint32)maxu ((HGuint32)exponent, d);
    exponent  >>= F_EXPONENT_SHIFT; 

    /*-------------------------------------------------------------------
     * Extract mantissas, convert them into fixed-point, handle
     * zero cases and shift the mantissas, then sum them together. We
     * set the hidden bits to position 29, as this is the largest value
     * we can use without having to worry about overflows.
     *-----------------------------------------------------------------*/
        
    mantissa =  floatAlignMantissaUnsigned (a, exponent, 29) +
                floatAlignMantissaUnsigned (b, exponent, 29) +
                floatAlignMantissaUnsigned (c, exponent, 29) +
                floatAlignMantissaUnsigned (d, exponent, 29);

    /*-------------------------------------------------------------------
     * Update the exponent and normalize the mantissa. The pack the
     * float. The normalization doesn't require a clz as we can just
     * test for the 
     *-----------------------------------------------------------------*/

    overflow    =   1 - (mantissa >> 31);
    exponent    -=  overflow;
    mantissa    <<= overflow;
    overflow    =   2 - (mantissa >> 31);               /* note 2 so that we shift away the hidden bit */
    exponent    -=  overflow;
    mantissa    <<= overflow;                           /* NB: cannot combine shifts as we use this shift to get rid of the hidden bit */
    mantissa    >>= 9;
    exponent    +=  3;
    mantissa    |=  exponent << F_EXPONENT_SHIFT;
    exponent--;

    if ((HGuint32)exponent >= 254u)                      /* handles both overflows and zeros */
        mantissa = F_FLOAT_MAX & ~((HGint32)(exponent) >> 31);

    return mantissa;
}

/*-------------------------------------------------------------------*//*!
 * \brief   Takes absolute values of three floats and adds them together
 * \param   a   Floating point value
 * \param   b   Floating point value
 * \param   c   Floating point value
 * \return  fabs(a) + fabs(b) + fabs(c)
 * \note    This function is somewhat faster than F_ADD3, and is useful
 *          in operations such as normalization etc.
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_ADDABS3 (
    HGifloat a, 
    HGifloat b,
    HGifloat c)
{
    HGint32     exponent, overflow;
    HGuint32    mantissa;

    /*-------------------------------------------------------------------
     * Get rid of signs and find largest exponent
     *-----------------------------------------------------------------*/

    a           = F_ABS(a);
    b           = F_ABS(b);
    exponent    = (HGint32)maxu(a,b);
    c           = F_ABS(c);
    exponent    = (HGint32)maxu ((HGuint32)exponent,c);
    exponent  >>= F_EXPONENT_SHIFT; 

    /*-------------------------------------------------------------------
     * Extract mantissas, convert them into fixed-point, handle
     * zero cases and shift the mantissas, then sum them together. We
     * set the hidden bits to position 29, as this is the largest value
     * we can use without having to worry about overflows.
     *-----------------------------------------------------------------*/
        
    mantissa =  floatAlignMantissaUnsigned (a, exponent, 29) +
                floatAlignMantissaUnsigned (b, exponent, 29) +
                floatAlignMantissaUnsigned (c, exponent, 29);

    /*-------------------------------------------------------------------
     * Update the exponent and normalize the mantissa. The pack the
     * float. The normalization doesn't require a clz as we can just
     * test for the 
     *-----------------------------------------------------------------*/

    overflow    =   1 - (mantissa >> 31);
    exponent    -=  overflow;
    mantissa    <<= overflow;
    overflow    =   2 - (mantissa >> 31);               /* note 2 so that we shift away the hidden bit */
    exponent    -=  overflow;
    mantissa    <<= overflow;                           /* NB: cannot combine shifts as we use this shift to get rid of the hidden bit */
    mantissa    >>= 9;
    exponent    +=  3;
    mantissa    |=  exponent << F_EXPONENT_SHIFT;
    exponent--;

    if ((HGuint32)exponent >= 254u)                      /* handles both overflows and zeros */
        mantissa = F_FLOAT_MAX & ~((HGint32)(exponent) >> 31);

    return mantissa;
}

/*-------------------------------------------------------------------*//*!
 * \brief   Performs multiplication of a float and an integer
 * \param   a   Floating point value
 * \param   b   Signed integer value
 * \return  a*b
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_IMUL (
    HGifloat a, 
    HGint32  b)
{
    HGuint32    signMask;
        HGuint64        mantissa;
        HGint32         overflow;
    HGint32             mantissa32;
        int         exponent;

        HG_ASSERT(F_ISVALID(a));

    /*-------------------------------------------------------------------
     * Compute sign of the result. Then take absolute values of the
     * arguments and early-exit if either argument is zero.
     *-----------------------------------------------------------------*/

    signMask = (a ^ b) & F_SIGN_MASK;       

    a = F_ABS(a);                           
    b = hgAbs32(b);

    if (a == F_ZERO || b == F_ZERO)
        return F_ZERO;

    /*-------------------------------------------------------------------
     * Compute new mantissa and exponent.
     *-----------------------------------------------------------------*/

    mantissa    = hgMulu64(extractMantissa(a) << 8, (HGuint32)b);
    overflow    = hgClz64(hgToSigned64(mantissa));
    exponent    = (HGint32)(a >> F_EXPONENT_SHIFT) + 32 - overflow;
        mantissa32      = (HGuint32)(hgLsl64h(hgToSigned64(mantissa),overflow)) >> 8;

        if (exponent >= 255)
                return F_FLOAT_MAX | signMask;

    return buildFloatUnchecked (signMask, exponent, mantissa32);
}

/*-------------------------------------------------------------------*//*!
 * \brief   Performs multiplication of two Floats
 * \param   a   Floating point value
 * \param   b   Floating point value
 * \return  a*b
 * \todo    [wili 17/Oct/04] Doesn't propagate infinities properly
 * \note    Exactly the same as x87 multiply op in CHOP mode
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_MUL (
    HGifloat a, 
    HGifloat b)
{
#if 1

        /* the code below causes zero load/store spills or branches in ARM code */
    
        HGuint32    signMask, mantissa;
    int         exponent;

    HG_ASSERT (F_ISVALID(a) && F_ISVALID(b));

        signMask = a ^ b;                                                                                                       /* bit 31 contains sign of result       */
        mantissa = hgMulu64h((a << 8) | (1u << 31), (b << 8) | (1u << 31));     /* multiply mantissas                           */

        exponent = (HGint32)((a+a) >> 24);                                              /* exponent of a */
                                                                                                                        
        if (exponent == 0)                                                                              /* multiplication by 0 -- force exponent to negative */
                exponent = -256;

        b <<= 1;                                                                                                /* remove sign */

        if (b)                                                                                                  /* if non-zero, add exponent to sum                             */
                exponent += (b >> 24);
        else                                                                                                    /* .. if zero, force exponent to be negative    */
                exponent -= 256;

        exponent -= (F_EXPONENT_BIAS + 1);                                              /* apply exponent bias          */
        exponent += (HGint32)(mantissa >> 31);                                  /* apply mantissa overflow      */

        /*todo: if we want an early exit for exponent <= 0 (handles zero multiply cases), we should have it here */

        mantissa <<= (2 - (mantissa >> 31));                                    /* remove hidden bit and shift mantissa into place */
        mantissa >>= 9;                                                                                 
        mantissa  |= (exponent << F_EXPONENT_SHIFT);                    /* combine mantissa and exponent */
                                                                                                                        
        if (exponent >= 255)                                                                    /* handle overflow                               */
                mantissa  = F_FLOAT_MAX;                                                        
                                                                                                                        
        mantissa  |= (signMask & F_SIGN_MASK);                                  /* apply sign                                   */      
                                                                                                                        
        if (exponent <= 0)                                                                              /* underflow                                    */
                mantissa = F_ZERO;

    HG_ASSERT (F_ISVALID(mantissa));                                            /* validate result                              */

        return mantissa;                                                                                /* we're done                                   */

#endif

    /* this version handles denormals properly, but needs to be optimized */
#if 0
    HGuint32    signMask, overflow, aMantissa, bMantissa;
    int         aExponent, bExponent;

    HG_ASSERT(F_ISVALID(a) && F_ISVALID(b));

    /*-------------------------------------------------------------------
     * Compute sign of the result. Then take absolute values of the
     * arguments and early-exit if either argument is zero.
     *-----------------------------------------------------------------*/

    signMask = (a ^ b) & F_SIGN_MASK;       

    a = F_ABS(a);                           
    b = F_ABS(b);

    if (a < b)
    {
        HGifloat tmp = a;
        a = b;
        b = tmp;
    }

    if (b == F_ZERO)                                /* smaller is zero */
        return F_ZERO;

    aExponent = (a >> F_EXPONENT_SHIFT);

    if (aExponent == 0)                             /* larger is denormal */
        return F_ZERO;

    aMantissa = extractMantissa(a);
    bExponent = (b >> F_EXPONENT_SHIFT);
    aExponent += bExponent;
    bMantissa = extractMantissa(b);

    if (bExponent == 0)
    {
        HGint32 shiftLeft = hgClz32(b) - 8;

        bMantissa  = b << shiftLeft;
        aExponent -= (shiftLeft-1);
    } 


    /*-------------------------------------------------------------------
     * Compute new mantissa and exponent. Check for overflow.
     *-----------------------------------------------------------------*/

    aMantissa = hgMulu64h(aMantissa << 1, bMantissa << 8);
    overflow  = aMantissa >> 24;        
    
    aMantissa >>= overflow;

    HG_ASSERT (overflow >= 0 && overflow <= 1);
    
    /*-------------------------------------------------------------------
     * Construct output floating point value
     *-----------------------------------------------------------------*/

    return buildFloat (signMask, aExponent - F_EXPONENT_BIAS + overflow - 1, aMantissa);
#endif
}

#define FIND_MAX_EXPONENT(a,b,first)                                                                            \
                {                                                                                                                                       \
                        HGint32 t0, t1;                                                                                                 \
                        t0 = (HGint32)((a+a)>>24); if (t0 == 0) t0 = -256;                              \
                        t1 = (HGint32)((b+b)>>24); if (t1 == 0) t1 = -256;                              \
                        t0+=t1;                                                                                                                 \
                        exponent = (first) ? t0 : hgMax32(exponent, t0);                                \
                }

/*-------------------------------------------------------------------*//*!
 * \brief   Computes 4-component dot product (low-precision variant)
 * \param   a   Floating point value
 * \param   b   Floating point value
 * \param   c   Floating point value
 * \param   d   Floating point value
 * \param   e   Floating point value
 * \param   f   Floating point value
 * \param   g   Floating point value
 * \param   h   Floating point value
 * \return  a*b + c*d + e*f + g*h
 * \note        The operation is done internally by scaling the results
 *                      of all multiplications to operate in the same 32-bit integer
 *                      range, and to perform the additions there.
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_DOT4 (
        HGifloat a, 
        HGifloat b, 
        HGifloat c, 
        HGifloat d, 
        HGifloat e, 
        HGifloat f, 
        HGifloat g, 
        HGifloat h)
{
    /*-------------------------------------------------------------------
     * Macros for performing actual operations.
         *-----------------------------------------------------------------*/

#define MULTIPLYALIGN_32(a,b,first)                                                                                     \
        {                                                                                                                                               \
                HGuint32 e0 = (a << 1) >> 24;                                                                           \
                if (e0)                                                                                                                         \
                {                                                                                                                                       \
                        HGuint32 e1 = (b << 1) >> 24;                                                                   \
                        if (e1)                                                                                                                 \
                        {                                                                                                                               \
                                HGint32 sh = exponent - (e0 + e1) + 3;                                          \
                                if (sh <= 31)                                                                                           \
                                {                                                                                                                       \
                                        HGint32 m;                                                                                              \
                                        e0               = (a << 8) | (1u << 31);                                               \
                                        e1               = (b << 8) | (1u << 31);                                               \
                                        m        = (HGint32)(hgMulu64h(e0, e1) >> sh);                  \
                                        if ((HGint32)(a^b) < 0)                                                                 \
                                                mantissa32 -= m;                                                                        \
                                        else                                                                                                    \
                                                mantissa32 += m;                                                                        \
                                }                                                                                                                       \
                        }                                                                                                                               \
                }                                                                                                                                       \
        }                               

    /*-------------------------------------------------------------------
         * Find maximum exponent of the individual multiplications. Note 
         * that zeroes are treated by setting them to have an exponent of
         * -256 (this way we don't need unnecessary conditional branching).
     *-----------------------------------------------------------------*/

        HGint32 exponent = 0;

        FIND_MAX_EXPONENT(a,b,1)
        FIND_MAX_EXPONENT(c,d,0)
        FIND_MAX_EXPONENT(e,f,0)
        FIND_MAX_EXPONENT(g,h,0)

    /*-------------------------------------------------------------------
     * If the largest exponent is so small that the result will undeflow,
         * let's exit at this point.
     *-----------------------------------------------------------------*/


        if (exponent > F_EXPONENT_BIAS) 
        {
                /*----------------------------------------------------------------
                 * Perform multiplications of the mantissas, generate 32-bit results 
                 * and align them (so that the value with the largest exponent has
                 * its hidden bit as position 1<<30). The mantissas are then summed
                 * to form a signed 32-bit output mantissa.
                 *--------------------------------------------------------------*/
                
                HGuint32        sign;
                HGint32         shift;
                HGint32         mantissa32 = 0;

                MULTIPLYALIGN_32(a,b,1)
                MULTIPLYALIGN_32(c,d,0)
                MULTIPLYALIGN_32(e,f,0)
                MULTIPLYALIGN_32(g,h,0)

                if (mantissa32 == 0)
                        return F_ZERO;

                /*----------------------------------------------------------------
                 * Figure out sign and find out how much exponent has changed. Also,
                 * align mantissa to final proper place.
                 *--------------------------------------------------------------*/

                sign            = mantissa32 & F_SIGN_MASK;                             /* sign of result                                       */
                mantissa32  = hgAbs32(mantissa32);                                      /* convert back to unsigned format      */
                shift       = hgClz32(mantissa32);                                      /* find proper shift value                      */
                exponent   -= (shift + F_EXPONENT_BIAS - 3);

                if (exponent <= 0)                                                                      /* underflow    */
                        return F_ZERO;

                if (exponent >= 255)                                                            /* overflow             */
                        return F_FLOAT_MAX | sign;                                                              

                return sign | (HGuint32)(exponent << F_EXPONENT_SHIFT) | ((((HGuint32)(mantissa32) << shift) << 1) >> 9);                       
        }

        return F_ZERO;

#undef MULTIPLYALIGN_32
}

/*-------------------------------------------------------------------*//*!
 * \brief   Computes 4-component dot product (high-precision variant)
 * \param   a   Floating point value
 * \param   b   Floating point value
 * \param   c   Floating point value
 * \param   d   Floating point value
 * \param   e   Floating point value
 * \param   f   Floating point value
 * \param   g   Floating point value
 * \param   h   Floating point value
 * \return  a*b + c*d + e*f + g*h
 * \note        The operation is done internally by scaling the results
 *                      of all multiplications to operate in the same 64-bit integer
 *                      range, and to perform the additions there.
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_DOT4HI (
        HGifloat a, 
        HGifloat b, 
        HGifloat c, 
        HGifloat d, 
        HGifloat e, 
        HGifloat f, 
        HGifloat g, 
        HGifloat h)
{
    /*-------------------------------------------------------------------
     * Macros for performing actual operations.
         *-----------------------------------------------------------------*/


#define MULTIPLYALIGN_64(a,b,first)                                                                                     \
        {                                                                                                                                               \
                HGint32 e0 = (a << 1) >> 24;                                                                            \
                if (e0)                                                                                                                         \
                {                                                                                                                                       \
                        HGint32 e1 = (b << 1) >> 24;                                                                    \
                        if (e1)                                                                                                                 \
                        {                                                                                                                               \
                                HGint32 sh = exponent - (e0 + e1);                                                      \
                                if (sh <= 63)                                                                                           \
                                {                                                                                                                       \
                                        HGint64 m;                                                                                              \
                                        e0               = (HGint32)(((a << 8) | (1u << 31)) >> 1);             \
                                        if ((HGint32)(a^b) < 0)                                                                 \
                                                e0 = -e0;                                                                                       \
                                        e1               = (HGint32)(((b << 8)| ( 1u << 31)) >> 2);             \
                                        m        = hgAsr64(hgMul64(e0, e1), sh);                                \
                                        mantissa64 = first ? m : hgAdd64(mantissa64, m);                \
                                }                                                                                                                       \
                        }                                                                                                                               \
                }                                                                                                                                       \
        }                               

    /*-------------------------------------------------------------------
         * Find maximum exponent of the individual multiplications. Note 
         * that zeroes are treated by setting them to have an exponent of
         * -256 (this way we don't need unnecessary conditional branching).
     *-----------------------------------------------------------------*/

        HGint32 exponent = 0;

        FIND_MAX_EXPONENT(a,b,1)
        FIND_MAX_EXPONENT(c,d,0)
        FIND_MAX_EXPONENT(e,f,0)
        FIND_MAX_EXPONENT(g,h,0)

    /*-------------------------------------------------------------------
     * If the largest exponent is so small that the result will undeflow,
         * let's exit at this point.
     *-----------------------------------------------------------------*/


        if (exponent > F_EXPONENT_BIAS) 
        {
                /*----------------------------------------------------------------
                 * Perform multiplications of the mantissas, generate 64-bit results 
                 * and align them (so that the value with the largest exponent has
                 * its hidden bit as position 1<<62). The mantissas are then summed
                 * to form a signed 64-bit output mantissa.
                 *--------------------------------------------------------------*/
                
                HGuint32        sign;
                HGint32         shift;
                HGint64         mantissa64 = hgZero64();

                MULTIPLYALIGN_64(a,b,1)
                MULTIPLYALIGN_64(c,d,0)
                MULTIPLYALIGN_64(e,f,0)
                MULTIPLYALIGN_64(g,h,0)

                if (hgIsZero64(mantissa64))                                                                                     /* result is zero? */
                        return F_ZERO;

                /*----------------------------------------------------------------
                 * Figure out sign and find out how much exponent has changed. Also,
                 * align mantissa to final proper place.
                 *--------------------------------------------------------------*/

                sign            = hgGet64h(mantissa64) & F_SIGN_MASK;   /* sign of result                                       */
                mantissa64  = hgAbs64(mantissa64);                                      /* convert back to unsigned format      */
                shift       = hgClz64(mantissa64);                                      /* find proper shift value                      */
                exponent   -= (shift + F_EXPONENT_BIAS - 3);

                if (exponent <= 0)                                                                      /* underflow    */
                        return F_ZERO;

                if (exponent >= 255)                                                            /* overflow             */
                        return F_FLOAT_MAX | sign;                                                              

                return sign | (HGuint32)(exponent << F_EXPONENT_SHIFT) | (((HGuint32)hgLsl64h(mantissa64, shift) << 1) >> 9);                   
        }

        return F_ZERO;

#undef MULTIPLYALIGN_64
}

#undef FIND_MAX_EXPONENT

/*-------------------------------------------------------------------*//*!
 * \brief   Computes a*b+c
 * \param   a   Floating point value
 * \param   b   Floating point value
 * \param   c   Floating point value
 * \return  a*b+c
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_MADD (
    HGifloat a, 
    HGifloat b, 
    HGifloat c) 
{ 
    HGuint32    diffExponent, cMantissa, mantissa, overflow, sign, diffSign;
    int         exponent;

    HG_ASSERT(F_ISVALID(a) && F_ISVALID(b) && F_ISVALID(c));

    /*-------------------------------------------------------------------
         * Setup signs and early-exit if either 'a' or 'b' is zero
     *-----------------------------------------------------------------*/

    sign        = (a ^ b)       & F_SIGN_MASK;      
    diffSign    = (sign ^ c)    & F_SIGN_MASK;
    a           = F_ABS(a);                         
    b           = F_ABS(b);

    if (a == F_ZERO || b == F_ZERO)                             
        return c;

    /*-------------------------------------------------------------------
         * Perform multiplication of 'a' and 'b'
     *-----------------------------------------------------------------*/

    mantissa   = hgMulu64h(extractMantissa(a) << 1, extractMantissa(b) << 8);
    overflow   = mantissa >> 24;                        
    exponent   = (HGint32)((a >> F_EXPONENT_SHIFT ) + (b >> F_EXPONENT_SHIFT) - F_EXPONENT_BIAS + overflow - 1);                                       

    if (exponent <= 0)
        return c;

    mantissa = (mantissa >> overflow) & F_MANTISSA_MASK;

    a = (HGifloat)((exponent << F_EXPONENT_SHIFT) | mantissa);                                  

    if (exponent >= 255)
        /*      return F_FLOAT_MAX | sign; */
                a = F_FLOAT_MAX;

    /*-------------------------------------------------------------------
         * Perform addition
     *-----------------------------------------------------------------*/

    c = F_ABS(c);

    if (c < F_FLOAT_MIN)    
        return a ^ sign;

    if (a == c && diffSign)
        return F_ZERO;

    if (a < c)          
    {
        HGifloat tmp;
        tmp     = a;
        a       = c;
        c       = tmp;
        sign    ^= diffSign;
    }

    exponent        = (HGint32)(a >> F_EXPONENT_SHIFT);                    
    diffExponent    = (HGuint32)(exponent - (c >> F_EXPONENT_SHIFT));

    if (diffExponent > 31u)
        diffExponent = 31u;

    mantissa  = extractMantissa(a) << 7;
    cMantissa = extractMantissa(c) << 7;

    if (diffSign)               
    {
        HGuint32 oldcMantissa = cMantissa;
        cMantissa >>= diffExponent;
        if ((cMantissa << diffExponent) != oldcMantissa)
            cMantissa++;

        mantissa    -=  cMantissa;

        overflow    =   (HGuint32)(hgClz32(mantissa) - 1);  /* todo: early exit before clz if overflow = 0 ? */
        exponent    -=  overflow;
        mantissa    <<= overflow;
    } else                      
    {
        cMantissa >>= diffExponent;
        mantissa    +=  cMantissa;
        overflow    =   mantissa >> 31;                                     
        exponent    +=  overflow;
        mantissa    >>= overflow;
    }

    return buildFloat (sign, exponent, mantissa >> 7);
}

/*-------------------------------------------------------------------*//*!
 * \brief   Performs a*a
 * \param   a   Floating point value
 * \return  a*a
 * \note    This is somewhat faster than calling F_MUL(a,a)
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_SQR (
    HGifloat a)
{
        HGuint32    mantissa;
    int         exponent;

    HG_ASSERT (F_ISVALID(a));

        mantissa  = hgMulu64h((a << 8) | (1u << 31), (a << 8) | (1u << 31));    /* multiply mantissas                           */
        exponent  = (HGint32)((a+a) >> 23) & ~1;                                /* exponent of a                        */
        exponent -= (F_EXPONENT_BIAS + 1);                                              /* apply exponent bias          */
        exponent += (HGint32)(mantissa >> 31);                                  /* apply mantissa overflow      */
                
        mantissa <<= (2 - (mantissa >> 31));                                    /* remove hidden bit and shift mantissa into place */
        mantissa >>= 9;                                                                                 

        if (exponent <= 0)
        {
                mantissa = F_ZERO;
                exponent = 0;
        }
        
        mantissa  |= (exponent << F_EXPONENT_SHIFT);                    /* combine mantissa and exponent */
        
        if (exponent >= 255)                                                                    /* handle overflow                               */
                mantissa  = F_FLOAT_MAX;                                                        
                                                                                                                                                                                                                                                

    HG_ASSERT (F_ISVALID(mantissa));                                            /* validate result                              */

        return mantissa;                                                                                /* we're done                                   */
}

/*-------------------------------------------------------------------*//*!
 * \brief   Converts 32-bit integer into a floating-point value and
 *                      scales the output value by 2^shift
 * \param   a           Integer
 * \param       shift   Shift value (may be negative, whole integer range
 *                                      is supported)
 * \return  float(x * pow(2.0f, shift))
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_ITOFSCALE (
        HGint32 x, 
        HGint32 sh)
{
        HGuint32 sign = (HGuint32)(x) & F_SIGN_MASK;
        HGuint32 mantissa;
        HGint32  exponent;

    if (x == 0)
                return F_ZERO;
        
        if (sh >= 255)                                                  /* needs to be done because theoretically 'sh' can be close to 2^31 */
                return F_FLOAT_MAX | sign;
    
        mantissa = (HGuint32)hgAbs32(x);
        exponent = 8-hgClz32(mantissa);
        mantissa = lsrSigned (mantissa, exponent);

        return buildFloat (sign, exponent + F_EXPONENT_BIAS + 24 + sh, mantissa);
}

/*-------------------------------------------------------------------*//*!
 * \brief   Converts 64-bit integer into a floating-point value and
 *                      scales the output value by 2^shift
 * \param   a           Integer
 * \param       shift   Shift value (may be negative, whole integer range
 *                                      is supported)
 * \return  float(x * pow(2.0f, shift))
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_I64TOFSCALE (
        HGint64 x, 
        HGint32 sh)
{
        HGuint32 sign = (HGuint32)(hgGet64h(x)) & F_SIGN_MASK;
        HGint64 mantissa;
        HGint32  exponent;
        HGuint32 m32;

    if(hgIsZero64(x))
                return F_ZERO;
        
        if(sh >= 255)                                                   /* needs to be done because theoretically 'sh' can be close to 2^31 */
                return F_FLOAT_MAX | sign;
    
        mantissa = hgAbs64(x);
        exponent = 8-hgClz64(mantissa);

        if(exponent >= 0)
                m32 = (HGuint32)hgGet64h(mantissa) >> exponent;
        else
                m32 = (HGuint32)hgLsl64h(mantissa, -exponent);

        return buildFloat (sign, exponent + F_EXPONENT_BIAS + 56 + sh, m32);
}

/*-------------------------------------------------------------------*//*!
 * \brief   Converts 32-bit unsigned integer into a floating-point value and
 *                      scales the output value by 2^shift
 * \param   a           Unsigned integer
 * \param       shift   Shift value (may be negative, whole integer range
 *                                      is supported)
 * \return  float(x * pow(2.0f, shift))
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_UTOFSCALE (
        HGuint32 x, 
        HGint32  sh)
{
        HGuint32 mantissa;
        HGint32  exponent;

    if (x == 0)
                return F_ZERO;
        
        if (sh >= 255)                                                  /* needs to be done because theoretically 'sh' can be close to 2^31 */
                return F_FLOAT_MAX;
    
        mantissa = x;
        exponent = 8-hgClz32(mantissa);
        mantissa = lsrSigned (mantissa, exponent);

        return buildFloat (0, exponent + F_EXPONENT_BIAS + 24 + sh, mantissa);
}

/*-------------------------------------------------------------------*//*!
 * \brief   Converts 32-bit integer into a floating-point value
 * \param   a   Integer
 * \return  float(a)
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_ITOF (HGint32 x)
{
    HGifloat res;
    HGuint32 sign = (HGuint32)(x) & F_SIGN_MASK;
    HGuint32 mantissa;
    HGint32  exponent;
    
    mantissa    = (HGuint32)hgAbs32(x);
    exponent    = 8-hgClz32(mantissa);
        mantissa        = lsrSigned (mantissa, exponent);
        exponent    += F_EXPONENT_BIAS + 24;

    res = buildFloatUnchecked (sign, exponent, mantissa);

    if (exponent == F_EXPONENT_BIAS)    
        res = F_ZERO;

    return res;
}

/*-------------------------------------------------------------------*//*!
 * \brief   Converts signed 16.16 fixed point into a floating-point value
 * \param   a   Integer
 * \return  float(a)
 * \note        This function has been deprecated -- don't use it!
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_FIXED2F   (HGint32 x)
{
    HGuint32 sign = (HGuint32)(x) & F_SIGN_MASK;
    HGuint32 mantissa;
    HGint32  exponent;
    
    mantissa    = (HGuint32)hgAbs32(x);
    exponent    = 8-hgClz32(mantissa);
        mantissa        = lsrSigned (mantissa, exponent);
    exponent += F_EXPONENT_BIAS + 24 - 16;

        if (exponent == (F_EXPONENT_BIAS - 16)) /* zero */
                exponent = 0;
        
    return buildFloatUnchecked (sign, exponent, mantissa);
}

/*-------------------------------------------------------------------*//*!
 * \brief   Converts 32-bit unsigned integer into a floating-point value
 * \param   a   Unsigned integer
 * \return  float(a)
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_UTOF (HGuint32 x)
{
    HGuint32 mantissa = x;
    HGint32  exponent = 8-hgClz32(mantissa);
    
        mantissa = lsrSigned (mantissa, exponent);
        exponent += F_EXPONENT_BIAS + 24;

        if (exponent == F_EXPONENT_BIAS)                /* zero */
                exponent = 0;
    
    return buildFloatUnchecked (0, exponent, mantissa);
}

/*-------------------------------------------------------------------*//*!
 * \brief       Clamp float to [0.0,1.0f] range then scale into [0.0f,255.0f]
 *                      and convert into integer
 * \param       a       Floating point value
 * \return      Floating-point value converted into unsigned byte, with
 *                      the formula y = (int)(255.0f * x + 0.501f)
 *//*-------------------------------------------------------------------*/

HGint32 F_CALL F_F2UBYTE (HGifloat a)
{
        HGint32  shift;

        if ((HGint32)(a) < ((F_EXPONENT_BIAS-8) << F_EXPONENT_SHIFT))
                return 0;

        if (a >= F_ONE)
                return 255;

        shift = F_EXPONENT_BIAS - extractBiasedExponent(a);
        a     = extractMantissa(a);

        HG_ASSERT (shift >= 0 && shift <= 31);  /* must be! */

        a = (a << 8) - a;                               /* multiply by 255                                              */
        a >>= shift;                                    /* align values                                                 */
        a  += 0x00804189u;                              /* add rounding fix (0.501f * (1<<24))  */
/*  a  += 0x00800000u; */                       /* rounding fix of 0.5f */
        a >>= 24;                                               /* scale down                                                   */

        return (HGint32)(a);
}

/*-------------------------------------------------------------------*//*!
 * \brief   Computes (int)(clamp(x * pow(2.0f,shift)))
 * \param   x       Floating point value
 * \param   shift   Shift value
 * \return  (int)(clamp(x * pow(2.0f,shift))))
 * \note    The function is used for converting floats into different
 *          fixed-point and integer types. The rounding mode is
 *          CHOP.
 * \note    The result is clamped into [0x80000000, 0x7fffffff] range
 *//*-------------------------------------------------------------------*/

HGint32 F_CALL F_ICHOPSCALE (
        HGifloat        x, 
        int                     shift)
{
    HGint32 exponent, mantissa, sign;

    exponent = extractBiasedExponent(x);

        if (exponent == 0)
                return 0;

    exponent   = (F_EXPONENT_BIAS + 31) - (exponent + shift);
    mantissa   = (HGint32)(extractMantissa(x) << 7); 
    sign       = (HGint32)(x) >> 31;

        if (exponent > 31)                                      /* NOTE: needs to be done even on modulo-256 systems */
                exponent = 31;

        mantissa >>= exponent;
    mantissa  += sign;                  /* begin apply sign */

    if (exponent < 0)                   /* clamp to [0x80000000,0x7fffffff] range   */
        mantissa = 0x7fffffff;

    mantissa ^= sign;                   /* rest of sign */

    return mantissa;
}

/*-------------------------------------------------------------------*//*!
 * \brief   Computes (int)(clamp(x * pow(2.0f,shift)))
 * \param   x       Floating point value
 * \param   shift   Shift value
 * \return  (HGint64)(clamp(x * pow(2.0f,shift))))
 * \note    The function is used for converting floats into different
 *          fixed-point and integer types. The rounding mode is
 *          CHOP.
 * \note    The result is clamped into [0x8000000000000000, 0x7fffffffffffffff] range
 *//*-------------------------------------------------------------------*/

HGint64 F_CALL F_I64CHOPSCALE (
        HGifloat        x, 
        int                     shift)
{
    HGint32 exponent;
        HGint64 mantissa, sign;

    exponent = extractBiasedExponent(x);

        if (exponent == 0)
                return hgZero64();

    exponent   = (F_EXPONENT_BIAS + 63) - (exponent + shift);
    mantissa   = hgSet64x((extractMantissa(x) << 7)); 
    sign       = hgSet64s((HGint32)(x) >> 31);

        if (exponent > 63)                                      /* NOTE: needs to be done even on modulo-256 systems */
                exponent = 63;

    if (exponent < 0)                   /* clamp to [0x80000000,0x7fffffff] range   */
    {
        mantissa = hgSet64(0x7fffffff, 0xffffffff);
    }
    else
    {
        mantissa = hgAsr64(mantissa, exponent);
        mantissa = hgAdd64(mantissa, sign);       /* begin apply sign */
    }

    mantissa = hgXor64(mantissa, sign);                   /* rest of sign */
    return mantissa;
}

/*-------------------------------------------------------------------*//*!
 * \brief   Computes (int)(chop(x))
 * \param   x       Floating point value
 * \return  (int)(chop(x))
 * \note    The result is clamped into [0x80000000, 0x7fffffff] range
 *//*-------------------------------------------------------------------*/

HGint32 F_CALL F_ICHOP (HGifloat x)
{
    HGint32 mantissa = (HGuint32)( (x << 8) | (1u << 31) ) >> 1;                /* get mantissa to place                                */
        HGint32 shift    = (31 + F_EXPONENT_BIAS) - extractBiasedExponent(x);           
                                                                                                                                                                                                                                                                                                                                                                                                                                                                
#if (HG_SHIFTER_MODULO < 256)                                                                                                                                                                   
        if (shift > 31)                                                                                                         /* values in range ]-1,+1[                              */
                shift = 31;
#endif

        mantissa  >>= shift;                                                                                            /* shift to place                                               */

        mantissa += (HGint32)(x) >> 31;                                                                         /* begin apply sign */

        if (shift < 0)                                                                                                          /* clamp result                                                 */
                mantissa = 0x7fffffff;                                                                                  /*  to either 0x7fffffff or 0x80000000  */

        mantissa ^= (HGint32)(x) >> 31;                                                                         /* end apply sign */

    return mantissa;
}

/*-------------------------------------------------------------------*//*!
 * \brief   Computes (int)(floor(x))
 * \param   x       Floating point value
 * \return  (int)(floor(x))
 * \note    The result is clamped into [0x80000000, 0x7fffffff] range
 *//*-------------------------------------------------------------------*/

HGint32 F_CALL F_IFLOOR (HGifloat x)
{
        HGint32 mantissa, shift, sign;

    mantissa = (HGuint32)( (x << 8) | (1u << 31) ) >> 1;                                /* get mantissa to place                                */
                                                                                                                                                                                                                                
        if (F_ZCMPLT(x))                                                                                                        /* x < 0.0f -> negate mantissa                  */
                mantissa = -mantissa;                                                                                                                                                                   
                                                                                                                                                                                                                                
        shift = extractBiasedExponent(x) - F_EXPONENT_BIAS;                                     /* shift                                                                */
        sign  = mantissa >> 31;                                                                                         /* get sign (0 or -1) from mantissa             */
                                                                                                                                                                                                                                
        if (mantissa << shift)                                                                                          /* non-integer negative values?                 */
                mantissa -= sign;                                                                                                                                                                               
                                                                                                                                                                                                                                
#if (HG_SHIFTER_MODULO < 256)                                                                                                                                                                   
        if (shift < 0)                                                                                                          /* values in range ]-1,+1[                              */
                shift = 0;
#endif

        shift           = 31 - shift;
        mantissa  >>= shift;                                                                                            /* shift to place                                               */

        if (shift < 0)                                                                                                          /* clamp result                                                 */
                mantissa = 0x7fffffff ^ sign;                                                                   /*  to either 0x7fffffff or 0x80000000  */

    return mantissa;
}

/*-------------------------------------------------------------------*//*!
 * \brief   Computes (int)(ceil(x))
 * \param   x       Floating point value
 * \return  (int)(ceil(x))
 * \note    The result is clamped into [0x80000000, 0x7fffffff] range
 *//*-------------------------------------------------------------------*/

HGint32 F_CALL F_ICEIL (HGifloat x)
{
        HGint32 mantissa, shift, sign;

    mantissa = (HGuint32)( (x << 8) | (1u << 31) ) >> 1;                                /* get mantissa to place                                */
                                                                                                                                                                                                                                
        if (F_ZCMPGT(x))                                                                                                        /* x > 0.0f -> negate mantissa                  */
                mantissa = -mantissa;                                                                                                                                                                   
                                                                                                                                                                                                                                
        shift = extractBiasedExponent(x) - F_EXPONENT_BIAS;                                     /* shift                                                                */
        sign  = mantissa >> 31;                                                                                         /* get sign (0 or -1) from mantissa             */
                                                                                                                                                                                                                                
        if (mantissa << shift)                                                                                          /* non-integer negative values?                 */
                mantissa -= sign;                                                                                                                                                                               
                                                                                                                                                                                                                                
#if (HG_SHIFTER_MODULO < 256)                                                                                                                                                                   
        if (shift < 0)                                                                                                          /* values in range ]-1,+1[                              */
                shift = 0;
#endif

        shift           = 31 - shift;
        mantissa  >>= shift;                                                                                            /* shift to place                                               */

        mantissa = -mantissa;

        if (shift < 0)                                                                                                          /* clamp result                                                 */
                mantissa = 0x80000000 ^ sign;                                                                   /*  to either 0x7fffffff or 0x80000000  */

    return mantissa;
}

/*-------------------------------------------------------------------*//*!
 * \brief   Multiplies floating-point value by 2^shift
 * \param   a       Floating point value
 * \param   shift   Shift value (can be negative)
 * \return  a * pow (2.0f, shift)
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_SHIFT (
    HGifloat    a, 
    int     shift)
{
        HGuint32 exponent = extractBiasedExponent(a) - 1;

        if (exponent < 254u)                                            /* not zero or infinite */
        {
                exponent += shift;                                              /* modify exponent */

                if (exponent >= 254u)                                   /* handle underflows and overflows */
                        a = (a | 0x7fffffffu) &~ ((1<<23) | (((HGint32)exponent) >> 31));
                else
                        a += (shift << F_EXPONENT_SHIFT);
        }

    return a;
}

/*-------------------------------------------------------------------*//*!
 * \brief   Clamps value to range [mn,mx]
 * \param   a       Floating point value
 * \param   mn      Range minimum
 * \param   mx      Range maximum
 * \return  Clamped value
 * \note    mn MUST BE <= mx (asserted in debug build)
 * \todo    [wili 17/Oct/04] Ensure that this works with INFs etc.
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_CLAMP (
    HGifloat a, 
    HGifloat mn, 
    HGifloat mx)
{
    HG_ASSERT (F_CMPLE(mn,mx));
    return F_MIN(F_MAX(a,mn),mx);
}

/*-------------------------------------------------------------------*//*!
 * \brief   Computes reciprocal of a float
 * \param   a   Floating point value
 * \return  1.0f / a
 * \note    The result of division by zero (i.e., a == 0.0f) is 
 *          undefined.
 * \todo        Enable new variant (use one iteration of Newton-Rahpson?)
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_RCP (HGifloat a)
{
#if 0
        HGint32                 exponent    = 0xFE - extractBiasedExponent(a);
        HGuint32                sign        = a & F_SIGN_MASK;
    HGint32                     x;

        x = a & F_MANTISSA_MASK;

        if (x)
        {
                const HGint32*  ix;
                HGint32                 y;

                exponent--;
                ix                      = &s_rcplut[(x >> (F_EXPONENT_SHIFT - 6))][0];      /* correct row in LUT                       */
                x                       = (x << (30 - F_EXPONENT_SHIFT)) | (1 << 30);           /* mantissa to 0.30 format              */
                y                       = hgMul64h(ix[0], x) + ix[1];                                           /* evaluate polynomial                  */
                y                       = hgMul64h(y, x)     + ix[2];                           
                x                       = y >> 2;
        } 

        if (exponent <= 0)
                return F_ZERO;
        
        return (HGifloat)((exponent << F_EXPONENT_SHIFT) | (x & F_MANTISSA_MASK) | sign);

#else
        HGint32     exponent    = 0xFE - extractBiasedExponent(a);
    HGuint32    sign        = a & F_SIGN_MASK;
    HGuint32    mantissa    = a & F_MANTISSA_MASK;

    if (mantissa)                                                          
    {
        HGuint32 r,r1,rt;

        exponent--;
        mantissa    = (mantissa | F_HIDDEN_BIT_MASK) << 8;                   
        r           = (HGuint32)s_rcpTable[(mantissa >> 23) & 0xFF];
        rt          = ~(r * (mantissa >> 8));
        r1          = (r * (rt >> 16)) >> 7;
        rt          = ~(r1 * (mantissa >> 16));
        r1          = r1 * (rt >> 15);
        rt          =~hgMulu64h(r1,mantissa);
        mantissa    = hgMulu64h(r1,rt) >> 7;
    } 

    return buildFloat (sign, exponent, mantissa);
#endif
}

/*-------------------------------------------------------------------*//*!
 * \brief   Performs floating point division
 * \param   a   Floating point value
 * \param   b   Floating point value
 * \return  a/b
 * \note    The result of division by zero (i.e., b == 0.0f) is 0.0f.
 * \note        The routine is both faster and more accurate than performing
 *                      an RCP + MUL.
 * \note        if b is a power-of-two, the routine is much faster.
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_DIV (
    HGifloat a, 
    HGifloat b)
{
    HGuint32    signMask, bMantissa, mantissa;
    int         exponent;

    /*-------------------------------------------------------------------
         * If either 'a' or 'b' is zero, return 0.0f
     *-----------------------------------------------------------------*/

    if (F_ZCMPEQ(a) || F_ZCMPEQ(b))         
        return F_ZERO;

    /*-------------------------------------------------------------------
         * Compute resulting sign and exponent, extract mantissas
     *-----------------------------------------------------------------*/

    signMask            = (a ^ b) & F_SIGN_MASK;       
        exponent                = 0xFE - extractBiasedExponent(b) + extractBiasedExponent(a) - F_EXPONENT_BIAS - 1;                    
        mantissa                = extractMantissa(a);
    bMantissa           = b & F_MANTISSA_MASK;

    /*-------------------------------------------------------------------
         * If 'b' has a mantissa (i.e., it's not a power of two), perform
         * reciprocal computation, followed by multiplication of the
         * mantissas of 'a' and 'b'.
     *-----------------------------------------------------------------*/

    if (bMantissa)                                                          
    {
        HGuint32 r,r1,rt, overflow;

        bMantissa   = (bMantissa | F_HIDDEN_BIT_MASK) << 8;                   
        r           = (HGuint32)s_rcpTable[(bMantissa >> 23) & 0xFF];
        rt          = ~(r * (bMantissa >> 8));
        r1          = (r * (rt >> 16)) >> 7;
        rt          = ~(r1 * (bMantissa >> 16));
        r1          = r1 * (rt >> 15);
        rt          =~hgMulu64h(r1,bMantissa);
        bMantissa   = hgMulu64h(r1,rt);

                mantissa        =  hgMulu64h(mantissa << 1, (bMantissa << 1) | (1u << 31));
                overflow        =  mantissa >> 24;                      
                exponent   +=  overflow - 1;
                mantissa  >>= overflow;
        } 

    /*-------------------------------------------------------------------
         * Create floating-point value
     *-----------------------------------------------------------------*/

        return buildFloat (signMask, exponent, mantissa);
}

/*-------------------------------------------------------------------*//*!
 * \brief   Performs floating point modulo
 * \param   a   Floating point value
 * \param   b   Floating point value
 * \return  fmod(a,b)
 * \note    The result of division by zero (i.e., b == 0.0f) is zero
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_MOD (
    HGifloat x, 
    HGifloat y)
{
        /*return F_MUL(F_FRAC(F_DIV(x,y)),y);*/

        /*-------------------------------------------------------------------
         * Quick early-exits. If abs(x) <= abs(y), we know the result 
         * immediately. If y is zero, raise error (in our case: return zero).
         * \todo we could early-exit also if the result is known to flush
         *               to zero
     *-----------------------------------------------------------------*/

        HGint32 mx = (HGint32)F_ABS(x);
        HGint32 my = (HGint32)F_ABS(y);
        HGint32 expx,expy,sh;

        if(mx < my)                                                     
                return x;                       
        
        if(mx == my || my == F_ZERO)
            return F_ZERO;

    /*-------------------------------------------------------------------
         * Extract exponents and mantissas
     *-----------------------------------------------------------------*/

        expx = (mx >> F_EXPONENT_SHIFT) - (F_EXPONENT_BIAS + 1);
        expy = (my >> F_EXPONENT_SHIFT) - (F_EXPONENT_BIAS + 1);

        mx       = extractMantissa((HGifloat)mx);
        my       = extractMantissa((HGifloat)my);

    /*-------------------------------------------------------------------
         * Perform modulo by looping. The inner loop is 2-3 instructions
         * in ARM, and we have unrolled it by a factor of 8.
         *-----------------------------------------------------------------*/

        if (expx != expy)
        {
                if (mx >= my)
                        mx -= my;

                expx -= expy + 1;

#define ITER { mx += (mx - my); if (mx < 0) mx += my; }

                for (; expx > 7; expx-=8)
                {
                        ITER
                        ITER
                        ITER
                        ITER
                        ITER
                        ITER
                        ITER
                        ITER
                }

                for (; expx > 0; expx--)
                {
                        ITER
                }
#undef ITER

                mx += mx;
        }
        
        if (mx >= my)
                mx -= my;

        if (mx == 0)                    
            return F_ZERO;

    /*-------------------------------------------------------------------
     * Normalize mantissa. If the resulting value becomes denormal,
         * return zero.
     *-----------------------------------------------------------------*/

        sh = hgMaxZero32(hgClz32((HGuint32)mx) - 8);

        mx  <<= sh;
        expy -= sh;

        if (expy < -126)
                return F_ZERO;

        HG_ASSERT (mx >= (HGint32)F_HIDDEN_BIT_MASK);

    /*-------------------------------------------------------------------
         * Construct IEEE floating-point value
     *-----------------------------------------------------------------*/

    return buildFloatUnchecked (x & F_SIGN_MASK, expy + F_EXPONENT_BIAS + 1, mx - F_HIDDEN_BIT_MASK);
}

/*-------------------------------------------------------------------*//*!
 * \brief   Computes reciprocal square root of a float
 * \param   a   Floating point value
 * \return  1.0f / sqrt(a)
 * \note    Return values when a <= 0.0 are undefined!
 * \note    There's a 2 ULP error 
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_RSQ (HGifloat a)
{
        HGint32                 x,y,exponent, even;
        const HGint32*  ix;

        if (F_ZCMPLE(a))                                
                return F_ZERO;

        exponent        = extractBiasedExponent(a) - F_EXPONENT_BIAS;
        even            = (exponent & 1) ^ 1;
        exponent        = F_EXPONENT_BIAS - (exponent >> 1) + even;

        x                       = a & F_MANTISSA_MASK;
        ix                      = &s_rsqlut[(x >> (F_EXPONENT_SHIFT - 6)) + (even << 6)][0];      /* correct row in LUT                         */
        x                       = (x << (30 - F_EXPONENT_SHIFT)) | (1 << 30);                                     /* mantissa to 0.30 format            */
        y                       = hgMul64h(ix[0], x) + ix[1];                                                                     /* evaluate polynomial                        */
        y                       = hgMul64h(y, x)     + ix[2];                           
        y                       >>= (2 - (even+even));                                                                                    /* conditional shifting                       */
        y                       = (exponent << F_EXPONENT_SHIFT) | (y & F_MANTISSA_MASK);

        return y;
}

/*-------------------------------------------------------------------*//*!
 * \brief   Computes square root of a float
 * \param   a   Floating point value
 * \return  sqrt(a)
 * \note    Square root of negative values is zero
 * \note    Implemented using a lookup table of 2nd degree polynomials
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_SQRT (HGifloat a)
{
    if (F_ZCMPGT(a))
    {
                HGint32                 e               = (HGint32)(a >> F_EXPONENT_SHIFT);
                HGint32                 x               = (HGint32)(a & F_MANTISSA_MASK);
                HGint32                 even    = (e & 1) ^ 1;
                const HGint32*  ix;
                HGint32                 y;

                e       = (( e - (F_EXPONENT_BIAS - 1)) >> 1) + F_EXPONENT_BIAS;
                ix  = &s_sqrtlut[(x >> (F_EXPONENT_SHIFT - 5)) + (even << 5)][0];       
                x   = (x << (30 - F_EXPONENT_SHIFT)) | (1 << 30);                       
                y   = hgMul64h(ix[0], x) + ix[1];
                y   = hgMul64h(y, x)     + ix[2];                                                                
                y   = (y >> (3 - (even << 1))) & F_MANTISSA_MASK;

                return (HGifloat)(y | (e << F_EXPONENT_SHIFT));
        } 

        return F_ZERO;
}

/*-------------------------------------------------------------------*//*!
 * \internal
 * \brief   Computes sine for a unit scalar
 * \param   x   Unit scalar value
 * \return  Unit scalar containing sin(x)
 *//*-------------------------------------------------------------------*/

HG_STATICF HGint32 F_CALL _IUnitScalar_sin (HGint32 x)
{
    HGint64     s;
    HGuint32    y;

    y = (HGuint32)hgAbs32(x);

    HG_ASSERT (y <= (HGuint32)IUNITSCALAR_ONE);

    if(y > (HGuint32)IUNITSCALAR_HALF)
        y = (HGuint32)(IUNITSCALAR_ONE-y);

    s = hgToSigned64(hgMulu64(y<<2,0xC90FDAA2u));
    y = (HGuint32)hgLsl64h_0_31(s,2);
    {
        HGint32 r;
        HGint32 x2 = (HGint32)hgMulu64h(y,y);
        y = hgMulu64h((HGuint32)x2,y);
        s = hgMadd64(s, (HGint32)y,-(0x55555555>>1));
        y = hgMulu64h((HGuint32)x2,y);
        s = hgMadd64(s, (HGint32)y, (0x44444444>>3));
        y = hgMulu64h((HGuint32)x2,y);
        s = hgMadd64(s, (HGint32)y,-(0x68068068>>7)-1);
        y = hgMulu64h((HGuint32)x2,y);
        s = hgMadd64(s, (HGint32)y, (0x5C778E95>>11)-1);
        y = hgMulu64h((HGuint32)x2,y);
        r = hgMadd64h(s, (HGint32)y,-(0x6B99159F>>16));

        if(x < 0)
            r =-r;
            
        HG_ASSERT (r >=-IUNITSCALAR_ONE);
        HG_ASSERT (r <= IUNITSCALAR_ONE);
        return r;
    }
}

/*-------------------------------------------------------------------*//*!
 * \internal
 * \brief   Computes cosine for a unit scalar
 * \param   x   Unit scalar value
 * \return  Unit scalar containing cos(x)
 *//*-------------------------------------------------------------------*/

HG_STATICF HGint32 F_CALL _IUnitScalar_cos (HGint32 x)
{
    HGuint32 y;

    x = hgAbs32(x);
    y = (HGuint32)x;
    
    if(y > (HGuint32)IUNITSCALAR_HALF)
        y = (HGuint32)(IUNITSCALAR_ONE-y);

    y = hgMulu64h(y<<3,0xC90FDAA2u);
    {
        HGuint32 t;
        HGint64 c  = hgToSigned64(hgMulu64(y,y<<1));
        HGint32 x2 = hgLsl64h_0_31(c,1);
        
        t = hgMulu64h((HGuint32)x2,(HGuint32)x2);
        c = hgMadd64(c, (HGint32)t,-(0x55555555>>1)-1);      /*  1/24 * 2 * 16 */
        t = hgMulu64h(t,(HGuint32)x2);
        c = hgMadd64(c, (HGint32)t, (0x5B05B05B>>4));            /*  1/720 *4 * 32 */
        t = hgMulu64h(t,(HGuint32)x2);
        c = hgMadd64(c, (HGint32)t,-(0x68068068>>8)+1);              /*  1/40320 *16 * 32 */
        t = hgMulu64h(t,(HGuint32)x2);
        c = hgMadd64(c, (HGint32)t, (0x49F93EDD>>12)+1);             /*  1/3628800 *32 * 16 * 4 */
        t = hgMulu64h(t,(HGuint32)x2);
        c = hgMadd64(c, (HGint32)t,-(0x47BB63BF>>17));               /*  1/479001600 * 64 * 16 * 8 */
        {
            HGint32 r = hgGet64h(c);
            r = (IUNITSCALAR_TWO - r)>>1;

            if(x > IUNITSCALAR_HALF)
                r =-r;
            
            HG_ASSERT(r >=-IUNITSCALAR_ONE);
            HG_ASSERT(r <= IUNITSCALAR_ONE);
            return r;
        }
    }
}

/*-------------------------------------------------------------------*//*!
 * \internal
 * \brief   Converts radians into a unit scalar
 * \param   a   Floating point value
 * \return  Unit scalar
 *//*-------------------------------------------------------------------*/

HG_STATICF HGint32 F_CALL radiansToUnitScalar (HGifloat a)
{
    /*-------------------------------------------------------------------
     * Extract exponent and mantissa. Apply input sign to mantissa.
     *-----------------------------------------------------------------*/

    HGint32 e   = extractBiasedExponent(a);
    HGint32 m   = (HGint32)(extractMantissa(a) << 6);
    HGint32 sh, lsh, rsh, x;

    if ((HGint32)(a) < 0)
        m = -m;

    /*-------------------------------------------------------------------
     * Convert into unit scalar range (this divides by PI and handles
     * the modulo).
     *-----------------------------------------------------------------*/

    sh  = ((e-2)+4) - 0x7f;
    lsh = hgMin32(hgMaxZero32(sh),    63);
    rsh = hgMin32(hgMaxZero32(-sh)+2, 31);
    x   = hgLsl64h(hgMul64(m, 0x517cc191),lsh) >> rsh;

    return x;
}

/*-------------------------------------------------------------------*//*!
 * \internal
 * \brief   Converts a unit scalar into a floating-point value
 * \param   s   Unit scalar
 * \return  Corresponding IEEE floating-point value
 *//*-------------------------------------------------------------------*/

HG_STATICF HGifloat F_CALL unitScalarToFloat (HGint32 s)
{
    HGuint32 sign       = (HGuint32)(s) & F_SIGN_MASK;
    HGuint32 mantissa   = (HGuint32)hgAbs32(s);
    HGint32  exponent   = 8-hgClz32(mantissa);

    HG_ASSERT (hgAbs32(s) <= IUNITSCALAR_ONE);

        mantissa        = lsrSigned (mantissa, exponent);

    return buildFloatUnchecked (sign, exponent + F_EXPONENT_BIAS - 5, mantissa);
}

/*-------------------------------------------------------------------*//*!
 * \brief   Computes sine of a float
 * \param   a   Floating point value
 * \return  sin(a)
 * \note    This is *terribly* slow. We need a nice CORDIC variant!
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_SIN (HGifloat a)
{
    if (F_ABS(a) <= 0x3a000000u)    /* sin(x) ~ x for very small values of x */
        return a;
    else
        return unitScalarToFloat(_IUnitScalar_sin(radiansToUnitScalar(a)));
}

/*-------------------------------------------------------------------*//*!
 * \brief   Computes cosine of a float
 * \param   a   Floating point value
 * \return  cos(a)
 * \note    This is *terribly* slow. We need a nice CORDIC variant!
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_COS (HGifloat a)
{
    return unitScalarToFloat(_IUnitScalar_cos(radiansToUnitScalar(a)));
}

/*-------------------------------------------------------------------*//*!
 * \brief   Computes tangent of a float
 * \param   a   Floating point value
 * \return  tan(a)
 * \note    Currently computes tan as sin(a)/cos(a), but this can
 *          be highly inaccurate when a is close to PI/2. Will change
 *          to a better formula later.
 * \note    This is *terribly* slow. We need a nice CORDIC variant!
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_TAN (HGifloat a)
{
    if (F_ABS(a) <= 0x3a000000u)        /* tan(x) ~ x for very small values of x */
        return a;
    else
    {
        HGint32         angle = radiansToUnitScalar(a);
        HGifloat        s     = unitScalarToFloat(_IUnitScalar_sin(angle));
        HGifloat    c     = unitScalarToFloat(_IUnitScalar_cos(angle));

        s = F_DIV(s,c);

        return s;
    }
}

/*-------------------------------------------------------------------*//*!
 * \brief   Computes arcus cosine of a float
 * \param   a   Floating point value
 * \return  acos(a)
 * \note    This is *terribly* slow. We need a nice CORDIC variant!
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_ACOS (HGifloat x)
{
    const HGifloat  
            pio2_hi = 0x3fc90fdau, /*  1.5707962513e+00f*/
            pio2_lo = 0x33a22168u, /*  7.5497894159e-08f*/
            pS0     = 0x3e2aaaabu, /*  1.6666667163e-01f*/
            pS1     = 0xbea6b090u, /* -3.2556581497e-01f*/
            pS2     = 0x3e4e0aa8u, /*  2.0121252537e-01f*/
            pS3     = 0xbd241146u, /* -4.0055535734e-02f*/
            pS4     = 0x3a4f7f04u, /*  7.9153501429e-04f*/
            pS5     = 0x3811ef08u, /*  3.4793309169e-05f*/
            qS1     = 0xc019d139u, /* -2.4033949375e+00f*/
            qS2     = 0x4001572du, /*  2.0209457874e+00f*/
            qS3     = 0xbf303361u, /* -6.8828397989e-01f*/
            qS4     = 0x3d9dc62eu; /*  7.7038154006e-02f*/

    HGifloat    z,r,s;
    HGint32 ix = (HGint32)(x &~ F_SIGN_MASK);

    /*-------------------------------------------------------------------
     * Early exits
     *-----------------------------------------------------------------*/

    if (ix >= (HGint32)(F_ONE))
        return (HGint32)(x) < 0 ? F_PI : F_ZERO;

    if(ix <= 0x23000000)                                /* values really close to zero */
        return F_HALF_PI;

    /*-------------------------------------------------------------------
     * Compute r
     *-----------------------------------------------------------------*/

    if (ix < (HGint32)F_HALF)
        z = F_SQR(x);
    else if ((HGint32)(x) < 0)
        z = F_SHIFT(F_ADD(F_ONE,x),-1);
    else
        z = F_SHIFT(F_SUB(F_ONE,x),-1);

    {
        HGifloat p = F_MUL(z,F_MADD(z,F_MADD(z,F_MADD(z,F_MADD(z,F_MADD(z,pS5,pS4),pS3),pS2),pS1),pS0));
        HGifloat q = F_MADD(z,F_MADD(z,F_MADD(z,F_MADD(z,qS4,qS3),qS2),qS1),F_ONE);

        r = F_DIV(p,q);
    }

    /*-------------------------------------------------------------------
     * ]-0.5,+0.5[
     *-----------------------------------------------------------------*/

    if(ix < (HGint32)F_HALF)                                        
        return F_SUB(pio2_hi,F_SUB(x,F_SUB(pio2_lo,F_MUL(x,r))));

    s = F_SQRT(z);

    /*-------------------------------------------------------------------
     * ]-1.0, -0.5[
     *-----------------------------------------------------------------*/

    if ((HGint32)(x) < 0)                               
        return F_SUB(F_PI,F_SHIFT(F_ADD(s,F_MSUB(r,s,pio2_lo)),1));

    /*-------------------------------------------------------------------
     * [0.5,1.0[
     *-----------------------------------------------------------------*/

    {                                                   
        HGifloat df    = s & 0xfffff000u;
        HGifloat c     = F_DIV(F_SUB(z,F_SQR(df)),F_ADD(s,df));
        HGifloat w     = F_MADD(r,s,c);

        return F_SHIFT(F_ADD(df,w),1);
    }
}

/*-------------------------------------------------------------------*//*!
 * \brief   Flushes denormals and converts NaNs into finites
 * \param   a   Floating point value
 * \return  Cleaned float
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_CLEAN (HGifloat a)
{
        HGifloat absa = F_ABS(a);                                       /* clean top bit                        */

    if (absa < F_FLOAT_MIN)                     /* flush denormals to zero      */
        return F_ZERO;

    if (absa > F_FLOAT_INF)                     /* NaNs etc. are converted into INFs with proper sign */
        return F_FLOAT_INF | (a & F_SIGN_MASK);

    HG_ASSERT (F_ISVALID(a));
    return a;                                                                   /* ok, return as-is */
}

/*-------------------------------------------------------------------*//*!
 * \brief   Clamps infinite values to finite values, treats NaN input 
 *                      as infinities. Also flushes denormals into zeroes. 
 * \param   a   Floating point value
 * \return  Cleaned and clamped float
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_CLEANFINITE (HGifloat a)
{
        HGifloat absa = F_ABS(a);                                               /* clear top (sign) bit                 */

    if (absa < F_FLOAT_MIN)                                                     /* flush denormals to zero */
        return F_ZERO;

    if (absa >= F_FLOAT_INF)                                            /* NaNs and INFs are clamped to F_FLOAT_MAX */
        return  F_FLOAT_MAX | (a & 0x80000000u);

    HG_ASSERT (F_ISVALID(a));
    HG_ASSERT (F_FINITE(a));
    
        return a;
}

/*-------------------------------------------------------------------*//*!
 * \brief   Performs comparison between a float and an integer
 * \param   a   Floating point value
 * \param   b   32-bit signed integer
 * \return  a < b -> -1, a == b -> 0, a > b -> +1
 *//*-------------------------------------------------------------------*/

HGint32 F_CALL F_ICMP (
    HGifloat a, 
    HGint32  b)
{
    HGint32 bExponent, aExponent, aMantissa;
    
    /*-------------------------------------------------------------------
     * Take care of the zero cases (and denormals etc.) first. This
     * makes the subsequent code simpler..
     *-----------------------------------------------------------------*/

    if (b == 0)                                 /* b = 0                */
        return F_ZCMP(a);

    if (F_ABS(a) < F_ONE)                       /* a = ]-1.0f,+1.0f[    */
        return (HGint32)(( ((HGuint32)(b) >> 30) & 2) - 1);

    /*-------------------------------------------------------------------
     * If the values have different signs, we can return immediately.
     *-----------------------------------------------------------------*/

    if ((HGint32)(a ^ b) < 0)
        return 1 - ((a >> 30) & 2); /* either +1 or -1 depending on sign */

    /*-------------------------------------------------------------------
     * Both values have the same sign and neither is zero. We also know
     * that the absolute value of both values are >= 1. We need to
     * find the exponent of 'b' and then perform comparsions.
     *-----------------------------------------------------------------*/

    b   = hgAbs32(b);

    aExponent = extractBiasedExponent(a) - F_EXPONENT_BIAS; 
    bExponent = 32-hgClz32((HGuint32)b);

    /*-------------------------------------------------------------------
     * If the values have different exponents, we can exit now.
     *-----------------------------------------------------------------*/

    if (aExponent != bExponent)
        return 1 - (HGint32)(((HGuint32)((aExponent - bExponent) ^ a) >> 30) & 2);

    /*-------------------------------------------------------------------
     * Align mantissas..
     *-----------------------------------------------------------------*/

    aMantissa   =   (HGint32)(extractMantissa(a) << 8); 
    b           <<= (32 - bExponent);

    /*-------------------------------------------------------------------
     * Perform comparison of mantissas. Negate the result if the
     * values were signed.
     *-----------------------------------------------------------------*/

    aMantissa -= b;

    if ((HGint32)(a) < 0)
        aMantissa = -aMantissa;

    return hgSign32(aMantissa); /* [-1,0,+1] */
}


/*-------------------------------------------------------------------*//*!
 * \brief   Computes a*b + c*d
 * \param   a   Floating point value
 * \param   b   Floating point value
 * \param   c   Floating point value
 * \param   d   Floating point value
 * \return  a*b+c*d
 * \todo        Open up?
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_DOT2 (
    HGifloat a, 
    HGifloat b, 
    HGifloat c, 
    HGifloat d)
{
    return F_MADD(c, d, F_MUL(a, b));
}
/*-------------------------------------------------------------------*//*!
 * \brief   Computes 2^x 
 * \param   a   Floating point value
 * \return  2^x
 * \note    Maximum error is currently 2 ULPs.
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_EXP2 (HGifloat a)
{   

    HGint32         exponent, y, x;
    const HGint32*  ix; 

    /*----------------------------------------------------------------
     * Handle underflows and overflows, i.e., values outside the
     * ]-126.0f,+128.0f[ range.
     *--------------------------------------------------------------*/

    if (a > 0xc2fc0000u)                                /* input value < -126.0f */
        return F_ZERO;

    if ((HGint32)(a) >= 0x43000000)             /* input value >= +128.0f */
        return F_FLOAT_MAX;

    /*----------------------------------------------------------------
     * Extract exponent.
     *--------------------------------------------------------------*/

    exponent = (F_EXPONENT_BIAS + 31 - 23) - extractBiasedExponent(a);

    /*----------------------------------------------------------------
     * Align mantissa and apply sign.
     *--------------------------------------------------------------*/

    x = asrMod256((extractMantissa(a) << 7), exponent);  
    
    if ((HGint32)(a) < 0)
        x = -x;

    /*----------------------------------------------------------------
     * Exponent of resulting floating-point value.
     *--------------------------------------------------------------*/

    exponent = ((x >> F_EXPONENT_SHIFT) + (F_EXPONENT_BIAS + 1)) << F_EXPONENT_SHIFT;

    /*----------------------------------------------------------------
     * Choose correct lookup table and evaluated second-degree
     * polynomial using the mantissa of the fixed-point value.
     *--------------------------------------------------------------*/

    x  &= F_MANTISSA_MASK;                                  /* take mantissa                            */
    ix  = &s_exp2lut[(x >> (F_EXPONENT_SHIFT - 5))][0];     /* correct row in LUT                       */
    x   = (x << (30 - F_EXPONENT_SHIFT)) | (1 << 30);       /* mantissa to 0.30 format          */
    y   = hgMul64h(ix[0], x) + ix[1];                       /* evaluate polynomial                      */
    y   = hgMul64h(y, x)     + ix[2];                                           

    /*----------------------------------------------------------------
     * Combine exponent and mantissa (the shift pair removes the
     * hidden bit and places the mantissa in the right position).
     *--------------------------------------------------------------*/

    return exponent | ((HGuint32)(y << 5) >> 9);
}

/*-------------------------------------------------------------------*//*!
 * \brief   Computes log2 of floating-point value
 * \param   a   Floating point value
 * \return      log2 of floating-point value
 * \note        max 2 ULP error for input values >= 2.0f, and absolute
 *                      error < 1e-6 for range [0,2[
 * \note        Returns 0.0f for values < 0.0f
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_LOG2 (HGifloat a)
{       
        
        HGint32                 x,y,exponent;
    const HGint32*  ix; 
    HGuint32            mantissa, sign;

    /*----------------------------------------------------------------
     * Need to handle special cases first.
     *--------------------------------------------------------------*/

        if ((HGint32)(a) <= (HGint32)F_ONE)
        {
                if (F_ZCMPLE(a) || a == F_ONE)                                                          /* error cases or exactly 1.0f  */
                        return F_ZERO;
        } else
        {
                if (a >= 0x7f7fffffu)                                                                           /* >= FLT_MAX */
                        return 0x42ffffffu;                                                                     
        }

    /*----------------------------------------------------------------
     * Evaluate using polynomials
     *--------------------------------------------------------------*/

        x                       = a & F_MANTISSA_MASK;
    ix                  = &s_log2lut[(x >> (F_EXPONENT_SHIFT - 6))][0];     /* correct row in LUT                       */
    x                   = (x << (30 - F_EXPONENT_SHIFT)) | (1 << 30);       /* mantissa to 0.30 format          */
    y                   = hgMul64h(ix[0], x) + ix[1];                       /* evaluate polynomial                      */
    y                   = hgMul64h(y, x)     + ix[2];                           

    /*----------------------------------------------------------------
     * Construct resulting floating point value
     *--------------------------------------------------------------*/

    mantissa    = y + ((extractBiasedExponent(a) - F_EXPONENT_BIAS - 2) << (F_EXPONENT_SHIFT + 1));
    sign                = (HGuint32)(mantissa) & F_SIGN_MASK;
    mantissa    = (HGuint32)hgAbs32((HGint32)mantissa);
    exponent    = 8 - hgClz32(mantissa);
        mantissa        = lsrSigned (mantissa, exponent);
    
    return buildFloatUnchecked (sign, exponent + F_EXPONENT_BIAS, mantissa);
}

/*-------------------------------------------------------------------*//*!
 * \brief   Computes a^b
 * \param   a   Floating point value
 * \return  a^b
 * \note        Implemented using internally the formula:
 *                      pow(a,b) = exp2(log2(|a|) * b) and then handling
 *                      signs correctly.
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_POW (
        HGifloat a, 
        HGifloat b)
{   
        HGuint32                globalSign      = 0;
        HGuint32                sign            = 0;
        HGint32                 bShift          = extractBiasedExponent(b);
        HGint32                 exponent, x, y;
        HGuint32                mantissa, overflow;
        const HGint32*  ix; 

        /*--------------------------------------------------------------------
         * If 'b' is zero or denormal -> result is 1.0
         *------------------------------------------------------------------*/

        if (bShift == 0)                                                
                return F_ONE;

        /*--------------------------------------------------------------------
         * If 'a' is negative, determine sign of the result (assign to
         * 'globalSign').
         *------------------------------------------------------------------*/

        if (F_ZCMPLE(a))                                                                                        /* a <= 0  */
        {
                HGint32         aShift = extractBiasedExponent(a);

                /*----------------------------------------------------------------
                 * Handle 0^b
                 *--------------------------------------------------------------*/

                if (aShift == 0)                                                        
                        return F_ZCMPGE(b) ? F_ZERO : F_FLOAT_MAX;

                /*----------------------------------------------------------------
                 * Now we need to determine if b is integer and whether it's even
                 * or odd
                 *--------------------------------------------------------------*/
 
                bShift = (F_EXPONENT_BIAS + 24) - bShift;

                if (bShift >= 24)                                       /* b < 1.0                                                      */
                        return F_ZERO;
                else
                if (bShift <= 0)                                        /* b > 2^24 -> always an integer        */
                        globalSign = (b & 1u);                  /* odd ones are signed                          */
                else
                {
                        HGifloat res = ((HGint32)(b) >> bShift) << bShift;

                        if (res != b)
                                return F_ZERO;                          /* Not an integer value!! */

                        res >>= bShift;                                 /* get down */
                        globalSign  = (res & 1u);               /* determine whether even or odd */
                }

                globalSign <<= 31;
        }

        a = F_ABS(a);                                                   /* from now on perform ops as unsigned */

        /*--------------------------------------------------------------------
         * Handle cases +-1.0
         *------------------------------------------------------------------*/

        if (a == F_ONE)                                                 /* +1 and -1 */
                return F_ONE ^ globalSign;
/*
        a = F_LOG2(a);
        a = F_MUL(a,b);
        a = F_EXP2(a);

        return a ^ globalSign;

*/
        /*--------------------------------------------------------------------
         * Compute log2(a)
         *------------------------------------------------------------------*/

        if (a >= F_FLOAT_MAX)                                                                                   /* FLT_MAX */
        {
                exponent = 7;
                mantissa = 0x007fffff;                                                                          /* 127.9999999... */
        } else
        {
                x               = a & F_MANTISSA_MASK;
                ix              = &s_log2lut[(x >> (F_EXPONENT_SHIFT - 6))][0];     /* correct row in LUT                       */
                x               = (x << (30 - F_EXPONENT_SHIFT)) | (1 << 30);       /* mantissa to 0.30 format          */
                y               = hgMul64h(ix[0], x) + ix[1];                       /* evaluate polynomial                      */
                y               = hgMul64h(y, x)     + ix[2];                           

                mantissa    = y + ((extractBiasedExponent(a) - F_EXPONENT_BIAS - 2) << (F_EXPONENT_SHIFT + 1));
                sign            = (HGuint32)(mantissa) & F_SIGN_MASK;
                mantissa    = (HGuint32)hgAbs32((HGint32)mantissa);
                exponent    = 8 - hgClz32(mantissa);
                mantissa        = lsrSigned (mantissa, exponent);

                mantissa &= F_MANTISSA_MASK;
        }

        /*--------------------------------------------------------------------
         * Perform multiplication (with 29 bit output).
         *------------------------------------------------------------------*/

        HG_ASSERT(F_ISVALID(a) && F_ISVALID(b));

        sign            = (sign ^ b) & F_SIGN_MASK;
        b                       = F_ABS(b);
        mantissa        =  hgMulu64h((mantissa | F_HIDDEN_BIT_MASK) << 7, extractMantissa(b) << 8);
        overflow        =  (HGuint32)(mantissa) >> 30;                      
        exponent        += (b >> F_EXPONENT_SHIFT) - F_EXPONENT_BIAS;
        exponent        += overflow - 1;
        mantissa        =  (HGuint32)(mantissa)  >> overflow;
        mantissa        &= ((1<<29)-1);

        /*----------------------------------------------------------------
         * If value is out of range, exit.
         *--------------------------------------------------------------*/

        if (exponent >= 8)                                                                                                      /* input value <= -128 or >= 128 */
                return sign ? F_ZERO : (F_FLOAT_MAX ^ globalSign);

        if (sign && exponent == 7 && mantissa > (0x007c0000 << 6))                      /* input value < -126 */
                return F_ZERO;

        /*----------------------------------------------------------------
         * Compute shifter value.
         *--------------------------------------------------------------*/

        exponent = (31 - F_EXPONENT_SHIFT) - exponent ;

        /*----------------------------------------------------------------
         * Align mantissa and apply sign.
         *--------------------------------------------------------------*/

        x = (HGuint32)asrMod256(((mantissa | (F_HIDDEN_BIT_MASK << 6)) << 1), exponent);  

        if (sign)       
                x = -x;

        /*----------------------------------------------------------------
         * Exponent of resulting floating-point value.
         *--------------------------------------------------------------*/

        exponent = ((x >> F_EXPONENT_SHIFT) + (F_EXPONENT_BIAS + 1)) << F_EXPONENT_SHIFT;

        /*----------------------------------------------------------------
         * Choose correct lookup table and evaluate second-degree
         * polynomial using the mantissa of the fixed-point value.
         * \todo figure out why we can't feed in x in .29 format (i.e.,
         *       why is x aligned the way it is right now).
         *--------------------------------------------------------------*/

        ix  = &s_exp2lut[(x >> (F_EXPONENT_SHIFT - 5)) & 0x1f][0];      /* correct row in LUT                   */
        x  &= F_MANTISSA_MASK;                                                                                  /* take mantissa                                */
        x   = (x << (30 - F_EXPONENT_SHIFT)) | (1 << 30);                               /* mantissa to 0.30 format              */
        y   = hgMul64h(ix[0], x) + ix[1];                                                               /* evaluate polynomial                  */
        y   = hgMul64h(y, x)     + ix[2];                                                               /* output in .28 fixed point    */         

        /*----------------------------------------------------------------
         * Combine exponent and mantissa (the shift pair removes the
         * hidden bit and places the mantissa in the right position).
         *--------------------------------------------------------------*/

        return (exponent | ((HGuint32)(y << 5) >> 9)) ^ globalSign;
}

/*-------------------------------------------------------------------*//*!
 * \brief   Returns the fractional part of a float
 * \param   a   Floating point value
 * \return  a - floor(a) (this is the definition of 'frac')
 * \note    The code has been opened up so that in most cases it
 *          is much faster than computing the floor and executing a
 *          subtraction.
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_FRAC (HGifloat a)
{
        HGint32         exponent = extractBiasedExponent(a);
        HGuint32        x;

    /*----------------------------------------------------------------
         * Values |a| >= (2^24) always yield zero (we handle these here
         * to avoid clamping later on).
     *--------------------------------------------------------------*/

        if (exponent >= (F_EXPONENT_BIAS + 24))
                return F_ZERO;

    /*----------------------------------------------------------------
     * Values in range ]-1,+1[ handled with separate code.
     *--------------------------------------------------------------*/

        if (exponent <= F_EXPONENT_BIAS)
        {
                HGint32  overflow;
                HGuint32 mantissa;

           /*-------------------------------------------------------------------
                * Values in range [0,1[ are returned back as-is (this retains
                * more precision in the results).
                *-----------------------------------------------------------------*/

                if (F_ZCMPGE(a))
                        return a;

           /*-------------------------------------------------------------------
                * Values in ]-1,0[ need to be treated separately. This is done
                * by computing (a + 1.0f). The code below performs that using
                * an optimized version specialized for values in this range.
                *-----------------------------------------------------------------*/

                if (exponent <= (F_EXPONENT_BIAS - 24))         
                        return F_ONE;

                mantissa        = (0x80000000) - ((extractMantissa(a) << 8) >> (F_EXPONENT_BIAS + 1 - exponent));
                overflow    = hgClz32(mantissa);                                        /* normalize mantissa */
                exponent    = F_EXPONENT_BIAS + 1 - overflow;
                overflow        = 8 - overflow;
                mantissa        = lsrSigned (mantissa, overflow);

                return buildFloatUnchecked (0, exponent, mantissa);
        }
 
    /*----------------------------------------------------------------
     * Get rid of integer part (leave fraction to mantissa).
     *--------------------------------------------------------------*/

    x = (a << (exponent - F_EXPONENT_BIAS));

    /*----------------------------------------------------------------
     * Handle negative values (need to compute 1 - frac).
     *--------------------------------------------------------------*/

    if ((HGint32)(a) < 0)                     
        x = (HGuint32)-(HGint32)x;

    /*----------------------------------------------------------------
     * Construct floating-point value from the fixed-point result.
     *--------------------------------------------------------------*/

    x &= (F_MANTISSA_MASK << 1);                

    if (x == 0)                                 
        return F_ZERO;

    exponent = hgClz32(x) - 8;
    
    return buildFloatUnchecked (0, F_EXPONENT_BIAS - exponent, x << exponent);
}

/*-------------------------------------------------------------------*//*!
 * \brief   Returns floor(x), i.e., rounds downwards to nearest 
 *          integer
 * \param   x   Floating point value
 * \return  floor(x)
 *//*-------------------------------------------------------------------*/

HGifloat F_CALL F_FLOOR (HGifloat x)
{
    HGint32 e, t, q;

        e = extractBiasedExponent(x);

    t = (HGint32)0xff000000;
    e = e - 126;
    t = ~(asrMod256(t,e));
    q = t & (HGint32)x >> 31;

    if(e > 0)
    {
        x += q;
        x &= ~t;
        return x;
    }

    if(x > 0x80000000u)  
        x = 0xbf800000u;
    else                
        x &= 0x80000000u;

    return x;

#if 0
    HGifloat    res;
    HGint32     shift;
    HGuint32    signMask;

    /*-------------------------------------------------------------------
     * First handle +-0.0f and denormals (exponent = 0)
     *-----------------------------------------------------------------*/

    shift = extractBiasedExponent(x);
    
    if (shift == 0)                                     
        return x;

    /*-------------------------------------------------------------------
     * If exponent >= 24, flooring can't affect the value ->
     * return immediately.
     *-----------------------------------------------------------------*/
    
    shift = (F_EXPONENT_BIAS + 24) - shift;

    if (shift <= 0)
        return x;

    /*-------------------------------------------------------------------
     * Clear bits from bottom. If x is negative and is not an integer
     * in the first place (i.e., bits are actually cleared), we need
     * to decrement it by one, i.e., floor(-6.3f) == -7.0f;
     *-----------------------------------------------------------------*/

    signMask    = (HGuint32)((HGint32)(x) >> 31);
    res         = ((HGint32)(x) >> shift) << shift;

    if (res != x)           
        res -= signMask << shift;

    /*-------------------------------------------------------------------
     * Handle cases in range [-1,+1]. Negative values must return
     * -1.0f and positive values 0.0f.
     *-----------------------------------------------------------------*/

    if (shift > 23)
        res = (F_SIGN_MASK | F_ONE) & signMask;

    /*-------------------------------------------------------------------
     * Return values.
     *-----------------------------------------------------------------*/

    return res;
#endif
}

/*----------------------------------------------------------------------*/

