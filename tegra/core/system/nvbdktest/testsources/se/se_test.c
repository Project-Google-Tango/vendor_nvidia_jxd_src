/*
 * Copyright (c) 2012-2014, NVIDIA CORPORATION.  All rights reserved.
 *
 * NVIDIA Corporation and its licensors retain all intellectual property
 * and proprietary rights in and to this software and related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA Corporation is strictly prohibited.
 */

#include "nvos.h"
#include "nvddk_blockdev.h"
#include "nvddk_se_blockdev.h"
#include "se_test.h"
#include "nvddk_sdio.h"
#include "nvddk_blockdevmgr.h"
#include "testsources.h"


#include "nvtest.h"
#include "nvcommon.h"
#include "nvrm_init.h"
#include "nvrm_hardware_access.h"
#include "nvrm_memmgr.h"
#include "nvrm_module.h"
#include "nvassert.h"
#include "nvodm_services.h"
#include "nvrm_power.h"
#include "nvrm_drf.h"
#include "nvodm_query.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "nvddk_aes_blockdev_defs.h"
#include "nvddk_aes_blockdev.h"

#define AES_TEXT_MSG_LENGTH_BYTES (64)

#define IN_BITS(x)  ((x)<<3)
#define IN_BYTES(x) ((x)>>3)

#define SE_TEST_RNG_MAX_SEED_LEN IN_BYTES(384)
#define SE_TEST_RNG_OUT_MIN_SIZE IN_BYTES(128)
#define MAX_ROUNDS 200

#define SE_TEST_PUB_EXP_MAX_SIZE (4)
#define SE_TEST_MODULUS_MAX_SIZE (256)

#define AES_KEY_LENGTH_BYTES   16
#define AES_IV_LENGTH_BYTES    16
#define NvDdkAesConst_MaxKeyLengthBytes 32
#define NvDdkAesConst_BlockLengthBytes 16
#define BUFFER_SIZE_BYTES 0x140
#define AES_ENCRYPTION NV_TRUE
#define AES_DECRYPTION NV_FALSE
#define DEDICATED_SLOT NV_TRUE
#define MSECS_IN_A_SEC 1000
#define MB_IN_BYTES(x) x * 1024 * 1024

static NvU8 s_ZeroKey[NvDdkAesConst_MaxKeyLengthBytes] = {0};

typedef struct AesTestVectorData_Rec
{
    NvU8 Key[32];
    NvU8 Iv[NvDdkSeAesConst_IVLengthBytes];
    NvU8 PlainText[AES_TEXT_MSG_LENGTH_BYTES];
    NvU8 CipherText[AES_TEXT_MSG_LENGTH_BYTES];
    NvU32 KeyLen;
    NvU8 NoOfBlocks;
    NvDdkSeAesOperationalMode OpMode;
} AesTestVectorData;

typedef struct CmacTestVectorData_Rec
{
    NvU8 Key[32];
    NvU8 PlainText[AES_TEXT_MSG_LENGTH_BYTES];
    NvU8 Cmac[16];
    NvU32 MsgLen;
} CmacTestVectorData;

typedef struct SeRngTestVecData_Rec
{
    NvU8 RngSeed[SE_TEST_RNG_MAX_SEED_LEN];
    NvU32 RngSeedLen;
    NvDdkSeRngKey KeySize;
    NvU8 RandomNumber[SE_TEST_RNG_OUT_MIN_SIZE * MAX_ROUNDS];
} SeRngTestVecData;

static SeRngTestVecData Rng1Vector =
{
    {
        0xa6, 0xf4, 0xd9, 0x72, 0xd2, 0xfc, 0x94, 0xe9, 0xb9, 0x82, 0xb5, 0xdc,
        0xec, 0xc8, 0x24, 0xdb, 0x83, 0xad, 0xd7, 0xd5, 0x36, 0x2e, 0xb7, 0x57,
        0x05, 0x33, 0x3f, 0x51, 0x22, 0xf5, 0x42, 0x2e
    },
    32,
    NvDdkSeRngKeySize_128,
    {
        0x00
    }
};

static SeRngTestVecData Rng2Vector =
{
    {
        0xa6, 0xf4, 0xd9, 0x72, 0xd2, 0xfc, 0x94, 0xe9, 0xb9, 0x82, 0xb5, 0xdc,
        0xec, 0xc8, 0x24, 0xdb, 0x83, 0xad, 0xd7, 0xd5, 0x36, 0x2e, 0xb7, 0x57,
        0x05, 0x33, 0x3f, 0x51, 0x22, 0xf5, 0x42, 0x2e, 0x0c, 0x5d, 0x94, 0x55,
        0xf5, 0x8e, 0x23, 0xc4, 0x03, 0x39, 0xc0, 0x6d, 0x47, 0x87, 0x17, 0x4b
    },
    48,
    NvDdkSeRngKeySize_192,
    {
        0x00
    }
};

static SeRngTestVecData Rng3Vector =
{
    {
        0xa6, 0xf4, 0xd9, 0x72, 0xd2, 0xfc, 0x94, 0xe9, 0xb9, 0x82, 0xb5, 0xdc,
        0xec, 0xc8, 0x24, 0xdb, 0x83, 0xad, 0xd7, 0xd5, 0x36, 0x2e, 0xb7, 0x57,
        0x05, 0x33, 0x3f, 0x51, 0x22, 0xf5, 0x42, 0x2e, 0x0c, 0x5d, 0x94, 0x55,
        0xf5, 0x8e, 0x23, 0xc4, 0x03, 0x39, 0xc0, 0x6d, 0x47, 0x87, 0x17, 0x4b
    },
    48,
    NvDdkSeRngKeySize_256,
    {
        0x00
    }
};

CmacTestVectorData cmacTestVector1 =
{
    {
        0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,
        0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c
    },
    {
        0x0
    },
    {
        0xbb,0x1d,0x69,0x29,0xe9,0x59,0x37,0x28,
        0x7f,0xa3,0x7d,0x12,0x9b,0x75,0x67,0x46
    },
    0
};

CmacTestVectorData cmacTestVector2 =
{
    {
        0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,
        0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c
    },
    {
        0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,
        0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
        0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,
        0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,
        0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11
    },
    {
        0xdf,0xa6,0x67,0x47,0xde,0x9a,0xe6,0x30,
        0x30,0xca,0x32,0x61,0x14,0x97,0xc8,0x27
    },
    40
};

CmacTestVectorData cmacTestVector3 =
{
    {
        0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,
        0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c
    },
    {
        0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,
        0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
        0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,
        0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,
        0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11,
        0xe5,0xfb,0xc1,0x19,0x1a,0x0a,0x52,0xef,
        0xf6,0x9f,0x24,0x45,0xdf,0x4f,0x9b,0x17,
        0xad,0x2b,0x41,0x7b,0xe6,0x6c,0x37,0x10
    },
    {
        0x51,0xf0,0xbe,0xbf,0x7e,0x3b,0x9d,0x92,
        0xfc,0x49,0x74,0x17,0x79,0x36,0x3c,0xfe
    },
    64
};

CmacTestVectorData cmacTestVector4 =
{
    {
        0x33,0x64,0x16,0x9e,0xe0,0x77,0xca,0xfb,
        0x9b,0x15,0xcb,0xab,0xaf,0xa4,0xf3,0xf1,
        0xea,0x13,0x8b,0xbc,0x09,0x75,0x64,0x70
    },
    {
        0x0
    },
    {
        0x57,0xaa,0xb6,0x46,0x10,0x5c,0x5e,0x5b,
        0x80,0x21,0x4b,0x87,0xff,0xfa,0x38,0x47
    },
    0
};

CmacTestVectorData cmacTestVector5 =
{
    {
        0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,
        0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c,
        0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,
        0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c
    },
    {
        0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,
        0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
        0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,
        0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,
        0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11
    },
    {
        0x45,0x64,0xfe,0xd0,0x36,0x2c,0x6d,0xb6,
        0x34,0xf2,0xf2,0x8a,0x39,0x42,0x38,0x9b
    },
    40
};

AesTestVectorData aesCbcVector1 =
{
    /// Case #1: Encrypting 16 bytes (1 block) using AES-CBC with 128-bit key
    {
        /// 128-bit Key
        0x06, 0xa9, 0x21, 0x40, 0x36, 0xb8, 0xa1, 0x5b,
        0x51, 0x2e, 0x03, 0xd5, 0x34, 0x12, 0x00, 0x06
    },
    {
        /// 128-bit IV
        0x3d, 0xaf, 0xba, 0x42, 0x9d, 0x9e, 0xb4, 0x30,
        0xb4, 0x22, 0xda, 0x80, 0x2c, 0x9f, 0xac, 0x41
    },
    /// Plain Text
    "Single block msg",
    {
        /// Cipher text
        0xe3, 0x53, 0x77, 0x9c, 0x10, 0x79, 0xae, 0xb8,
        0x27, 0x08, 0x94, 0x2d, 0xbe, 0x77, 0x18, 0x1a
    },
    /// key length
    16,
    /// Number of AES blocks in the Text
    1,
    NvDdkSeAesOperationalMode_Cbc
};
AesTestVectorData aesCbcVector2 =
{
    /// Case #2: Encrypting 16 bytes (2 blocks) using AES-CBC with 128-bit key
    {
        /// 128-bit Key
        0xc2, 0x86, 0x69, 0x6d, 0x88, 0x7c, 0x9a, 0xa0,
        0x61, 0x1b, 0xbb, 0x3e, 0x20, 0x25, 0xa4, 0x5a
    },
    {
        /// 128-bit IV
        0x56, 0x2e, 0x17, 0x99, 0x6d, 0x09, 0x3d, 0x28,
        0xdd, 0xb3, 0xba, 0x69, 0x5a, 0x2e, 0x6f, 0x58
    },
    {
        /// Plain Text
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
    },
    {
        /// Cipher text
        0xd2, 0x96, 0xcd, 0x94, 0xc2, 0xcc, 0xcf, 0x8a,
        0x3a, 0x86, 0x30, 0x28, 0xb5, 0xe1, 0xdc, 0x0a,
        0x75, 0x86, 0x60, 0x2d, 0x25, 0x3c, 0xff, 0xf9,
        0x1b, 0x82, 0x66, 0xbe, 0xa6, 0xd6, 0x1a, 0xb1
    },
    /// key length
    16,
    /// Number of AES blocks in the Text
    2,
    NvDdkSeAesOperationalMode_Cbc
};
AesTestVectorData aesCbcVector3 =
{
    /// Case #3: Encrypting 16 bytes (3 blocks) using AES-CBC with 128-bit key
    {
        /// 128-bit Key
        0x6c, 0x3e, 0xa0, 0x47, 0x76, 0x30, 0xce, 0x21,
        0xa2, 0xce, 0x33, 0x4a, 0xa7, 0x46, 0xc2, 0xcd
    },
    {
        /// 128-bit IV
        0xc7, 0x82, 0xdc, 0x4c, 0x09, 0x8c, 0x66, 0xcb,
        0xd9, 0xcd, 0x27, 0xd8, 0x25, 0x68, 0x2c, 0x81
    },
    /// Plain Text
    "This is a 48-byte message (exactly 3 AES blocks)",
    {
        /// Cipher text
        0xd0, 0xa0, 0x2b, 0x38, 0x36, 0x45, 0x17, 0x53,
        0xd4, 0x93, 0x66, 0x5d, 0x33, 0xf0, 0xe8, 0x86,
        0x2d, 0xea, 0x54, 0xcd, 0xb2, 0x93, 0xab, 0xc7,
        0x50, 0x69, 0x39, 0x27, 0x67, 0x72, 0xf8, 0xd5,
        0x02, 0x1c, 0x19, 0x21, 0x6b, 0xad, 0x52, 0x5c,
        0x85, 0x79, 0x69, 0x5d, 0x83, 0xba, 0x26, 0x84
    },
    ///key length
    16,
    /// Number of AES blocks in the Text
    3,
    NvDdkSeAesOperationalMode_Cbc
};
AesTestVectorData aesCbcVector4 =
{
    /// Case #4: Encrypting 16 bytes (4 blocks) using AES-CBC with 128-bit key
    {
        /// 128-bit Key
        0x56, 0xe4, 0x7a, 0x38, 0xc5, 0x59, 0x89, 0x74,
        0xbc, 0x46, 0x90, 0x3d, 0xba, 0x29, 0x03, 0x49
    },
    {
        /// 128-bit IV
        0x8c, 0xe8, 0x2e, 0xef, 0xbe, 0xa0, 0xda, 0x3c,
        0x44, 0x69, 0x9e, 0xd7, 0xdb, 0x51, 0xb7, 0xd9
    },
    {
        /// Plain Text
        0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
        0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
        0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
        0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
        0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
        0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
        0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf
    },
    {
        /// Cipher text
        0xc3, 0x0e, 0x32, 0xff, 0xed, 0xc0, 0x77, 0x4e,
        0x6a, 0xff, 0x6a, 0xf0, 0x86, 0x9f, 0x71, 0xaa,
        0x0f, 0x3a, 0xf0, 0x7a, 0x9a, 0x31, 0xa9, 0xc6,
        0x84, 0xdb, 0x20, 0x7e, 0xb0, 0xef, 0x8e, 0x4e,
        0x35, 0x90, 0x7a, 0xa6, 0x32, 0xc3, 0xff, 0xdf,
        0x86, 0x8b, 0xb7, 0xb2, 0x9d, 0x3d, 0x46, 0xad,
        0x83, 0xce, 0x9f, 0x9a, 0x10, 0x2e, 0xe9, 0x9d,
        0x49, 0xa5, 0x3e, 0x87, 0xf4, 0xc3, 0xda, 0x55
    },
    /// key length
    16,
    /// Number of AES blocks in the Text
    4,
    NvDdkSeAesOperationalMode_Cbc
};

AesTestVectorData aesCbcVector5 =
{
    {
        0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52, 0xC8, 0x10,
        0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5, 0x62, 0xF8, 0xEA, 0xD2,
        0x52, 0x2C, 0x6B, 0x7B
    },
    {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
    },
    {
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96,
        0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A
    },
    {
        0x4F, 0x02, 0x1D, 0xB2, 0x43, 0xBC, 0x63, 0x3D,
        0x71, 0x78, 0x18, 0x3A, 0x9F, 0xA0, 0x71, 0xE8
    },
    24,
    1,
    NvDdkSeAesOperationalMode_Cbc
};

AesTestVectorData aesCbcVector6 =
{
    {
        0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE,
        0xF0, 0x85, 0x7D, 0x77, 0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61,
        0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4
    },
    {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
    },
    {
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96,
        0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A
    },
    {
        0xF5, 0x8C, 0x4C, 0x04, 0xD6, 0xE5, 0xF1, 0xBA,
        0x77, 0x9E, 0xAB, 0xFB, 0x5F, 0x7B, 0xFB, 0xD6
    },
    32,
    1,
    NvDdkSeAesOperationalMode_Cbc
};

AesTestVectorData aesCbcVector7 =
{
    {
        0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE,
        0xF0, 0x85, 0x7D, 0x77, 0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61,
        0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4
    },
    {
        0x39, 0xF2, 0x33, 0x69, 0xA9, 0xD9, 0xBA, 0xCF,
        0xA5, 0x30, 0xE2, 0x63, 0x04, 0x23, 0x14, 0x61
    },
    {
        0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17, 0xAD,
        0x2B, 0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10
    },
    {
        0xB2, 0xEB, 0x05, 0xE2, 0xC3, 0x9B, 0xE9, 0xFC, 0xDA,
        0x6C, 0x19, 0x07, 0x8C, 0x6A, 0x9D, 0x1B
    },
    32,
    1,
    NvDdkSeAesOperationalMode_Cbc
};
AesTestVectorData aesCbcVector8 =
{
    {
        0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52, 0xC8, 0x10,
        0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5, 0x62, 0xF8, 0xEA, 0xD2,
        0x52, 0x2C, 0x6B, 0x7B
    },
    {
        0x57, 0x1B, 0x24, 0x20, 0x12, 0xFB, 0x7A, 0xE0, 0x7F, 0xA9,
        0xBA, 0xAC, 0x3D, 0xF1, 0x02, 0xE0
    },
    {
        0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17, 0xAD, 0x2B,
        0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10
    },
    {
        0x08, 0xB0, 0xE2, 0x79, 0x88, 0x59, 0x88, 0x81, 0xD9, 0x20,
        0xA9, 0xE6, 0x4F, 0x56, 0x15, 0xCD
    },
    24,
    1,
    NvDdkSeAesOperationalMode_Cbc
};

/// ECB vectors taken from National Institute of Standards and
/// Technology (NIST.)
/// http://csrc.nist.gov/groups/ST/toolkit/examples.html
AesTestVectorData aesEcbVector1 =
{
    {
        /// 128-bit Key
        0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,
        0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C
    },
    {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },
    {
        /// Plain Text
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96,
        0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A,
        0xAE, 0x2D, 0x8A, 0x57, 0x1E, 0x03, 0xAC, 0x9C,
        0x9E, 0xB7, 0x6F, 0xAC, 0x45, 0xAF, 0x8E, 0x51,
        0x30, 0xC8, 0x1C, 0x46, 0xA3, 0x5C, 0xE4, 0x11,
        0xE5, 0xFB, 0xC1, 0x19, 0x1A, 0x0A, 0x52, 0xEF,
        0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17,
        0xAD, 0x2B, 0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10
    },
    {
        /// Cipher text
        0x3A, 0xD7, 0x7B, 0xB4, 0x0D, 0x7A, 0x36, 0x60,
        0xA8, 0x9E, 0xCA, 0xF3, 0x24, 0x66, 0xEF, 0x97,
        0xF5, 0xD3, 0xD5, 0x85, 0x03, 0xB9, 0x69, 0x9D,
        0xE7, 0x85, 0x89, 0x5A, 0x96, 0xFD, 0xBA, 0xAF,
        0x43, 0xB1, 0xCD, 0x7F, 0x59, 0x8E, 0xCE, 0x23,
        0x88, 0x1B, 0x00, 0xE3, 0xED, 0x03, 0x06, 0x88,
        0x7B, 0x0C, 0x78, 0x5E, 0x27, 0xE8, 0xAD, 0x3F,
        0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5D, 0xD4
    },
    /// key length
    16,
    /// Number of AES blocks in the Text
    4,
    NvDdkSeAesOperationalMode_Ecb
};

AesTestVectorData aesEcbVector2 =
{
    {
        0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52, 0xC8, 0x10,
        0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5, 0x62, 0xF8, 0xEA, 0xD2,
        0x52, 0x2C, 0x6B, 0x7B
    },
    {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },
    {
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D,
        0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A
    },
    {
        0xBD, 0x33, 0x4F, 0x1D, 0x6E, 0x45, 0xF2, 0x5F, 0xF7, 0x12,
        0xA2, 0x14, 0x57, 0x1F, 0xA5, 0xCC
    },
    24,
    1,
    NvDdkSeAesOperationalMode_Ecb
};

AesTestVectorData aesEcbVector3 =
{
    {
        0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE,
        0xF0, 0x85, 0x7D, 0x77, 0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61,
        0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4
    },
    {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },
    {
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D,
        0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A
    },
    {
        0xF3, 0xEE, 0xD1, 0xBD, 0xB5, 0xD2, 0xA0, 0x3C, 0x06, 0x4B,
        0x5A, 0x7E, 0x3D, 0xB1, 0x81, 0xF8
    },
    32,
    1,
    NvDdkSeAesOperationalMode_Ecb
};

typedef struct SeRsaTestVectorData_Rec
{
    NvU32 ModulusSizeInBytes;
    NvU32 PubExpSizeInBytes;
    NvU8 PrvExp[SE_TEST_MODULUS_MAX_SIZE];
    NvU8 PubExp[SE_TEST_PUB_EXP_MAX_SIZE];
    NvU8 Modulus[SE_TEST_MODULUS_MAX_SIZE];
    NvU8 PlainMsg[SE_TEST_MODULUS_MAX_SIZE];
} SeRsaTestVectorData;

static NvU8 SeRSAHWOutput[SE_TEST_MODULUS_MAX_SIZE];
static NvU8 SeRSAHWResult[SE_TEST_MODULUS_MAX_SIZE];

static SeRsaTestVectorData *CurTestVec = NULL;

static SeRsaTestVectorData SeRsaTestVec3_Mod2048 =
{
    256,
    4,
    {
     0x42,0xaa,0x67,0x57,0x18,0x1c,0xb1,0x03,0x59,0xb3,0x16,0x35,0x9c,0x1a,0x07,0x97,
     0x0a,0xcf,0x42,0xd7,0xa3,0xbb,0x42,0xa7,0xe3,0x77,0xcb,0xa6,0xd9,0x63,0x03,0xbb,
     0x79,0x15,0xeb,0x88,0xa0,0x2e,0x4f,0x02,0x4d,0xbc,0xbd,0xd4,0xba,0x56,0x7c,0x79,
     0x49,0x94,0xb5,0x6c,0xa2,0xca,0x63,0x66,0x7c,0xa9,0x36,0xb2,0xc6,0xfd,0x4b,0x01,
     0x10,0x75,0xd2,0xab,0x65,0x54,0x7f,0x1a,0xa8,0x1a,0xe9,0xf2,0x77,0x2d,0x55,0x20,
     0x14,0xc7,0x5e,0xa0,0xa3,0x11,0x5c,0x84,0x17,0x31,0x55,0x40,0xb6,0xa0,0x49,0x11,
     0x5d,0xa5,0xad,0x72,0x9c,0xd2,0xc6,0x7e,0xd8,0xf9,0xa2,0x4a,0x2a,0xe4,0x11,0x37,
     0x1d,0xa9,0x9d,0x83,0x86,0x2c,0x0d,0x94,0x82,0x7e,0x12,0x30,0x4f,0xd0,0x53,0xa4,
     0x51,0x12,0xa7,0x72,0x03,0xd9,0xbc,0x7e,0xa1,0xe9,0x31,0xba,0x3f,0x2e,0x8c,0x75,
     0x1b,0x0e,0x08,0xae,0x1a,0xba,0xcb,0xcc,0xce,0xd7,0xcb,0x85,0xcf,0x7f,0x7d,0x40,
     0x6e,0xdc,0x7f,0x32,0x89,0xb2,0x49,0x8c,0xbd,0xec,0xc2,0xbe,0xc9,0x2d,0x4a,0x73,
     0x23,0x63,0x4a,0x65,0x6c,0xe2,0x66,0xa3,0xc3,0x19,0x9f,0x72,0xd9,0x14,0xa2,0xe0,
     0x64,0x75,0x48,0xe4,0x0c,0x4f,0xe7,0xff,0x2f,0x45,0xec,0x63,0xda,0x46,0xb9,0x4e,
     0x69,0x42,0x5f,0x8d,0xfe,0x98,0x64,0xab,0xe3,0x9a,0xf0,0x79,0xc4,0x14,0xe4,0x2a,
     0x66,0x1a,0x6e,0xb0,0x9b,0xa2,0x15,0xfd,0xf2,0xd6,0xb3,0x7c,0xaf,0xa5,0xdd,0x6d,
     0x46,0x48,0x4d,0xd1,0x3c,0xa8,0xf9,0xcb,0x67,0xc9,0xf0,0xd4,0x3a,0xd1,0x92,0x05
    },
    {
     0x11,0x00,0x00,0x00 //public exponent 17
    },
    {
     0xae,0x5b,0x35,0xa8,0xb5,0x37,0x58,0xcd,0xaf,0x85,0x9c,0x8c,0x35,0xcd,0xec,0x77,
     0x57,0x59,0x24,0xf8,0xe7,0x4c,0x38,0x2d,0x3f,0x39,0x4f,0xb4,0x5f,0xef,0x44,0xd6,
     0x9f,0x25,0xa3,0x16,0x8f,0x3e,0x09,0xb7,0x41,0x77,0x7a,0x53,0xbf,0xf5,0xe3,0x15,
     0xd4,0x22,0x78,0x08,0x6e,0xae,0xdc,0x95,0xe3,0x93,0x2c,0x98,0x7e,0x96,0x75,0x65,
     0x3e,0xbd,0xff,0x98,0xe1,0xa1,0xe9,0xf6,0xf2,0xbc,0x8b,0x3f,0x10,0x4f,0x2d,0x67,
     0x98,0xce,0x59,0xf2,0xe5,0x8f,0xde,0x45,0xc6,0x81,0x06,0x5a,0x7b,0x2d,0x0d,0xde,
     0xa6,0x27,0x76,0xdc,0xfc,0x9d,0x69,0x9a,0x86,0x3e,0x1e,0x9a,0x97,0x8f,0x8f,0x7c,
     0x74,0xf6,0xaf,0xa6,0xc1,0x5f,0x85,0xfa,0x90,0x5d,0x6a,0xa5,0xbd,0x0d,0x29,0x88,
     0x07,0x49,0xb1,0x3c,0x1a,0xd0,0x15,0x5b,0xb9,0x07,0x4d,0x8f,0x60,0xe4,0x6e,0x16,
     0xc5,0x89,0x1b,0x3c,0x29,0x5e,0xd5,0xf6,0xc1,0xdb,0x00,0x87,0xc3,0x32,0x07,0xb7,
     0x75,0x15,0x97,0xb5,0x23,0xfe,0xea,0x70,0x71,0xbf,0xd3,0xa1,0x3c,0x08,0x8b,0xd6,
     0xe4,0xe3,0xe4,0xf5,0x85,0x51,0x36,0x54,0x0b,0xc7,0x79,0x10,0x6b,0x99,0xb2,0x08,
     0xc3,0x92,0xf4,0xde,0x6b,0x7a,0xf0,0x96,0xda,0x71,0x07,0x3b,0x4f,0xea,0xee,0xc6,
     0x3a,0x8a,0xfc,0x70,0x2e,0xf9,0x49,0x06,0x2f,0xad,0xbe,0x08,0x94,0xb1,0xd5,0x57,
     0x30,0xff,0xa6,0x31,0x02,0xd3,0xad,0xf9,0xcc,0x82,0x37,0xb4,0xa8,0xbe,0x1e,0x03,
     0xf4,0xc1,0x57,0x45,0xf0,0x44,0xb7,0x73,0x57,0x70,0xf8,0x8e,0xec,0x23,0x09,0x57
    },
    {
     0x00 // need to fill this data with inputdata
    }
};

static SeRsaTestVectorData SeRsaTestVec4_Mod2048 =
{
    256,
    4,
    {
     0x1d,0x0f,0x33,0x9c,0x1e,0x33,0xe4,0x22,0x47,0xeb,0x9a,0x17,0x5e,0x4c,0xfc,0xbe,
     0x8e,0x8e,0xdb,0x7e,0xd1,0x37,0x5e,0xb2,0x35,0x34,0x37,0xf3,0x65,0x52,0x8b,0x79,
     0x1a,0x86,0x45,0xd9,0x17,0xdf,0xac,0x49,0x35,0x93,0xe9,0xb8,0x9f,0xfe,0x50,0x83,
     0xa3,0x5b,0x14,0x01,0x67,0xc7,0xcf,0x6e,0x50,0x98,0x87,0x6e,0xbf,0xc3,0xbe,0x3b,
     0x8a,0x74,0xff,0xee,0xd0,0x45,0xa6,0xfe,0x7d,0xca,0x17,0x35,0x2d,0x62,0x87,0x91,
     0x44,0x22,0x64,0x53,0x26,0x42,0xa5,0x0b,0xa1,0x15,0x81,0x0f,0x14,0x87,0x82,0x4f,
     0xc6,0x5b,0xe9,0x24,0xd4,0xc4,0xe6,0xef,0x16,0x5f,0xaf,0xc4,0x6e,0x97,0xed,0x3f,
     0x68,0xd3,0xc7,0xf1,0x20,0x3a,0x96,0x54,0x6d,0x64,0xe7,0x1b,0x9f,0x82,0x31,0x96,
     0x64,0xfb,0x00,0xc8,0xac,0x58,0x58,0xba,0x7b,0x16,0xe1,0x29,0xcc,0xc5,0x85,0x6e,
     0x1f,0x7c,0x45,0x6c,0xb6,0x51,0x6c,0x87,0x39,0x57,0x80,0x19,0x81,0xd5,0x1c,0x57,
     0x29,0xc2,0x93,0x57,0xab,0x9c,0x7b,0xf5,0x24,0xd6,0xcb,0x0a,0xf5,0x3b,0x20,0x73,
     0xd4,0x59,0x3a,0xaf,0x7e,0x3b,0x4d,0x8f,0x96,0xaf,0x45,0x80,0xd4,0xc7,0x5a,0xb0,
     0x94,0xd0,0xa9,0x9e,0x7b,0x85,0x4a,0xde,0xd2,0xf7,0x18,0x45,0xc8,0x2b,0xf4,0xe0,
     0x89,0xc7,0x99,0x3d,0xe5,0x21,0x9b,0x78,0xdf,0xee,0x34,0x4f,0x55,0x78,0xb2,0x39,
     0xdd,0xbc,0xc0,0xa8,0xe1,0x60,0xe8,0xc4,0x07,0x64,0x26,0xda,0x73,0xf2,0xf7,0x7e,
     0x66,0xd7,0x4f,0xde,0x7c,0xe7,0x31,0xce,0xd1,0x58,0x06,0x83,0xe5,0x20,0x46,0x37
    },
    {
     0x03,0x00,0x00,0x00 //public exponent 3
    },
    {
     0xae,0x5b,0x35,0xa8,0xb5,0x37,0x58,0xcd,0xaf,0x85,0x9c,0x8c,0x35,0xcd,0xec,0x77,
     0x57,0x59,0x24,0xf8,0xe7,0x4c,0x38,0x2d,0x3f,0x39,0x4f,0xb4,0x5f,0xef,0x44,0xd6,
     0x9f,0x25,0xa3,0x16,0x8f,0x3e,0x09,0xb7,0x41,0x77,0x7a,0x53,0xbf,0xf5,0xe3,0x15,
     0xd4,0x22,0x78,0x08,0x6e,0xae,0xdc,0x95,0xe3,0x93,0x2c,0x98,0x7e,0x96,0x75,0x65,
     0x3e,0xbd,0xff,0x98,0xe1,0xa1,0xe9,0xf6,0xf2,0xbc,0x8b,0x3f,0x10,0x4f,0x2d,0x67,
     0x98,0xce,0x59,0xf2,0xe5,0x8f,0xde,0x45,0xc6,0x81,0x06,0x5a,0x7b,0x2d,0x0d,0xde,
     0xa6,0x27,0x76,0xdc,0xfc,0x9d,0x69,0x9a,0x86,0x3e,0x1e,0x9a,0x97,0x8f,0x8f,0x7c,
     0x74,0xf6,0xaf,0xa6,0xc1,0x5f,0x85,0xfa,0x90,0x5d,0x6a,0xa5,0xbd,0x0d,0x29,0x88,
     0x07,0x49,0xb1,0x3c,0x1a,0xd0,0x15,0x5b,0xb9,0x07,0x4d,0x8f,0x60,0xe4,0x6e,0x16,
     0xc5,0x89,0x1b,0x3c,0x29,0x5e,0xd5,0xf6,0xc1,0xdb,0x00,0x87,0xc3,0x32,0x07,0xb7,
     0x75,0x15,0x97,0xb5,0x23,0xfe,0xea,0x70,0x71,0xbf,0xd3,0xa1,0x3c,0x08,0x8b,0xd6,
     0xe4,0xe3,0xe4,0xf5,0x85,0x51,0x36,0x54,0x0b,0xc7,0x79,0x10,0x6b,0x99,0xb2,0x08,
     0xc3,0x92,0xf4,0xde,0x6b,0x7a,0xf0,0x96,0xda,0x71,0x07,0x3b,0x4f,0xea,0xee,0xc6,
     0x3a,0x8a,0xfc,0x70,0x2e,0xf9,0x49,0x06,0x2f,0xad,0xbe,0x08,0x94,0xb1,0xd5,0x57,
     0x30,0xff,0xa6,0x31,0x02,0xd3,0xad,0xf9,0xcc,0x82,0x37,0xb4,0xa8,0xbe,0x1e,0x03,
     0xf4,0xc1,0x57,0x45,0xf0,0x44,0xb7,0x73,0x57,0x70,0xf8,0x8e,0xec,0x23,0x09,0x57
    },
    {
     0x00 // need to fill this data with input data
    }
};

static SeRsaTestVectorData SeRsaTestVec2_Mod1536 =
{
    192,
    4,
    {
     0x29,0xf8,0xf9,0x3c,0x94,0x43,0xed,0x7c,0x55,0xf2,0x4b,0x89,0x86,0x92,0x7f,0x04,
     0x2c,0xe6,0x9d,0x8d,0xb3,0xb2,0x3c,0x20,0xc9,0x59,0x14,0x4c,0x84,0xdc,0xf4,0x8e,
     0x36,0xaf,0x19,0x15,0xfd,0xb9,0x8c,0x3f,0xef,0xe4,0x47,0xe5,0x8c,0xf4,0xe1,0x1c,
     0x53,0x67,0xb1,0x55,0x2c,0xad,0xd2,0x51,0x4b,0xf4,0xbd,0x7c,0x52,0x6b,0xa6,0xd0,
     0xc4,0x3e,0xaa,0x58,0x4c,0x93,0xc0,0x13,0x9f,0xb1,0xf4,0xcd,0x67,0xab,0x0c,0xb5,
     0x25,0xf3,0x44,0x2d,0x39,0x23,0x1c,0xf7,0x18,0x52,0x32,0xfb,0x16,0x50,0x70,0xbc,
     0xd6,0x35,0x62,0xd0,0xf9,0x26,0x68,0x91,0xba,0x38,0xab,0x83,0x57,0x39,0x88,0x63,
     0x71,0xa4,0x25,0xa0,0x28,0x99,0xa4,0x53,0xd6,0x7d,0xab,0xd7,0x83,0xfa,0xea,0x95,
     0xc3,0xda,0xcf,0x7c,0xd5,0x58,0x6f,0x67,0xf0,0x1c,0x2e,0xcc,0x87,0xc6,0x8a,0xd4,
     0x27,0x30,0x96,0xd0,0x47,0x32,0x4c,0x46,0x9b,0x5c,0x9b,0x44,0x99,0x77,0xaa,0x4e,
     0xc8,0x11,0xe4,0x46,0xce,0xef,0xc6,0x63,0x90,0x6c,0x73,0xc7,0xd9,0x61,0x7a,0x84,
     0xc1,0x42,0xa4,0xdc,0xe8,0x5b,0x5f,0x0d,0x0a,0xca,0x7d,0xc3,0xf0,0xf3,0x21,0x25
    },
    {
     0x11,0x00,0x00,0x00 //public exponent 17
    },
    {
     0xed,0xd8,0x2f,0x01,0xf2,0xd6,0x41,0xc0,0x91,0xb2,0x56,0xb5,0xfa,0x93,0x7a,0x6c,
     0xfe,0x70,0x27,0x78,0x4f,0x9c,0xaa,0x0f,0x1f,0xa3,0x73,0x06,0xf0,0xe4,0x14,0x7b,
     0x35,0xe0,0x38,0xd1,0xf3,0x1b,0x70,0x14,0xfa,0x0d,0x97,0x6a,0x1e,0xc0,0xfb,0xa0,
     0x83,0x4b,0x97,0x8d,0x52,0x83,0xa7,0xcc,0xae,0x6a,0xdc,0x6b,0x28,0x62,0x06,0x9f,
     0x02,0xb8,0x6f,0xf4,0x5c,0x9a,0x95,0xc4,0x88,0xf0,0x6b,0x36,0xa0,0xc9,0x48,0x02,
     0x81,0xb7,0xd7,0xaa,0xee,0x71,0xa4,0x22,0xdf,0x27,0x20,0xe4,0x29,0x1d,0x29,0x85,
     0x56,0x58,0x93,0x00,0xc1,0x9d,0x9d,0x8b,0x4e,0xc2,0x06,0x86,0x29,0xeb,0xc4,0xe6,
     0xb1,0x56,0x87,0xdb,0x64,0x89,0x62,0x23,0xcf,0xa0,0x61,0x8f,0x4e,0x66,0xaf,0x6d,
     0x53,0xa3,0x2b,0x03,0xaa,0x48,0x16,0x49,0x43,0x32,0x06,0xac,0x88,0xdb,0x99,0x13,
     0xfa,0xb8,0x64,0x0a,0xc9,0x33,0x08,0xc2,0xf2,0x03,0x5b,0x84,0xc5,0xa7,0x1a,0x71,
     0x14,0x04,0xb7,0xd2,0xaf,0xfd,0x94,0xa2,0x4b,0x7b,0x7d,0x20,0xbb,0x98,0xab,0x09,
     0xc5,0x66,0x67,0xf6,0xb5,0x17,0x59,0x0f,0x46,0x9b,0x51,0x31,0x1b,0x38,0x84,0x8d
    },
    {
     0x00 // need to fill this data with input data
    }
};
static SeRsaTestVectorData SeRsaTestVec1_Mod1024 =
{
   128,
   4,
   {
    0x38,0x3a,0x6f,0x19,0xe1,0xea,0x27,0xfd,0x08,0xc7,0xfb,0xc3,0xbf,0xa6,0x84,0xbd,
    0x63,0x29,0x88,0x8c,0x0b,0xbe,0x4c,0x98,0x62,0x5e,0x71,0x81,0xf4,0x11,0xcf,0xd0,
    0x85,0x31,0x44,0xa3,0x03,0x94,0x04,0xdd,0xa4,0x1b,0xce,0x2e,0x31,0xd5,0x88,0xec,
    0x57,0xc0,0xe1,0x48,0x14,0x6f,0x0f,0xa6,0x5b,0x39,0x00,0x8b,0xa5,0x83,0x5f,0x82,
    0x9b,0xa3,0x5a,0xe2,0xf1,0x55,0xd6,0x1b,0x8a,0x12,0x58,0x1b,0x99,0xc9,0x27,0xfd,
    0x2f,0x22,0x25,0x2c,0x5e,0x73,0xcb,0xa4,0xa6,0x10,0xdb,0x39,0x73,0xe0,0x19,0xee,
    0x0f,0x95,0x13,0x0d,0x43,0x19,0xed,0x41,0x34,0x32,0xf2,0xe5,0xe2,0x0d,0x52,0x15,
    0xcd,0xd2,0x7c,0x21,0x64,0x20,0x6b,0x3f,0x80,0xed,0xee,0x51,0x93,0x8a,0x25,0xc1
   },
   {
    0x01,0x00,0x01,0x00 //public exponent 65537
   },
   {
    0xbc,0xb4,0x7b,0x2e,0x0d,0xaf,0xcb,0xa8,0x1f,0xf2,0xa2,0xb5,0xcb,0x11,0x5c,0xa7,
    0xe7,0x57,0x18,0x4c,0x9d,0x72,0xbc,0xdc,0xda,0x70,0x7a,0x14,0x6b,0x3b,0x4e,0x29,
    0x98,0x9d,0xdc,0x66,0x0b,0xd6,0x94,0x86,0x5b,0x93,0x2b,0x71,0xca,0x24,0xa3,0x35,
    0xcf,0x4d,0x33,0x9c,0x71,0x91,0x83,0xe6,0x22,0x2e,0x4c,0x9e,0xa6,0x87,0x5a,0xcd,
    0x52,0x8a,0x49,0xba,0x21,0x86,0x3f,0xe0,0x81,0x47,0xc3,0xa4,0x7e,0x41,0x99,0x0b,
    0x51,0xa0,0x3f,0x77,0xd2,0x21,0x37,0xf8,0xd7,0x4c,0x43,0xa5,0xa4,0x5f,0x4e,0x9e,
    0x18,0xa2,0xd1,0x5d,0xb0,0x51,0xdc,0x89,0x38,0x5d,0xb9,0xcf,0x83,0x74,0xb6,0x3a,
    0x8c,0xc8,0x81,0x13,0x71,0x0e,0x6d,0x81,0x79,0x07,0x5b,0x7d,0xc7,0x9e,0xe7,0x6b
   },
   {
    0x00,0x48,0xf6,0x2a,0x43,0x89,0xf4,0x2f,0x7b,0x4b,0xb1,0x31,0x05,0x3d,0x6c,0x88,
    0xa9,0x94,0xdb,0x20,0x75,0xb9,0x12,0xcc,0xbe,0x3e,0xa7,0xdc,0x61,0x17,0x14,0xf1,
    0x4e,0x07,0x5c,0x10,0x48,0x58,0xf2,0xf6,0xe6,0xcf,0xd6,0xab,0xde,0xdf,0x01,0x5a,
    0x82,0x1d,0x03,0x60,0x8b,0xf4,0xeb,0xa3,0x16,0x9a,0x67,0x25,0xec,0x42,0x2c,0xd9,
    0x06,0x94,0x98,0xb5,0x51,0x5a,0x96,0x08,0xae,0x7c,0xc3,0x0e,0x3d,0x2e,0xcf,0xc1,
    0xdb,0x68,0x25,0xf3,0xe9,0x96,0xce,0x9a,0x50,0x92,0x92,0x6b,0xc1,0xcf,0x61,0xaa,
    0x42,0xd7,0xf2,0x40,0xe6,0xf7,0xaa,0x0e,0xdb,0x38,0xbf,0x81,0xaa,0x92,0x9d,0x66,
    0xbb,0x5d,0x89,0x00,0x18,0x08,0x84,0x58,0x72,0x0d,0x72,0xd5,0x69,0x24,0x7b,0x00
   }
};

static SeRsaTestVectorData SeRsaTestVec1_Mod1536 =
{
    192,
    4,
    {
     0x1e,0x51,0x78,0x86,0xbf,0x2c,0x51,0x8c,0xe7,0x34,0xb1,0xe9,0xd1,0x5f,0x8a,0xd5,
     0x06,0xa5,0x99,0x0f,0x55,0x97,0xba,0xdd,0x59,0xee,0x6f,0x27,0x34,0x04,0x2e,0x44,
     0x4a,0x19,0x2e,0xa0,0x64,0xad,0x04,0x5b,0x55,0xff,0x75,0x9a,0xd6,0xde,0xe5,0x62,
     0x1c,0xf8,0xdb,0xa4,0xba,0x08,0x76,0x7b,0xdb,0xcb,0x20,0x7c,0x60,0xbf,0x27,0xa8,
     0x9d,0x95,0x92,0xd4,0x57,0xc3,0x8d,0xa5,0xc6,0xd5,0xfa,0xaf,0xc1,0x1d,0xf1,0x70,
     0x59,0x50,0x97,0x76,0xb1,0x16,0x49,0xb0,0xa7,0x17,0x7a,0x83,0x97,0xef,0x1e,0x11,
     0xef,0x81,0x55,0x6a,0x07,0xb7,0xc0,0xff,0x8b,0xc5,0xb4,0xd4,0xd5,0x8b,0x78,0xe2,
     0x19,0xba,0x23,0x1c,0xcf,0x1f,0x4f,0xfd,0x28,0xad,0x1f,0x67,0xad,0xe7,0xd2,0x46,
     0x80,0xe5,0xc8,0x04,0x37,0xfa,0x56,0x2b,0x8a,0xe9,0xf0,0x36,0x5d,0xb5,0xf1,0x8e,
     0xcb,0xa8,0x1e,0x3b,0xc4,0xe6,0x6c,0x29,0x6b,0x48,0x6a,0x93,0xb7,0x1a,0x5d,0x85,
     0x09,0x8c,0x00,0x36,0x8e,0x91,0x05,0x80,0x30,0x64,0x42,0x23,0x66,0x13,0xf1,0x30,
     0x92,0x87,0xef,0xef,0x8a,0x40,0xdf,0xa7,0xb7,0x31,0x85,0x21,0x7b,0x2b,0x6c,0xb1
    },
    {
     0x01,0x00,0x01,0x00 //public exponent 65537
    },
    {
     0xa1,0x80,0xac,0x4b,0x51,0x86,0xdf,0x0b,0x7b,0x1c,0xb7,0xa9,0x57,0x46,0xa5,0xaf,
     0x41,0x1e,0xfa,0x16,0xd1,0xae,0xd1,0x24,0x68,0xde,0x15,0xb7,0x47,0xa0,0xff,0x32,
     0xc2,0x15,0xdd,0x08,0xa9,0x92,0x87,0xb7,0x78,0x8e,0x91,0x54,0x2d,0x90,0x59,0x94,
     0x0e,0x4b,0x61,0x0f,0x74,0x1c,0xb9,0xc7,0xa8,0x6b,0x4a,0xa0,0xb4,0x5a,0x7b,0x38,
     0x45,0x0b,0x6e,0xa2,0x50,0x70,0xf9,0x8e,0x70,0xbb,0x78,0x33,0xae,0xcd,0x18,0x34,
     0xa8,0xe5,0x91,0xbe,0xa2,0x07,0xec,0x55,0xd4,0x03,0xc7,0x62,0x13,0xbd,0x9f,0x70,
     0x0c,0xe2,0x5a,0xdb,0x26,0x5a,0xd3,0x83,0xc4,0x43,0xed,0x7a,0x87,0xa5,0x7d,0x7e,
     0x5c,0x64,0x95,0xc3,0x2f,0x51,0xae,0x0c,0xc8,0x78,0x43,0x52,0xcf,0xc5,0x6f,0x20,
     0x29,0xcd,0xd3,0x23,0x39,0x3a,0x15,0x31,0x93,0xf4,0x1f,0x04,0x08,0xcd,0xcd,0x5b,
     0x34,0x4d,0x20,0x94,0x24,0x13,0xbd,0x97,0xc3,0xb0,0xc0,0x4a,0xb5,0x84,0xf6,0x85,
     0xb0,0xe7,0x96,0xce,0x9b,0x5a,0x0c,0xf6,0x44,0x41,0xf0,0x0e,0xe7,0x58,0x6c,0x62,
     0xfe,0x84,0x42,0xd5,0x22,0xf7,0xc6,0xe3,0xf3,0x14,0xf8,0x4d,0x55,0x70,0x39,0xb9
    },
    {
     0x00 // need to fill this data with  input data
    }
};

static SeRsaTestVectorData SeRsaTestVec1_Mod2048 =
{
    256,
    4,
    {
     0x2f,0x21,0xb0,0x1b,0xe9,0x4d,0xde,0x7f,0x5e,0xc1,0x8a,0x38,0x17,0xf3,0x27,0x4e,
     0xbb,0x37,0xf9,0xc2,0x6c,0xc8,0xc0,0xd1,0x16,0x9c,0x05,0x79,0x4e,0x7f,0xe3,0x3a,
     0xe3,0x1d,0xab,0xfd,0x09,0xd3,0x88,0x45,0xf0,0x94,0xa0,0xfa,0xb4,0x58,0xf1,0x4c,
     0x97,0x30,0xbe,0x6d,0x22,0xd0,0xe6,0x99,0xee,0x73,0x73,0xa1,0xbd,0xe0,0xb7,0xfa,
     0x03,0xe7,0x84,0x53,0x67,0x82,0xee,0xe1,0x30,0x9d,0x70,0x81,0x97,0xbe,0x35,0x5b,
     0x62,0x4e,0xd3,0xbb,0x4a,0xe2,0x66,0x4a,0x53,0x72,0xde,0xf6,0x70,0x82,0xbf,0x62,
     0x33,0xab,0x6e,0x2e,0xea,0x7a,0xd8,0xa3,0xe5,0xe7,0x9e,0xf5,0xe1,0xfc,0xec,0x41,
     0x5e,0x6f,0xa9,0x23,0x79,0x8f,0x05,0xbd,0xa0,0xca,0x9a,0x3b,0xde,0xdb,0x45,0xf4,
     0xd7,0x81,0xef,0x1a,0x4f,0x50,0x75,0xcd,0x9b,0xb3,0x99,0x63,0x5d,0xa3,0xe9,0xa6,
     0x88,0x0e,0xd0,0x21,0xa7,0x50,0xbc,0x98,0x06,0xaf,0x81,0xfb,0xff,0xcd,0x4a,0xce,
     0xaf,0x80,0x4e,0xc7,0x68,0x08,0xae,0x18,0x67,0x15,0xc7,0x72,0xca,0xa9,0x61,0xa8,
     0x62,0x99,0x1c,0x67,0xca,0x8b,0xff,0xef,0x6b,0x34,0x08,0x7b,0x44,0xdb,0x5b,0x59,
     0xab,0xce,0x09,0x31,0x77,0x47,0xfc,0x75,0x25,0x2f,0x17,0x05,0x26,0x0b,0x13,0xdd,
     0x62,0xcc,0xbc,0x74,0x50,0x91,0xf3,0xc1,0xb6,0x4f,0x59,0x03,0x1d,0x34,0x0c,0x73,
     0x62,0xa0,0xe1,0x06,0x6a,0xb0,0x55,0x4d,0x46,0x6f,0x20,0x9a,0x3c,0xf5,0x1b,0xc6,
     0x4b,0x3c,0x70,0xc3,0xce,0x52,0xf4,0x13,0xd8,0x1b,0x22,0x8f,0xa3,0x1d,0x9e,0xfd
    },
    {
     0x01,0x00,0x01,0x00 //public exponent 65537
    },
    {
     0xd9,0x5b,0x71,0xc9,0xdf,0xee,0x45,0x3b,0xa1,0xb1,0xa7,0xde,0x2c,0x1f,0x0b,0x0a,
     0x67,0x57,0x9e,0xe9,0x1d,0x1d,0x3a,0xd9,0x7e,0x48,0x18,0x29,0xb8,0x6e,0xda,0xc7,
     0x50,0xc4,0x8e,0x12,0xa8,0xcd,0xb0,0x26,0xc8,0x2f,0x27,0x3d,0xaf,0xc2,0x22,0x00,
     0x9f,0x0d,0xb3,0xb0,0x8b,0x2d,0xb1,0x0a,0x69,0xc4,0xb2,0xdd,0xda,0xae,0xce,0xac,
     0x1b,0x0c,0x86,0x26,0x82,0xee,0xf2,0x94,0xe5,0x79,0xf5,0x5a,0xab,0x87,0x1b,0xc0,
     0xa7,0xee,0xab,0xc9,0x23,0xc9,0xe8,0x0d,0xdd,0xc2,0x2e,0xc0,0xa2,0x70,0x02,0xae,
     0xe6,0xa5,0xba,0x66,0x39,0x7f,0x41,0x2b,0xba,0xf5,0xfb,0x4e,0xaf,0x66,0xa1,0xa0,
     0xf8,0x2e,0xaf,0x68,0x27,0x19,0x8c,0xaf,0x49,0xb3,0x47,0x25,0x8b,0x12,0x83,0xe8,
     0xcb,0xb1,0x0d,0xa2,0x83,0x7f,0x6e,0xcc,0x34,0x90,0xc7,0x28,0xfe,0x92,0x7f,0x44,
     0x45,0x5a,0x6f,0x19,0x4f,0x37,0x76,0xbf,0x79,0x15,0x1d,0x9a,0xd7,0xe2,0xda,0xf7,
     0x70,0xb3,0x7d,0x12,0x62,0x7c,0xc0,0xc5,0xfb,0x62,0x48,0x4f,0x46,0x25,0x8d,0x9c,
     0xe2,0xc1,0x1b,0x26,0x25,0x6d,0x09,0xcb,0x41,0x2f,0x8d,0x8f,0x8f,0x1f,0xe9,0x1b,
     0xb9,0x4a,0xc2,0x7d,0xe6,0xd2,0x6a,0x83,0xa8,0x43,0x9e,0x51,0xb3,0x5d,0xbe,0xe4,
     0x6b,0x3b,0x8f,0xf9,0x91,0xd6,0x67,0xbb,0x53,0xee,0xee,0x85,0xff,0x16,0x52,0xc8,
     0x98,0x1f,0x14,0x1d,0x47,0xc8,0x20,0x57,0x91,0xce,0xf5,0xb3,0x2d,0x71,0x8d,0xdc,
     0x08,0x2e,0xd0,0xdd,0x54,0x28,0x26,0x41,0x6b,0x22,0x71,0x06,0x4e,0xf4,0x37,0xa9
    },
    {
     0x00 // need to fill this data with input data
    }
};

static SeRsaTestVectorData SeRsaTestVec2_Mod1024 =
{
    128,
    4,
    {
     0x24,0xe2,0x62,0xc1,0xf0,0x02,0x86,0x23,0xdb,0xf6,0x00,0xa6,0xff,0xf7,0x8c,0x05,
     0xb4,0x06,0x61,0xf1,0xb4,0x0a,0x01,0x98,0xf3,0x68,0x47,0x2c,0x90,0x6a,0xc9,0xcd,
     0x5d,0xa8,0x3a,0xda,0xfa,0x30,0xb2,0x22,0xeb,0x3a,0x3b,0xc3,0xb5,0xe5,0xd3,0x82,
     0xe1,0xb6,0x8a,0x00,0xb8,0xc0,0x44,0xd8,0x80,0xb3,0x5d,0x69,0x1d,0xe4,0x25,0xcd,
     0xb7,0xc7,0x8b,0xac,0xdf,0x93,0xf6,0xcc,0xd6,0x76,0xb2,0xe5,0xde,0xfe,0x3f,0x48,
     0x85,0xd3,0xd1,0x98,0x05,0x25,0xb7,0x1d,0x25,0xc2,0xb6,0x89,0xf6,0x32,0x4f,0x81,
     0xf6,0x29,0x9e,0x85,0x0a,0x97,0xdb,0x8e,0xfb,0xa0,0xb8,0xd2,0x5b,0x74,0x49,0x1e,
     0x2e,0x3a,0xbc,0xc1,0xd3,0xd6,0x10,0x43,0xb9,0xf4,0x35,0x13,0xad,0x38,0xfd,0x47
    },
    {
     0xf7,0x08,0x4e,0x00
    },
    {
     0xc6,0x25,0x79,0x9e,0x10,0x09,0x2a,0x86,0x67,0x17,0xfa,0xbf,0x39,0x99,0xaf,0x0c,
     0x5e,0x20,0x9d,0xcb,0x4c,0x5c,0xf3,0xe2,0x47,0x47,0x94,0x3e,0x3d,0x77,0x23,0x92,
     0xf9,0xce,0x0d,0x19,0xb5,0x2c,0x75,0xc3,0xfa,0x55,0x6c,0xbd,0xac,0x09,0x20,0xdd,
     0x7a,0x72,0x2b,0x5a,0x27,0x90,0x26,0xfb,0x65,0x40,0xe6,0xa8,0x00,0x45,0x49,0xf5,
     0xd8,0x61,0x22,0x65,0x06,0x7f,0x74,0x1c,0xdc,0xe2,0xd0,0x04,0xcc,0xa0,0x8e,0x0e,
     0xa5,0xd8,0x62,0xea,0x2c,0xa1,0x14,0x20,0x8f,0x45,0xad,0x16,0xff,0x43,0x61,0x33,
     0x25,0xe4,0xc8,0xf6,0x06,0x95,0x01,0xdb,0x06,0x4f,0x3f,0xcc,0xeb,0xfe,0x1f,0xb5,
     0x5d,0x46,0x7c,0xa9,0xdb,0xeb,0xba,0xb4,0xb0,0xd7,0x51,0x5f,0xd9,0x9e,0x0c,0x9b
    },
    {
     0x12,0x48,0xf6,0x2a,0x43,0x89,0xf4,0x2f,0x7b,0x4b,0xb1,0x31,0x05,0x3d,0x6c,0x88,
     0xa9,0x94,0xdb,0x20,0x75,0xb9,0x12,0xcc,0xbe,0x3e,0xa7,0xdc,0x61,0x17,0x14,0xf1,
     0x4e,0x07,0x5c,0x10,0x48,0x58,0xf2,0xf6,0xe6,0xcf,0xd6,0xab,0xde,0xdf,0x01,0x5a,
     0x82,0x1d,0x03,0x60,0x8b,0xf4,0xeb,0xa3,0x16,0x9a,0x67,0x25,0xec,0x42,0x2c,0xd9,
     0x06,0x94,0x98,0xb5,0x51,0x5a,0x96,0x08,0xae,0x7c,0xc3,0x0e,0x3d,0x2e,0xcf,0xc1,
     0xdb,0x68,0x25,0xf3,0xe9,0x96,0xce,0x9a,0x50,0x92,0x92,0x6b,0xc1,0xcf,0x61,0xaa,
     0x42,0xd7,0xf2,0x40,0xe6,0xf7,0xaa,0x0e,0xdb,0x38,0xbf,0x81,0xaa,0x92,0x9d,0x66,
     0xbb,0x5d,0x89,0x00,0x18,0x08,0x84,0x58,0x72,0x0d,0x72,0xd5,0x69,0x24,0x7b,0x0c
    }
};

static SeRsaTestVectorData SeRsaTestVec2_Mod2048 =
{
    256,
    4,
    {
     0x49,0xe5,0x78,0x6b,0xb4,0xd3,0x32,0xf9,0x45,0x86,0x32,0x7b,0xde,0x08,0x88,0x75,
     0x37,0x9b,0x75,0xd1,0x28,0x48,0x8f,0x08,0xe5,0x74,0xab,0x47,0x15,0x30,0x2a,0x87,
     0xee,0xa5,0x2d,0x4c,0x4a,0x23,0xd8,0xb9,0x7a,0xf7,0x94,0x48,0x04,0x33,0x7c,0x5f,
     0x55,0xe1,0x6b,0xa9,0xff,0xaf,0xc0,0xc9,0xfd,0x9b,0x88,0xec,0xa4,0x43,0xf3,0x9b,
     0x79,0x67,0x17,0x0d,0xdb,0x8c,0xe7,0xdd,0xb9,0x3c,0x60,0x87,0xc8,0x06,0x6c,0x4a,
     0x95,0x53,0x8a,0x44,0x1b,0x9d,0xc8,0x0d,0xc9,0xf7,0x81,0x00,0x54,0xfd,0x1e,0x5c,
     0x9d,0x02,0x50,0xc9,0x78,0xbb,0x2d,0x74,0x8a,0xbe,0x1e,0x94,0x65,0xd7,0x1a,0x81,
     0x65,0xd3,0x12,0x6d,0xce,0x5d,0xb2,0xad,0xac,0xc0,0x03,0xe9,0x06,0x2b,0xa3,0x7a,
     0x54,0xb6,0x3e,0x5f,0x49,0xa4,0xea,0xfe,0xbd,0x7e,0x4b,0xf5,0xb0,0xa7,0x96,0xc2,
     0xb3,0xa9,0x50,0xfa,0x09,0xc7,0x98,0xd3,0xfa,0x3e,0x86,0xc4,0xb6,0x2c,0x33,0xba,
     0x93,0x65,0xed,0xa0,0x54,0xe5,0xfe,0x74,0xa4,0x1f,0x21,0xb5,0x95,0x02,0x6a,0xcf,
     0x10,0x93,0xc9,0x0a,0x8c,0x71,0x72,0x2f,0x91,0xaf,0x1e,0xd2,0x9a,0x41,0xa2,0x44,
     0x9a,0x32,0x0f,0xc7,0xba,0x31,0x20,0xe3,0xe8,0xc3,0xe4,0x24,0x0c,0x04,0x92,0x5c,
     0xc6,0x98,0xec,0xd6,0x6c,0x7c,0x90,0x6b,0xdf,0x24,0x0a,0xda,0xd9,0x72,0xb4,0xdf,
     0xf4,0x86,0x9d,0x40,0x0b,0x5d,0x13,0xe3,0x3e,0xeb,0xa3,0x8e,0x07,0x5e,0x87,0x2b,
     0x0e,0xd3,0xe9,0x1c,0xc9,0xc2,0x83,0x86,0x7a,0x4f,0xfc,0x39,0x01,0xd2,0x06,0x9f
    },
    {
     0x4f,0xc9,0x86,0x00
    },
    {
     0xc5,0x06,0x2b,0x58,0xd8,0x53,0x9c,0x76,0x5e,0x1e,0x5d,0xba,0xf1,0x4c,0xf7,0x5d,
     0xd5,0x6c,0x2e,0x13,0x10,0x5f,0xec,0xfd,0x1a,0x93,0x0b,0xbb,0x59,0x48,0xff,0x32,
     0x8f,0x12,0x6a,0xbe,0x77,0x93,0x59,0xca,0x59,0xbc,0xa7,0x52,0xc3,0x08,0xd2,0x81,
     0x57,0x3b,0xc6,0x17,0x8b,0x6c,0x0f,0xef,0x7d,0xc4,0x45,0xe4,0xf8,0x26,0x43,0x04,
     0x37,0xb9,0xf9,0xd7,0x90,0x58,0x1d,0xe5,0x74,0x9c,0x2c,0xb9,0xcb,0x26,0xd4,0x2b,
     0x2f,0xee,0x15,0xb6,0xb2,0x6f,0x09,0xc9,0x96,0x70,0x33,0x64,0x23,0xb8,0x6b,0xc5,
     0xbe,0xc7,0x11,0x13,0x15,0x7b,0xe2,0xd9,0x44,0xd7,0xff,0x3e,0xeb,0xff,0xb2,0x84,
     0x13,0x14,0x3e,0xa3,0x67,0x55,0xdb,0x0a,0xe6,0x2f,0xf5,0xb7,0x24,0xee,0xcb,0x3d,
     0x31,0x6b,0x6b,0xac,0x67,0xe8,0x9c,0xac,0xd8,0x17,0x19,0x37,0xe2,0xab,0x19,0xbd,
     0x35,0x3a,0x89,0xac,0xea,0x8c,0x36,0xf8,0x1c,0x89,0xa6,0x20,0xd5,0xfd,0x2e,0xff,
     0xea,0x89,0x66,0x01,0xc7,0xf9,0xda,0xca,0x7f,0x03,0x3f,0x63,0x5a,0x3a,0x94,0x33,
     0x31,0xd1,0xb1,0xb4,0xf5,0x28,0x87,0x90,0xb5,0x3a,0xf3,0x52,0xf1,0x12,0x1c,0xa1,
     0xbe,0xf2,0x05,0xf4,0x0d,0xc0,0x12,0xc4,0x12,0xb4,0x0b,0xdd,0x27,0x58,0x5b,0x94,
     0x64,0x66,0xd7,0x5f,0x7e,0xe0,0xa7,0xf9,0xd5,0x49,0xb4,0xbe,0xce,0x6f,0x43,0xac,
     0x3e,0xe6,0x5f,0xe7,0xfd,0x37,0x12,0x33,0x59,0xd9,0xf1,0xa8,0x50,0xad,0x45,0x0a,
     0xaf,0x5c,0x94,0xeb,0x11,0xde,0xa3,0xfc,0x0f,0xc6,0xe9,0x85,0x6b,0x18,0x05,0xef
    },
    {
     0x00 // need to fill this data with input data
    }
};

static SeRsaTestVectorData SeRsaTestVec1_Mod512 =
{
    64,
    4,
    {
        0x88, 0x13, 0xc8, 0xa0, 0x3c, 0x6a, 0xf5, 0x88, 0xb5, 0x2a, 0x42, 0xcc,
        0x29, 0xda, 0x69, 0x4b, 0x6a, 0x62, 0x25, 0x8a, 0xf5, 0x70, 0x07, 0xae,
        0x6d, 0x99, 0x85, 0x87, 0xf0, 0x58, 0x7e, 0xcc, 0x83, 0xd4, 0x51, 0x5a,
        0xda, 0x39, 0x62, 0xcf, 0xa1, 0x1a, 0x89, 0x44, 0x43, 0x29, 0x7b, 0x9b,
        0x9b, 0xaa, 0xc1, 0xca, 0x1f, 0xf9, 0xa6, 0x61, 0x9f, 0xf1, 0x8a, 0x79,
        0x20, 0x2c, 0xf0, 0xf9
    },
    {
        0x01, 0x00, 0x01, 0x00 //public exponent 65537
    },
    {
        0xa0, 0x2e, 0x6d, 0x00, 0xc3, 0x73, 0xf3, 0x4e, 0xc3, 0xa9, 0xd4, 0xc7,
        0x99, 0x11, 0xbb, 0x23, 0x49, 0xfe, 0xd4, 0xec, 0xe3, 0xe0, 0xbc, 0xeb,
        0x93, 0x93, 0x84, 0x6d, 0x84, 0x6e, 0xa9, 0xdb, 0x20, 0xe2, 0x31, 0xda,
        0x6a, 0xe6, 0x59, 0x2c, 0x05, 0x2a, 0xdd, 0x4c, 0x7d, 0x88, 0x1c, 0x4e,
        0xc1, 0x82, 0xdb, 0xb6, 0xfe, 0x6b, 0xc1, 0x69, 0xa3, 0x39, 0x8c, 0xa7,
        0xe8, 0xbc, 0xe0, 0x07
    },
    {
        0x00 // need to fill this data with input data
    }
};

typedef struct AesTestVectorData_Rec1
{
    NvU8 Key[AES_KEY_LENGTH_BYTES];
    NvU8 Iv[AES_IV_LENGTH_BYTES];
    NvU8 PlainText[AES_TEXT_MSG_LENGTH_BYTES];
    NvU8 CipherText[AES_TEXT_MSG_LENGTH_BYTES];
    NvU8 NofBlocks;
} AesTestVectorData1;

static AesTestVectorData1 s_ZeroKeyVectorKeySchedulerSupported =
{
    {   // 128-bit Key
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },
    {   // 128-bit IV
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },
    {   // Plain Text
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
    },
    {   // Cipher text
        0x7A, 0xCA, 0x0F, 0xD9, 0xBC, 0xD6, 0xEC, 0x7C,
        0x9F, 0x97, 0x46, 0x66, 0x16, 0xE6, 0xA2, 0x82
    },
    // Number of AES blocks in the Text
    1
};


static NvBool DataCompare(NvU8 *SrcBuffer, NvU8 *DstBuffer, NvU32 Size, NvBool PrintDiff)
{
    NvU32 i = 0;
    while ((i < Size) && (SrcBuffer[i] == DstBuffer[i]))
        i++;
    if (i == Size)
        return NV_FALSE;
    else
        return NV_TRUE;
}



static NvError PerformCmacOperation(NvDdkBlockDevHandle SeHandle,
        NvU8* Key, NvU32 KeyLen, NvU8 *pSrcBuf, NvU8 *pDstBuf, NvU32 SrcBufSize,
        NvBool IsFirstChunk, NvBool IsLastChunk)
{
    NvError e = NvSuccess;
    NvDdkSeAesComputeCmacInInfo CmacInInfo;
    NvDdkSeAesComputeCmacOutInfo CmacOutInfo;
    NvDdkSeAesKeyInfo KeyInfo;

    CmacInInfo.Key = Key;
    CmacInInfo.KeyLen = KeyLen;
    CmacInInfo.pBuffer = pSrcBuf;
    CmacInInfo.BufSize = SrcBufSize;
    CmacInInfo.IsFirstChunk = IsFirstChunk;
    CmacInInfo.IsLastChunk  = IsLastChunk;
    CmacInInfo.IsSbkKey = NV_FALSE;

    if (IsFirstChunk)
    {
        // Select Key
        KeyInfo.KeyType = NvDdkSeAesKeyType_UserSpecified;
        KeyInfo.KeyLength = KeyLen;
        NvOsMemcpy(KeyInfo.Key, Key, KeyLen);
        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_SelectKey,
                    sizeof(NvDdkSeAesKeyInfo),
                    0,
                    (const void *)&KeyInfo,
                    NULL));
    }
    if (IsLastChunk)
    {
        CmacOutInfo.pCMAC = pDstBuf;
        CmacOutInfo.CMACLen = 16;
    }
    NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                SeHandle,
                NvDdkSeAesBlockDevIoctlType_CalculateCMAC,
                sizeof(NvDdkSeAesComputeCmacInInfo),
                sizeof(NvDdkSeAesComputeCmacOutInfo),
                (const void *)&CmacInInfo,
                (void *)&CmacOutInfo));
fail:
    return e;
}

NvError NvSeAesVerifyTest(NvBDKTest_TestPrivData priv_data)
{
    NvBool b;
    char *test = "NvSeAesVerifyTest";
    char *suite = "se";
    NvError e = NvSuccess;
    NvDdkBlockDevHandle SeHandle;
    NvDdkSeAesOperation OpInfo;
    NvDdkSeAesKeyInfo KeyInfo;
    NvDdkSeAesProcessBufferInfo PbInfo;
    NvDdkSeAesSetIvInfo SetIvInfo;
    NvU8 CmacHash[16];
    NvU8 EncryptBuffer[64];
    NvU8 DecryptBuffer[64];
    AesTestVectorData *pAesVec[11];
    CmacTestVectorData *pCmacVec[5];
    NvU32 i;

    pAesVec[0] = &aesCbcVector1;
    pAesVec[1] = &aesCbcVector2;
    pAesVec[2] = &aesCbcVector3;
    pAesVec[3] = &aesCbcVector4;
    pAesVec[4] = &aesCbcVector5;
    pAesVec[5] = &aesCbcVector6;
    pAesVec[6] = &aesCbcVector7;
    pAesVec[7] = &aesCbcVector8;
    pAesVec[8] = &aesEcbVector1;
    pAesVec[9] = &aesEcbVector2;
    pAesVec[10] = &aesEcbVector3;

    for (i = 0; i < 11; i++)
    {
        /// Encryption
        /// Open Se block device
        NV_CHECK_ERROR_CLEANUP(NvDdkSeBlockDevOpen(0, 0, &SeHandle));
        /// select operation
        OpInfo.OpMode = pAesVec[i]->OpMode;
        OpInfo.IsEncrypt = NV_TRUE;
        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_SelectOperation,
                    sizeof(NvDdkSeAesOperation),
                    0,
                    (const void *)&OpInfo,
                    NULL));
        /// Set Iv
        SetIvInfo.pIV = pAesVec[i]->Iv;
        SetIvInfo.VectorSize = 16;
        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_SetIV,
                    sizeof(NvDdkSeAesSetIvInfo),
                    0,
                    (const void *)&SetIvInfo,
                    NULL));
        /// Select key
        KeyInfo.KeyType = NvDdkSeAesKeyType_UserSpecified;
        KeyInfo.KeyLength = pAesVec[i]->KeyLen;
        NvOsMemcpy(KeyInfo.Key, pAesVec[i]->Key, pAesVec[i]->KeyLen);
        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_SelectKey,
                    sizeof(NvDdkSeAesKeyInfo),
                    0,
                    (const void *)&KeyInfo,
                    NULL));
        /// process buffer
        PbInfo.pSrcBuffer = pAesVec[i]->PlainText;
        PbInfo.pDstBuffer = EncryptBuffer;
        PbInfo.SrcBufSize = pAesVec[i]->NoOfBlocks * 16;
        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_ProcessBuffer,
                    sizeof(NvDdkSeAesProcessBufferInfo),
                    0,
                    (const void *)&PbInfo,
                    NULL));
        if (!NvOsMemcmp(EncryptBuffer, pAesVec[i]->CipherText, pAesVec[i]->NoOfBlocks * 16))
        {
            e=NvSuccess;
            TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\nTest Failed\n");
            NvOsDebugPrintf("\nEncryption :Test vector %d Passed\n", i);
        }
        else
        {
            e=(!NvSuccess);
            TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\nTest Failed\n");
            NvOsDebugPrintf("\nEncryption :Test vector %d failed\n", i);
        }
        /// Decryption
        /// Select Operation
        OpInfo.IsEncrypt = NV_FALSE;
        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_SelectOperation,
                    sizeof(NvDdkSeAesOperation),
                    0,
                    (const void *)&OpInfo,
                    NULL));
        /// Set IV
        SetIvInfo.pIV = pAesVec[i]->Iv;
        SetIvInfo.VectorSize = 16;
        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_SetIV,
                    sizeof(NvDdkSeAesSetIvInfo),
                    0,
                    (const void *)&SetIvInfo,
                    NULL));
        PbInfo.pSrcBuffer = pAesVec[i]->CipherText;
        PbInfo.pDstBuffer = DecryptBuffer;
        PbInfo.SrcBufSize = pAesVec[i]->NoOfBlocks * 16;
        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_ProcessBuffer,
                    sizeof(NvDdkSeAesProcessBufferInfo),
                    0,
                    (const void *)&PbInfo,
                    NULL));
        if (!NvOsMemcmp(DecryptBuffer, pAesVec[i]->PlainText,
                         pAesVec[i]->NoOfBlocks * 16))
        {
            e=NvSuccess;
            TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\nTest Failed\n");
            NvOsDebugPrintf("\nDecryption : Test vector %d Passed\n", i);
        }
        else
        {
            e=(!NvSuccess);
            TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\nTest Failed\n");
            NvOsDebugPrintf("\nDecryption : Test vector %d failed\n", i);
        }
        SeHandle->NvDdkBlockDevClose(SeHandle);
    }

    /// Testing  Cmac
    pCmacVec[0] = &cmacTestVector1;
    pCmacVec[1] = &cmacTestVector2;
    pCmacVec[2] = &cmacTestVector3;
    pCmacVec[3] = &cmacTestVector4;
    pCmacVec[4] = &cmacTestVector5;

    for (i = 0; i < 5; i++)
    {
        /// open Se block device
        NV_CHECK_ERROR_CLEANUP(NvDdkSeBlockDevOpen(0, 0, &SeHandle));
        if(i<3)
        {
            NV_CHECK_ERROR_CLEANUP(PerformCmacOperation(SeHandle, pCmacVec[i]->Key,
                    16, pCmacVec[i]->PlainText,CmacHash, pCmacVec[i]->MsgLen,
                    NV_TRUE, NV_TRUE));
            if (!NvOsMemcmp(CmacHash, pCmacVec[i]->Cmac, 16))
            {
                e=NvSuccess;
                TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\nCmac 128Test Failed\n");
                NvOsDebugPrintf("\nCMAC: Test vector %d Passed\n", i);
            }
            else
            {
                e=(!NvSuccess);
                TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\nCmac 128Test Failed\n");
                NvOsDebugPrintf("\nCMAC: Test vector %d failed\n", i);
            }
        }
        else if(i==3)
        {
            NV_CHECK_ERROR_CLEANUP(PerformCmacOperation(SeHandle, pCmacVec[i]->Key,
                    24, pCmacVec[i]->PlainText,CmacHash, pCmacVec[i]->MsgLen,
                    NV_TRUE, NV_TRUE));
            if (!NvOsMemcmp(CmacHash, pCmacVec[i]->Cmac, 16))
            {
                e=NvSuccess;
                TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\nCmac 192Test Failed\n");
                NvOsDebugPrintf("\nCMAC: Test vector %d Passed\n", i);
            }
            else
            {
                e=(!NvSuccess);
                TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\nCmac 192Test Failed\n");
                NvOsDebugPrintf("\nCMAC: Test vector %d failed\n", i);
            }
        }
        else
        {
            NV_CHECK_ERROR_CLEANUP(PerformCmacOperation(SeHandle, pCmacVec[i]->Key,
                    32, pCmacVec[i]->PlainText,CmacHash, pCmacVec[i]->MsgLen,
                    NV_TRUE, NV_TRUE));

            if (!NvOsMemcmp(CmacHash, pCmacVec[i]->Cmac, 16))
            {
                e=NvSuccess;
                TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\nCmac 256Test Failed\n");
                NvOsDebugPrintf("\nCMAC: Test vector %d Passed\n", i);
            }
            else
            {
                e=(!NvSuccess);
                TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\nCmac 256Test Failed\n");
                NvOsDebugPrintf("\nCMAC: Test vector %d failed\n", i);
            }
        }

        SeHandle->NvDdkBlockDevClose(SeHandle);
    }
    /// Testing Cmac calling multiple times.
    /// Testing 40B vector.
    NV_CHECK_ERROR_CLEANUP(NvDdkSeBlockDevOpen(0, 0, &SeHandle));

    NV_CHECK_ERROR_CLEANUP(PerformCmacOperation(SeHandle, pCmacVec[1]->Key,
                16, pCmacVec[1]->PlainText, NULL, 16,
                NV_TRUE, NV_FALSE));

    NV_CHECK_ERROR_CLEANUP(PerformCmacOperation(SeHandle, pCmacVec[1]->Key,
                16, &pCmacVec[1]->PlainText[16], NULL, 16,
                NV_FALSE, NV_FALSE));

    NV_CHECK_ERROR_CLEANUP(PerformCmacOperation(SeHandle, pCmacVec[1]->Key,
                16, &pCmacVec[1]->PlainText[32], CmacHash, pCmacVec[1]->MsgLen - 32,
                NV_FALSE, NV_TRUE));

    if (!NvOsMemcmp(CmacHash, pCmacVec[1]->Cmac, 16))
    {
        NvOsDebugPrintf("\nCMAC: Test vector 1 with multiple iterations Passed\n");
    }
    else
    {
        NvOsDebugPrintf("\nCMAC: Test vector 1 with multiple iterations failed\n");
    }
    SeHandle->NvDdkBlockDevClose(SeHandle);

    /// Testing 64B vector.
    NV_CHECK_ERROR_CLEANUP(NvDdkSeBlockDevOpen(0, 0, &SeHandle));

    NV_CHECK_ERROR_CLEANUP(PerformCmacOperation(SeHandle, pCmacVec[2]->Key,
                16, pCmacVec[2]->PlainText, NULL, 16,
                NV_TRUE, NV_FALSE));

    NV_CHECK_ERROR_CLEANUP(PerformCmacOperation(SeHandle, pCmacVec[2]->Key,
                16, &pCmacVec[2]->PlainText[16], NULL, 16,
                NV_FALSE, NV_FALSE));

    NV_CHECK_ERROR_CLEANUP(PerformCmacOperation(SeHandle, pCmacVec[2]->Key,
                16, &pCmacVec[2]->PlainText[32], NULL, 16,
                NV_FALSE, NV_FALSE));

    NV_CHECK_ERROR_CLEANUP(PerformCmacOperation(SeHandle, pCmacVec[2]->Key,
                16, &pCmacVec[2]->PlainText[48], CmacHash, pCmacVec[2]->MsgLen - 48,
                NV_FALSE, NV_TRUE));

    if (!NvOsMemcmp(CmacHash, pCmacVec[2]->Cmac, 16))
    {
        NvOsDebugPrintf("\nCMAC: Test vector 2 with multiple iterations Passed\n");
    }
    else
    {
        NvOsDebugPrintf("\nCMAC: Test vector 2 with multiple iterations failed\n");
    }

    SeHandle->NvDdkBlockDevClose(SeHandle);
fail:
    return e;
}

//sha tests

typedef struct SeTestVecData_Rec
{
    NvDdkSeShaEncMode EncMode;
    NvU32 InDataSize;
    NvU8 InData[500];
    NvU32 OutDataSize;
    NvU8 OutData[IN_BYTES(NvDdkSeShaResultSize_Sha512)];
}SeTestVecData;

static NvU8 HashOutput[IN_BYTES(NvDdkSeShaResultSize_Sha512)];

static SeTestVecData Sha1Vector =
{
    NvDdkSeShaOperatingMode_Sha1,
    56,
    "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
    IN_BYTES(NvDdkSeShaResultSize_Sha1),
    {0x84,0x98,0x3e,0x44,0x1c,0x3b,0xd2,0x6e,0xba,0xae,0x4a,0xa1,0xf9,0x51,
     0x29,0xe5,0xe5,0x46,0x70,0xf1}
};

static SeTestVecData Sha224Vector =
{
    NvDdkSeShaOperatingMode_Sha224,
    56,
    "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
    IN_BYTES(NvDdkSeShaResultSize_Sha224),
    {0x75,0x38,0x8b,0x16,0x51,0x27,0x76,0xcc,0x5d,0xba,0x5d,0xa1,0xfd,0x89,
     0x01,0x50,0xb0,0xc6,0x45,0x5c,0xb4,0xf5,0x8b,0x19,0x52,0x52,0x25,0x25}
};

static SeTestVecData Sha256Vector =
{
    NvDdkSeShaOperatingMode_Sha256,
    56,
    "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
    IN_BYTES(NvDdkSeShaResultSize_Sha256),
    {0x24,0x8d,0x6a,0x61,0xd2,0x06,0x38,0xb8,0xe5,0xc0,0x26,0x93,0x0c,0x3e,
     0x60,0x39,0xa3,0x3c,0xe4,0x59,0x64,0xff,0x21,0x67,0xf6,0xec,0xed,0xd4,
     0x19,0xdb,0x06,0xc1}
};

static SeTestVecData Sha384Vector =
{
    NvDdkSeShaOperatingMode_Sha384,
    112,
    "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnh"\
    "ijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu",
    IN_BYTES(NvDdkSeShaResultSize_Sha384),
    {0x09,0x33,0x0c,0x33,0xf7,0x11,0x47,0xe8,0x3d,0x19,0x2f,0xc7,0x82,0xcd,
     0x1b,0x47,0x53,0x11,0x1b,0x17,0x3b,0x3b,0x05,0xd2,0x2f,0xa0,0x80,0x86,
     0xe3,0xb0,0xf7,0x12,0xfc,0xc7,0xc7,0x1a,0x55,0x7e,0x2d,0xb9,0x66,0xc3,
     0xe9,0xfa,0x91,0x74,0x60,0x39}
};

static SeTestVecData Sha512Vector =
{
    NvDdkSeShaOperatingMode_Sha512,
    112,
    "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnh"\
    "ijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu",
    IN_BYTES(NvDdkSeShaResultSize_Sha512),
    {0x8e,0x95,0x9b,0x75,0xda,0xe3,0x13,0xda,0x8c,0xf4,0xf7,0x28,0x14,0xfc,
     0x14,0x3f,0x8f,0x77,0x79,0xc6,0xeb,0x9f,0x7f,0xa1,0x72,0x99,0xae,0xad,
     0xb6,0x88,0x90,0x18,0x50,0x1d,0x28,0x9e,0x49,0x00,0xf7,0xe4,0x33,0x1b,
     0x99,0xde,0xc4,0xb5,0x43,0x3a,0xc7,0xd3,0x29,0xee,0xb6,0xdd,0x26,0x54,
     0x5e,0x96,0xe5,0x5b,0x87,0x4b,0xe9,0x09}
};


static NvError PerformSha(SeTestVecData *ptestvec)
{
    NvError e = NvSuccess;
    NvDdkBlockDevHandle sehandle;
    NvDdkSeShaInitInfo seinitinfo;
    NvDdkSeShaUpdateArgs seupdateinfo;
    NvDdkSeShaFinalInfo sefinalinfo;
    NvRmDeviceHandle hRmDevice = NULL;

    e = NvRmOpen(&hRmDevice, 0);
    if(e!=NvSuccess)
        goto fail;

    // Initialize SE engine
    e = NvDdkSeBlockDevInit(hRmDevice);
    if(e!=NvSuccess)
        goto fail;

    //  open the SE device
    if (NvSuccess != (NvDdkBlockDevMgrDeviceOpen(NvDdkBlockDevMgrDeviceId_Se,
                                                 0,
                                                 0,
                                                 &sehandle)))
    {
        NvOsDebugPrintf("\nSE device opening failed\n");
        goto fail;
    }

    seinitinfo.SeSHAEncMode = ptestvec->EncMode;
    seinitinfo.TotalMsgSizeInBytes = ptestvec->InDataSize;
    //  Init the SHA
    e = sehandle->NvDdkBlockDevIoctl(
                                sehandle,
                                NvDdkSeBlockDevIoctlType_SHAInit,
                                sizeof(NvDdkSeShaInitInfo),
                                0,
                                &seinitinfo,
                                0);
    if (e != NvSuccess)
    {
        NvOsDebugPrintf("\nSE SHA init failed\n");
        goto fail;
    }

    //  Updating the SHA-1 engine hash value
    seupdateinfo.InputBufSize = ptestvec->InDataSize;
    seupdateinfo.SrcBuf = ptestvec->InData;
    //  Update SHA
    e = sehandle->NvDdkBlockDevIoctl(
                                sehandle,
                                NvDdkSeBlockDevIoctlType_SHAUpdate,
                                sizeof(NvDdkSeShaUpdateArgs),
                                0,
                                &seupdateinfo,
                                0);
    if (e != NvSuccess)
    {
        NvOsDebugPrintf("\nSE SHA Update failed\n");
        goto fail;
    }

    sefinalinfo.HashSize = ptestvec->OutDataSize;
    sefinalinfo.OutBuf = HashOutput;
    //  Final SHA
    e = sehandle->NvDdkBlockDevIoctl(
                                sehandle,
                                NvDdkSeBlockDevIoctlType_SHAFinal,
                                0,
                                0,
                                0,
                                &sefinalinfo);
    if (e != NvSuccess)
    {
        NvOsDebugPrintf("\nSE SHA Final failed\n");
        goto fail;
    }

fail:
    //  Close the device
    sehandle->NvDdkBlockDevClose(sehandle);
    NvDdkSeBlockDevDeinit();
    NvRmClose(hRmDevice);
    return e;
}

static NvError Sha1Test(void)
{
    NvError e = NvSuccess;
    NvBool b;
    char *test = "NvSeShaVerifyTest";
    char *suite = "se";
    e = PerformSha(&Sha1Vector);
    TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\nSha1Test Failed\n");
    if(e!=NvSuccess)
        NvOsDebugPrintf("\nSha1Test failed\n");
    else
        NvOsDebugPrintf("\nSha1Test passed\n");
    return e;
fail:
    NvOsDebugPrintf("\nSha1Test failed\n");
    return e;
}

static NvError Sha224Test(void)
{
    char *test = "NvSeShaVerifyTest";
    char *suite = "se";
    NvError e = NvSuccess;
    NvBool b;
    e = PerformSha(&Sha224Vector);
    TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\nSha224Test Failed\n");
    if(e!=NvSuccess)
        NvOsDebugPrintf("\nSha224Test failed\n");
    else
        NvOsDebugPrintf("\nSha224Test passed\n");
    return e;
fail:
    NvOsDebugPrintf("\nSha1Test failed\n");
    return e;
}

static NvError Sha256Test(void)
{
    char *test = "NvSeShaVerifyTest";
    char *suite = "se";
    NvError e = NvSuccess;
    NvBool b;
    e = PerformSha(&Sha256Vector);
    TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\nSha256Test Failed\n");
    if(e!=NvSuccess)
        NvOsDebugPrintf("\nSha256Test failed\n");
    else
        NvOsDebugPrintf("\nSha256Test passed\n");
    return e;
fail:
    NvOsDebugPrintf("\nSha1Test failed\n");
    return e;
}

static NvError Sha384Test(void)
{
    char *test = "NvSeShaVerifyTest";
    char *suite = "se";
    NvError e = NvSuccess;
    NvBool b;
    e = PerformSha(&Sha384Vector);
    TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\nSha384Test Failed\n");
    if(e!=NvSuccess)
        NvOsDebugPrintf("\nSha384Test failed\n");
    else
        NvOsDebugPrintf("\nSha384Test passed\n");
    return e;
fail:
    NvOsDebugPrintf("\nSha1Test failed\n");
    return e;
}

static NvError Sha512Test(void)
{
    char *test = "NvSeShaVerifyTest";
    char *suite = "se";
    NvError e = NvSuccess;
    NvBool b;
    e = PerformSha(&Sha512Vector);
    TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\nSha512Test Failed\n");
    if(e!=NvSuccess)
        NvOsDebugPrintf("\nSha512Test failed\n");
    else
        NvOsDebugPrintf("\nSha512Test passed\n");
    return e;
fail:
    NvOsDebugPrintf("\nSha1Test failed\n");
    return e;
}


void NvSeShaVerifyTest(void)
{
    Sha1Test();
    Sha224Test();
    Sha256Test();
    Sha384Test();
    Sha512Test();
}


static NvError swap(NvU8 *Str, NvU32 one, NvU32 two)
{
    NvU8 temp;

    if (Str == NULL)
        return NvError_InvalidAddress;
    temp = Str[one];
    Str[one] = Str[two];
    Str[two] = temp;
    return NvSuccess;
}

static NvError ChangeEndian(NvU8 *Str, NvU32 Size)
{
    NvU32 i;
    NvError e = NvSuccess;

    if (Str == NULL)
        return NvError_InvalidAddress;

    for (i = 0; i < Size; i += 4)
    {
        if ((e = swap(Str, i, i + 3)) != NvSuccess)
            return e;
        if ((e = swap(Str, i + 1, i + 2)) != NvSuccess)
            return e;
    }
    return NvSuccess;
}

static NvError FillIpData(NvU8 *Str, NvU32 Size)
{
    NvU32 i;
    if (Str == NULL)
        return NvError_InvalidAddress;

    for (i = 0; i < Size; i++)
    {
        Str[Size - i - 1] = (i % 255);
    }
    return NvSuccess;
}

static NvError PerformModularExponentiation(NvBool IsPrvKeyUsed, NvU32 KeySlot)
{
    NvError e = NvSuccess;
    NvDdkBlockDevHandle sehandle;
    NvSeRsaKeyDataInfo RSAKeyDataInfo;
    NvSeRsaOutDataInfo RSAOutDataInfo;
    NvRmDeviceHandle hRmDevice = NULL;
    char *test = "NvSeRsaVerifyTest";
    char *suite = "se";
    NvBool b;

    e = NvRmOpen(&hRmDevice, 0);
    if(e!=NvSuccess)
        goto fail;
    /* Initialize SE engine */
    e = NvDdkSeBlockDevInit(hRmDevice);
    if(e!=NvSuccess)
        goto fail;

    /* open the SE device */
    if (NvSuccess != (NvDdkBlockDevMgrDeviceOpen(NvDdkBlockDevMgrDeviceId_Se,
                                                 0,
                                                 0,
                                                 &sehandle)))
    {
        e=!NvSuccess;
        TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\nSE device opening failed\n");
        NvOsDebugPrintf("\nSE device opening failed\n");
        goto fail;
    }

    /* Fill Input arguments */
    RSAKeyDataInfo.ModulusSizeInBytes = CurTestVec->ModulusSizeInBytes;
    RSAKeyDataInfo.Modulus = CurTestVec->Modulus;
    RSAKeyDataInfo.KeySlot = KeySlot;
    if (IsPrvKeyUsed)
    {
        RSAKeyDataInfo.InputBuf = CurTestVec->PlainMsg;
        RSAKeyDataInfo.ExponentSizeInBytes = CurTestVec->ModulusSizeInBytes;
        RSAKeyDataInfo.Exponent = CurTestVec->PrvExp;
        RSAOutDataInfo.OutputBuf = SeRSAHWOutput;
    }
    else
    {
        RSAKeyDataInfo.InputBuf = SeRSAHWOutput;
        RSAKeyDataInfo.ExponentSizeInBytes = CurTestVec->PubExpSizeInBytes;
        RSAKeyDataInfo.Exponent = CurTestVec->PubExp;
        RSAOutDataInfo.OutputBuf = SeRSAHWResult;
    }

    /* Call Driver API to perform Modular Exponentiation */
    e = sehandle->NvDdkBlockDevIoctl(
                              sehandle,
                              NvDdkSeBlockDevIoctlType_RSAModularExponentiation,
                              sizeof(NvSeRsaKeyDataInfo),
                              sizeof(NvSeRsaOutDataInfo),
                              &RSAKeyDataInfo,
                              &RSAOutDataInfo);
    if (e != NvSuccess)
    {
        TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\nRSA ModExpo operation Failed\n");
        NvOsDebugPrintf("\nSE RSA ModExpo operation failed\n");
        goto fail;
    }

fail:
    /*  Close the device */
    sehandle->NvDdkBlockDevClose(sehandle);
    NvDdkSeBlockDevDeinit();
    NvRmClose(hRmDevice);
    return e;
}

static void SeRsaTest(void)
{
    NvError e = NvSuccess;
    NvU32 i = 0;
    char *test = "NvSeRsaVerifyTest";
    char *suite = "se";
    NvBool b;

    NvOsDebugPrintf("\n*** Testing with SeRsaTestVec1_Mod512 Test vector,\
                    Keyslot 1,this test should pass****\n");
    CurTestVec = &SeRsaTestVec1_Mod512;
    e = ChangeEndian(CurTestVec->Modulus, 256);
    if(e!=NvSuccess)
        goto fail;
    e = ChangeEndian(CurTestVec->PrvExp, 256);
    if(e!=NvSuccess)
        goto fail;
    e = FillIpData(CurTestVec->PlainMsg, 64);
    if(e!=NvSuccess)
        goto fail;
    CurTestVec->PlainMsg[0] = 0x00;
    e = PerformModularExponentiation(1, 0);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(0, 0);
    if(e!=NvSuccess)
        goto fail;
    if(NvOsMemcmp(CurTestVec->PlainMsg,SeRSAHWResult,
                     CurTestVec->ModulusSizeInBytes))
        goto fail;
    TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\n*** Passed with test vector :SeRsaTestVec1_Mod512******\n");
    NvOsDebugPrintf("\n*** Passed with test vector :SeRsaTestVec1_Mod512******\n");
    NvOsDebugPrintf("\n*** Testing with SeRsaTestVec1_Mod2048 Test vector,\
                    Keyslot 1,this test should pass****\n");
    CurTestVec = &SeRsaTestVec1_Mod2048;
    e = ChangeEndian(CurTestVec->Modulus, 256);
    if(e!=NvSuccess)
        goto fail;
    e = ChangeEndian(CurTestVec->PrvExp, 256);
    if(e!=NvSuccess)
        goto fail;
    e = FillIpData(CurTestVec->PlainMsg, 256);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(1, 0);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(0, 0);
    if(e!=NvSuccess)
        goto fail;
    if(NvOsMemcmp(CurTestVec->PlainMsg,SeRSAHWResult,
                     CurTestVec->ModulusSizeInBytes))
        goto fail;
    TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\n*** Passed with test vector :SeRsaTestVec1_Mod2048******\n");
    NvOsDebugPrintf("\n*** Passed with test vector :SeRsaTestVec1_Mod2048******\n");

    NvOsDebugPrintf("\n*** Testing with SeRsaTestVec2_Mod2048 Test vector,\
                    Keyslot 2, this test should pass****\n");
    CurTestVec = &SeRsaTestVec2_Mod2048;
    e = ChangeEndian(CurTestVec->Modulus, 256);
    if(e!=NvSuccess)
        goto fail;
    e = ChangeEndian(CurTestVec->PrvExp, 256);
    if(e!=NvSuccess)
        goto fail;
    e = FillIpData(CurTestVec->PlainMsg, 256);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(1, 1);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(0, 1);
    if(e!=NvSuccess)
        goto fail;
    if(NvOsMemcmp(CurTestVec->PlainMsg,SeRSAHWResult,
                     CurTestVec->ModulusSizeInBytes))
        goto fail;
    TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\n*** Passed with test vector :SeRsaTestVec2_Mod2048******\n");
    NvOsDebugPrintf("\n*** Passed with test vector :SeRsaTestVec2_Mod2048******\n");

    NvOsDebugPrintf("\n*** Testing with SeRsaTestVec3_Mod2048 Test vector,\
                    Keyslot 2, this test should pass****\n");
    CurTestVec = &SeRsaTestVec3_Mod2048;
    e = ChangeEndian(CurTestVec->Modulus, 256);
    if(e!=NvSuccess)
        goto fail;
    e = ChangeEndian(CurTestVec->PrvExp, 256);
    if(e!=NvSuccess)
        goto fail;
    e = FillIpData(CurTestVec->PlainMsg, 256);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(1, 1);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(0, 1);
    if(e!=NvSuccess)
        goto fail;
    if(NvOsMemcmp(CurTestVec->PlainMsg,SeRSAHWResult,
                     CurTestVec->ModulusSizeInBytes))
        goto fail;
    TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\n*** Passed with test vector :SeRsaTestVec3_Mod2048******\n");
    NvOsDebugPrintf("\n*** Passed with test vector :SeRsaTestVec3_Mod2048******\n");

    NvOsDebugPrintf("\n*** Testing with SeRsaTestVec4_Mod2048 Test vector,\
                    Keyslot 2, this test should pass****\n");
    CurTestVec = &SeRsaTestVec4_Mod2048;
    e = ChangeEndian(CurTestVec->Modulus, 256);
    if(e!=NvSuccess)
        goto fail;
    e = ChangeEndian(CurTestVec->PrvExp, 256);
    if(e!=NvSuccess)
        goto fail;
    e = FillIpData(CurTestVec->PlainMsg, 256);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(1, 1);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(0, 1);
    if(e!=NvSuccess)
        goto fail;
    if(NvOsMemcmp(CurTestVec->PlainMsg,SeRSAHWResult,
                     CurTestVec->ModulusSizeInBytes))
        goto fail;
    TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\n*** Passed with test vector :SeRsaTestVec4_Mod2048******\n");
    NvOsDebugPrintf("\n*** Passed with test vector :SeRsaTestVec4_Mod2048******\n");

    NvOsDebugPrintf("\n*** Testing with SeRsaTestVec1_Mod1536 Test vector,\
                    Keyslot 1, this test should pass****\n");
    CurTestVec = &SeRsaTestVec1_Mod1536;
    e = ChangeEndian(CurTestVec->Modulus, 192);
    if(e!=NvSuccess)
        goto fail;
    e = ChangeEndian(CurTestVec->PrvExp, 192);
    if(e!=NvSuccess)
        goto fail;
    e = FillIpData(CurTestVec->PlainMsg, 192);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(1, 0);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(0, 0);
    if(e!=NvSuccess)
        goto fail;
    if(NvOsMemcmp(CurTestVec->PlainMsg,SeRSAHWResult,
                     CurTestVec->ModulusSizeInBytes))
        goto fail;
    TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\n*** Passed with test vector :SeRsaTestVec1_Mod1536******\n");
    NvOsDebugPrintf("\n*** Passed with test vector :SeRsaTestVec1_Mod1536******\n");

    NvOsDebugPrintf("\n*** Testing with SeRsaTestVec2_Mod1536 Test vector,\
                    Keyslot 1, this test should pass****\n");
    CurTestVec = &SeRsaTestVec2_Mod1536;
    e = ChangeEndian(CurTestVec->Modulus, 192);
    if(e!=NvSuccess)
        goto fail;
    e = ChangeEndian(CurTestVec->PrvExp, 192);
    if(e!=NvSuccess)
        goto fail;
    e = FillIpData(CurTestVec->PlainMsg, 192);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(1, 0);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(0, 0);
    if(e!=NvSuccess)
        goto fail;
    if(NvOsMemcmp(CurTestVec->PlainMsg,SeRSAHWResult,
                     CurTestVec->ModulusSizeInBytes))
        goto fail;
    TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\n*** Passed with test vector :SeRsaTestVec2_Mod1536******\n");
    NvOsDebugPrintf("\n*** Passed with test vector :SeRsaTestVec2_Mod1536******\n");

    NvOsDebugPrintf("\n*** Testing with SeRsaTestVec1_Mod1024 Test vector,\
                    keyslot 1 this test should pass****\n");
    CurTestVec = &SeRsaTestVec1_Mod1024;
    e = ChangeEndian(CurTestVec->Modulus, 128);
    if(e!=NvSuccess)
        goto fail;
    e = ChangeEndian(CurTestVec->PrvExp, 128);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(1, 0);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(0, 0);
    if(e!=NvSuccess)
        goto fail;
    if(NvOsMemcmp(CurTestVec->PlainMsg,SeRSAHWResult,
                     CurTestVec->ModulusSizeInBytes))
        goto fail;
    TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\n*** Passed with test vector :SeRsaTestVec1_Mod1024******\n");
    NvOsDebugPrintf("\n*** Passed with test vector :SeRsaTestVec1_Mod1024******\n");

    NvOsDebugPrintf("\n*** Testing with SeRsaTestVec2_Mod1024 Test vector,\
                    keyslot 2 this test should pass****\n");
    CurTestVec = &SeRsaTestVec2_Mod1024;
    e = ChangeEndian(CurTestVec->Modulus, 128);
    if(e!=NvSuccess)
        goto fail;
    e = ChangeEndian(CurTestVec->PrvExp, 128);
    if(e!=NvSuccess)
        goto fail;
    e = FillIpData(CurTestVec->PlainMsg, 128);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(1, 1);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(0, 1);
    if(e!=NvSuccess)
        goto fail;
    if(NvOsMemcmp(CurTestVec->PlainMsg,SeRSAHWResult,
                     CurTestVec->ModulusSizeInBytes))
        goto fail;
    TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\n*** Passed with test vector :SeRsaTestVec2_Mod1024******\n");
    NvOsDebugPrintf("\n*** Passed with test vector :SeRsaTestVec2_Mod1024******\n");

    NvOsDebugPrintf("\n*** Testing with SeRsaTestVec2_Mod2048 Test vector\
                    (mixed keyslot test slot0 and then slot1), this test should pass****\n");
    CurTestVec = &SeRsaTestVec2_Mod2048;
    e = FillIpData(CurTestVec->PlainMsg, 256);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(1, 0);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(0, 1);
    if(e!=NvSuccess)
        goto fail;
    if(NvOsMemcmp(CurTestVec->PlainMsg,SeRSAHWResult,
                     CurTestVec->ModulusSizeInBytes))
        goto fail;
    TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\n*** Mixed key test Passed with test vector :SeRsaTestVec2_Mod2048******\n");
    NvOsDebugPrintf("\n*** Mixed key test Passed with test vector :SeRsaTestVec2_Mod2048******\n");

    NvOsDebugPrintf("\n*** Testing with SeRsaTestVec1_Mod2048 Test vector\
                    (mixed keyslot test slot1 and then slot0), this test should pass****\n");
    CurTestVec = &SeRsaTestVec1_Mod2048;
    e =FillIpData(CurTestVec->PlainMsg, 256);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(1, 1);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(0, 0);
    if(e!=NvSuccess)
        goto fail;
    if(NvOsMemcmp(CurTestVec->PlainMsg,SeRSAHWResult,
                     CurTestVec->ModulusSizeInBytes))
        goto fail;
    TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\n*** Mixed key test Passed with test vector :SeRsaTestVec1_Mod2048******\n");
    NvOsDebugPrintf("\n*** Mixed key test Passed with test vector :SeRsaTestVec1_Mod2048******\n");

    NvOsDebugPrintf("\n*** START -VE TEST CASES*******\n");

    NvOsDebugPrintf("\n*** Testing with SeRsaTestVec2_Mod1024 Test vector,\
                    with (M = 0)keyslot 2 this test should fail****\n");
    CurTestVec = &SeRsaTestVec2_Mod1024;
    e = PerformModularExponentiation(1, 1);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(0, 1);
    if(e!=NvSuccess)
        goto fail;
    if(NvOsMemcmp(CurTestVec->PlainMsg,SeRSAHWResult,
                     CurTestVec->ModulusSizeInBytes))
        goto fail;
    TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\n*** (-VE TEST)failed with test vector:SeRsaTestVec2_Mod1024 (m = 0)******\n");
    NvOsDebugPrintf("\n*** (-VE TEST)failed with test vector:SeRsaTestVec2_Mod1024 (m = 0)******\n");

    NvOsDebugPrintf("\n*** Testing with SeRsaTestVec2_Mod1536 Test vector (m = n),\
                    Keyslot 1, this test should fail****\n");
    CurTestVec = &SeRsaTestVec2_Mod1536;
    for (i = 0; i < 192; i++)
    {
        CurTestVec->PlainMsg[192 - i - 1] = CurTestVec->Modulus[i];
    }
    e = ChangeEndian(CurTestVec->PlainMsg, 192);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(1, 0);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(0, 0);
    if(e!=NvSuccess)
        goto fail;

    if(NvOsMemcmp(CurTestVec->PlainMsg,SeRSAHWResult,
                     CurTestVec->ModulusSizeInBytes))
        goto fail;
    TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\n*** (-VE TEST)failed with test vector:SeRsaTestVec2_Mod1536 (m = n)******\n");
    NvOsDebugPrintf("\n*** (-VE TEST) failed with test vector :SeRsaTestVec2_Mod1536 (m = n)******\n");

    NvOsDebugPrintf("\n*** Testing with SeRsaTestVec2_Mod1536 Test vector (m > n),\
                    Keyslot 1, this test should fail****\n");
    CurTestVec = &SeRsaTestVec2_Mod1536;
    for (i = 0; i < 192; i++)
    {
        CurTestVec->PlainMsg[192 - i - 1] = CurTestVec->Modulus[i];
    }
    CurTestVec->PlainMsg[191] = 0xff;
    e = PerformModularExponentiation(1, 0);
    if(e!=NvSuccess)
        goto fail;
    e = PerformModularExponentiation(0, 0);
    if(e!=NvSuccess)
        goto fail;
    if(NvOsMemcmp(CurTestVec->PlainMsg,SeRSAHWResult,
                     CurTestVec->ModulusSizeInBytes))
        goto fail;
    TEST_ASSERT_EQUAL(e, NvSuccess, test ,suite, "\n*** (-VE TEST)failed with test vector:SeRsaTestVec2_Mod1536 (m > n)******\n");
    NvOsDebugPrintf("\n*** (-VE TEST) failed with test vector :SeRsaTestVec2_Mod1536 (m > n)******\n");
fail:
    if (e != NvSuccess)
        NvOsDebugPrintf("\n%s Test Failed\n",__FUNCTION__);
}


void NvSeRsaVerifyTest(void)
{
    SeRsaTest();
}


static NvBool AesClearSBKTest(void)
{
    NvError e;
    NvRmDeviceHandle hRmDevice = NULL;
    NvDdkBlockDevHandle SeHandle;
    NvU32 NumberOfBlocks = s_ZeroKeyVectorKeySchedulerSupported.NofBlocks;
    NvU32 BufferSize = NumberOfBlocks * NvDdkAesConst_BlockLengthBytes;
    NvBool ret = NV_FALSE;
    NvDdkSeAesOperation OpInfo;
    NvDdkSeAesKeyInfo   KeyInfo;
    NvDdkSeAesSetIvInfo SetIvInfo;
    NvDdkSeAesProcessBufferInfo PbInfo;
    NvU8 DecryptBuffer[64];

    e = NvRmOpen(&hRmDevice, 0);
    if(e!=NvSuccess)
        goto fail;

    // Initialize SE engine
    e = NvDdkSeBlockDevInit(hRmDevice);
    if(e!=NvSuccess)
        goto fail;

    //  open the SE device
    if (NvSuccess != (NvDdkBlockDevMgrDeviceOpen(NvDdkBlockDevMgrDeviceId_Se,
                                                 0,
                                                 0,
                                                 &SeHandle)))
    {
        goto fail;
    }
    /* Open SE BlockDevice */
    NV_CHECK_ERROR_CLEANUP(NvDdkSeBlockDevOpen(0, 0, &SeHandle));
    /* Select Operation */
    OpInfo.OpMode = NvDdkSeAesOperationalMode_Cbc;
    OpInfo.IsEncrypt = NV_TRUE;
    NV_CHECK_ERROR_CLEANUP(
            SeHandle->NvDdkBlockDevIoctl(
                SeHandle,
                NvDdkSeAesBlockDevIoctlType_SelectOperation,
                sizeof(NvDdkSeAesOperation),
                0,
                (const void *)&OpInfo,
                NULL));
    /* Select the key */
    KeyInfo.KeyType = NvDdkSeAesKeyType_SecureBootKey;
    KeyInfo.KeyLength = NvDdkSeAesKeySize_128Bit;
    NV_CHECK_ERROR_CLEANUP(
            SeHandle->NvDdkBlockDevIoctl(
                SeHandle,
                NvDdkSeAesBlockDevIoctlType_SelectKey,
                sizeof(NvDdkSeAesKeyInfo),
                0,
                (const void *)&KeyInfo,
                NULL));
    SetIvInfo.pIV = s_ZeroKey;
    SetIvInfo.VectorSize = 16;
    NV_CHECK_ERROR_CLEANUP(
            SeHandle->NvDdkBlockDevIoctl(
                SeHandle,
                NvDdkSeAesBlockDevIoctlType_SetIV,
                sizeof(NvDdkSeAesSetIvInfo),
                0,
                (const void *)&SetIvInfo,
                NULL));
    /* process buffer */
    PbInfo.pSrcBuffer = s_ZeroKeyVectorKeySchedulerSupported.PlainText;
    PbInfo.pDstBuffer = DecryptBuffer;
    PbInfo.SrcBufSize = BufferSize;
    NV_CHECK_ERROR_CLEANUP(
            SeHandle->NvDdkBlockDevIoctl(
                SeHandle,
                NvDdkSeAesBlockDevIoctlType_ProcessBuffer,
                sizeof(NvDdkSeAesProcessBufferInfo),
                0,
                (const void *)&PbInfo,
                NULL));
    if (DataCompare(DecryptBuffer,
                s_ZeroKeyVectorKeySchedulerSupported.CipherText, BufferSize, NV_TRUE))
        goto fail;
    ret = NV_TRUE;
fail:
    SeHandle->NvDdkBlockDevClose(SeHandle);
    return ret;
}

void NvSeAesClearSBKTest(void)
{
    NvBool e=AesClearSBKTest();
    if(e==NV_TRUE)
        NvOsDebugPrintf("\nsbk not present\n");
    else
        NvOsDebugPrintf("\nsbk present\n");
}


static NvBool AesLocksskTest(void)
{
    NvError e;
    NvRmDeviceHandle hRmDevice = NULL;
    NvDdkBlockDevHandle SeHandle;
    NvU32 NumberOfBlocks = s_ZeroKeyVectorKeySchedulerSupported.NofBlocks;
    NvU32 BufferSize = NumberOfBlocks * NvDdkAesConst_BlockLengthBytes;
    NvBool ret = NV_FALSE;
    NvDdkSeAesOperation OpInfo;
    NvDdkSeAesKeyInfo   KeyInfo;
    NvDdkSeAesSetIvInfo SetIvInfo;
    NvDdkSeAesProcessBufferInfo PbInfo;
    NvU8 DecryptBuffer[64];

    e = NvRmOpen(&hRmDevice, 0);
    if(e!=NvSuccess)
        goto fail;

    // Initialize SE engine
    e = NvDdkSeBlockDevInit(hRmDevice);
    if(e!=NvSuccess)
        goto fail;

    //  open the SE device
    if (NvSuccess != (NvDdkBlockDevMgrDeviceOpen(NvDdkBlockDevMgrDeviceId_Se,
                                                 0,
                                                 0,
                                                 &SeHandle)))
    {
        goto fail;
    }
    /* Open SE BlockDevice */
    NV_CHECK_ERROR_CLEANUP(NvDdkSeBlockDevOpen(0, 0, &SeHandle));
    /* Select Operation */
    OpInfo.OpMode = NvDdkSeAesOperationalMode_Cbc;
    OpInfo.IsEncrypt = NV_TRUE;
    NV_CHECK_ERROR_CLEANUP(
            SeHandle->NvDdkBlockDevIoctl(
                SeHandle,
                NvDdkSeAesBlockDevIoctlType_SelectOperation,
                sizeof(NvDdkSeAesOperation),
                0,
                (const void *)&OpInfo,
                NULL));
    /* Select the key */
    KeyInfo.KeyType = NvDdkSeAesKeyType_SecureStorageKey;
    KeyInfo.KeyLength = NvDdkSeAesKeySize_128Bit;
    NV_CHECK_ERROR_CLEANUP(
            SeHandle->NvDdkBlockDevIoctl(
                SeHandle,
                NvDdkSeAesBlockDevIoctlType_SelectKey,
                sizeof(NvDdkSeAesKeyInfo),
                0,
                (const void *)&KeyInfo,
                NULL));
    SetIvInfo.pIV = s_ZeroKey;
    SetIvInfo.VectorSize = 16;
    NV_CHECK_ERROR_CLEANUP(
            SeHandle->NvDdkBlockDevIoctl(
                SeHandle,
                NvDdkSeAesBlockDevIoctlType_SetIV,
                sizeof(NvDdkSeAesSetIvInfo),
                0,
                (const void *)&SetIvInfo,
                NULL));
    /* process buffer */
    PbInfo.pSrcBuffer = s_ZeroKeyVectorKeySchedulerSupported.PlainText;
    PbInfo.pDstBuffer = DecryptBuffer;
    PbInfo.SrcBufSize = BufferSize;
    NV_CHECK_ERROR_CLEANUP(
            SeHandle->NvDdkBlockDevIoctl(
                SeHandle,
                NvDdkSeAesBlockDevIoctlType_ProcessBuffer,
                sizeof(NvDdkSeAesProcessBufferInfo),
                0,
                (const void *)&PbInfo,
                NULL));
    if (DataCompare(DecryptBuffer,
                s_ZeroKeyVectorKeySchedulerSupported.CipherText, BufferSize, NV_TRUE))
        goto fail;
    ret = NV_TRUE;
fail:
    SeHandle->NvDdkBlockDevClose(SeHandle);
    return ret;
}

void NvSeAesLocksskTest(void)
{
    NvBool e=AesLocksskTest();
    if(e==NV_TRUE)
        NvOsDebugPrintf("\nssk not present\n");
    else
        NvOsDebugPrintf("\nssk present\n");
}

static NvError PerformRng(NvU32 Source, NvBool GenREI)
{
    NvError e = NvSuccess;
    NvDdkBlockDevHandle SeHandle = NULL;
    NvDdkSeRngInitInfo  RngInitInfo;
    NvDdkSeRngProcessInInfo RngInInfo;
    NvDdkSeRngProcessOutInfo RngOutInfo;
    NvU8 RandomNumber[SE_TEST_RNG_OUT_MIN_SIZE * MAX_ROUNDS];
    NvU32 i, j;
    SeRngTestVecData *p[3];

    /*  open the SE device */
    NV_CHECK_ERROR_CLEANUP(NvDdkSeBlockDevOpen(0, 0, &SeHandle));

    p[0] = &Rng1Vector;
    p[1] = &Rng2Vector;
    p[2] = &Rng3Vector;
    for (i = 0; i < 6 ; i++)
    {
        RngInitInfo.RngMode          =
            (i < 3) ? NvDdkSeRngMode_ForceReseed :NvDdkSeRngMode_Normal;
        RngInitInfo.RngKeyUsed       = p[i % 3]->KeySize;
        RngInitInfo.RngSeed          = p[i % 3]->RngSeed;
        RngInitInfo.RngSeedSize      = p[i % 3]->RngSeedLen;
        RngInitInfo.IsSrcMem         = Source;
        RngInitInfo.IsDestMem        = 1;

        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(SeHandle,
                                         NvDdkSeBlockDevIoctlType_RNGSetUpContext,
                                         sizeof(RngInitInfo),
                                         0,
                                         (const void *)&RngInitInfo,
                                         NULL
                                        ));

        RngInInfo.OutPutSizeReq  = (GenREI) ? SE_TEST_RNG_OUT_MIN_SIZE * 195:
            SE_TEST_RNG_OUT_MIN_SIZE * 95;
        RngOutInfo.pRandomNumber = RandomNumber;

        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(SeHandle,
                                         NvDdkSeBlockDevIoctlType_RNGGetRandomNum,
                                         sizeof(RngInInfo),
                                         sizeof(RngOutInfo),
                                         (const void *)&RngInInfo,
                                         (void *)&RngOutInfo
                                        ));

        NvOsDebugPrintf("\nPrinting Random vector : %d \n", (i % 3));
        for (j = 0; j < SE_TEST_RNG_OUT_MIN_SIZE; j++)
        {
            NvOsDebugPrintf("0x%x,", RandomNumber[j]);
        }
    }

fail:
    /*  Close the device */
    if (SeHandle)
        SeHandle->NvDdkBlockDevClose(SeHandle);
    return e;
}

NvError NvSeRngVerifyTest(void)
{
    NvError e = NvSuccess;
    char *pTest = "NvSeRngVerifyTest";
    char *pSuite = "se";
    NvBool b;

    NvOsDebugPrintf("\nTest: Source = memory, NO REI \n");
    NV_CHECK_ERROR_CLEANUP(PerformRng(1, NV_FALSE));
    TEST_ASSERT_EQUAL(e, NvSuccess, pTest ,pSuite, "\nTest: Source = memory, NO REI PASSED\n");
    NvOsDebugPrintf("\n Tests Passed \n");

    NvOsDebugPrintf("\nTest: Source = memory, REI generated\n");
    NV_CHECK_ERROR_CLEANUP(PerformRng(1, NV_TRUE));
    TEST_ASSERT_EQUAL(e, NvSuccess, pTest ,pSuite, "\nTest: Source = memory, REI generated PASSED\n");
    NvOsDebugPrintf("\n Tests Passed \n");

    NvOsDebugPrintf("\nTest: Source = entropy, NO REI \n");
    NV_CHECK_ERROR_CLEANUP(PerformRng(0, NV_FALSE));
    TEST_ASSERT_EQUAL(e, NvSuccess, pTest ,pSuite, "\nTest: Source = entropy, NO REI PASSED\n");
    NvOsDebugPrintf("\n Tests Passed \n");

fail:
    if (e != NvSuccess)
        NvOsDebugPrintf("\nTest failed \n");
    return e;
}

NvError NvSeAesPerformanceTest(void)
{
    NvBool b;
    char *pTest = "NvSeAesPerformanceTest";
    char *pSuite = "se";
    NvError e = NvSuccess;
    NvDdkBlockDevHandle SeHandle;
    NvDdkSeAesOperation OpInfo;
    NvDdkSeAesKeyInfo KeyInfo;
    NvDdkSeAesProcessBufferInfo PbInfo;
    NvDdkSeAesSetIvInfo SetIvInfo;
    NvU8 *pEncryptBuffer = NULL;
    NvU8 *pDecryptBuffer = NULL;
    NvU8 *pPlainText     = NULL;
    NvU8 Iv[AES_IV_LENGTH_BYTES] = {0};
    NvU8 Key[AES_KEY_LENGTH_BYTES] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF};
    NvU32 InputSize[] = {1, 2, 4, 8, 16, 32, 64};
    NvU64 InputSizeInBytes;
    NvU64 StartTime = 0;
    NvU64 EndTime = 0;
    NvU32 TimeConsumed;
    NvU32 i;
    NvU64 j;
    NvU8 PlainTextFiller;

    for (i = 0; i < (sizeof(InputSize) / sizeof(InputSize[0])); i++)
    {
        InputSizeInBytes = MB_IN_BYTES(InputSize[i]);

        NvOsDebugPrintf("\n============================================");
        NvOsDebugPrintf("\n*****Testing with %d MB of data*****", InputSize[i]);
        NvOsDebugPrintf("\n============================================");

        // allocate the buffers
        pPlainText = NvOsAlloc(InputSizeInBytes);
        TEST_ASSERT_PTR_NULL(!pPlainText, pTest, pSuite, "NvOsAlloc FAILED");

        pEncryptBuffer = NvOsAlloc(InputSizeInBytes);
        TEST_ASSERT_PTR_NULL(!pEncryptBuffer, pTest, pSuite, "NvOsAlloc FAILED");

        pDecryptBuffer = NvOsAlloc(InputSizeInBytes);
        TEST_ASSERT_PTR_NULL(!pDecryptBuffer, pTest, pSuite, "NvOsAlloc FAILED");

        // fill the input plain text
        PlainTextFiller = 0;
        for (j = 0; j < InputSizeInBytes; j++)
        {
            pPlainText[j] = PlainTextFiller;
            PlainTextFiller++;
        }

        // Encryption

        // Open Se block device
        NV_CHECK_ERROR_CLEANUP(NvDdkSeBlockDevOpen(0, 0, &SeHandle));

        // select operation
        OpInfo.OpMode = NvDdkSeAesOperationalMode_Cbc;
        OpInfo.IsEncrypt = NV_TRUE;
        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_SelectOperation,
                    sizeof(NvDdkSeAesOperation),
                    0,
                    (const void *)&OpInfo,
                    NULL));
        // Set Iv
        SetIvInfo.pIV = Iv;
        SetIvInfo.VectorSize = AES_IV_LENGTH_BYTES;
        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_SetIV,
                    sizeof(NvDdkSeAesSetIvInfo),
                    0,
                    (const void *)&SetIvInfo,
                    NULL));

        /// Select key
        KeyInfo.KeyType = NvDdkSeAesKeyType_UserSpecified;
        KeyInfo.KeyLength = AES_KEY_LENGTH_BYTES;
        NvOsMemcpy(KeyInfo.Key, Key, KeyInfo.KeyLength);
        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_SelectKey,
                    sizeof(NvDdkSeAesKeyInfo),
                    0,
                    (const void *)&KeyInfo,
                    NULL));

        /// process buffer
        PbInfo.pSrcBuffer = pPlainText;
        PbInfo.pDstBuffer = pEncryptBuffer;
        PbInfo.SrcBufSize = InputSizeInBytes;

        NvOsDebugPrintf("\nEncrypting PlainText......");
        StartTime = NvOsGetTimeUS();

        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_ProcessBuffer,
                    sizeof(NvDdkSeAesProcessBufferInfo),
                    0,
                    (const void *)&PbInfo,
                    NULL));

        EndTime = NvOsGetTimeUS();

        TimeConsumed = (NvU32)((EndTime - StartTime) / MSECS_IN_A_SEC);
        NvOsDebugPrintf("\nEncryption time = %d ms", TimeConsumed);
        NvOsDebugPrintf("\nEncryption speed = %d KB/s\n",
                           (NvU32)(InputSizeInBytes / TimeConsumed));

        // Decryption

        // Select Operation
        OpInfo.IsEncrypt = NV_FALSE;
        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_SelectOperation,
                    sizeof(NvDdkSeAesOperation),
                    0,
                    (const void *)&OpInfo,
                    NULL));

        // Set IV
        SetIvInfo.pIV = Iv;
        SetIvInfo.VectorSize = AES_IV_LENGTH_BYTES;
        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_SetIV,
                    sizeof(NvDdkSeAesSetIvInfo),
                    0,
                    (const void *)&SetIvInfo,
                    NULL));

        // process buffer
        PbInfo.pSrcBuffer = pEncryptBuffer;
        PbInfo.pDstBuffer = pDecryptBuffer;
        PbInfo.SrcBufSize = InputSizeInBytes;

        NvOsDebugPrintf("\nDecrypting the encrypted text........");
        StartTime = NvOsGetTimeUS();

        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_ProcessBuffer,
                    sizeof(NvDdkSeAesProcessBufferInfo),
                    0,
                    (const void *)&PbInfo,
                    NULL));

        EndTime = NvOsGetTimeUS();

        TimeConsumed = (NvU32)((EndTime - StartTime) / MSECS_IN_A_SEC);
        NvOsDebugPrintf("\nDecryption time = %d ms", TimeConsumed);
        NvOsDebugPrintf("\nDecryption speed = %d KB/s\n",
                           (NvU32)(InputSizeInBytes / TimeConsumed));

        SeHandle->NvDdkBlockDevClose(SeHandle);

        if (DataCompare(pDecryptBuffer,
                        pPlainText,
                        InputSizeInBytes, NV_TRUE))
        {
            NvOsDebugPrintf("\nperf test failed with %d MB of data\n", InputSize[i]);
            goto fail;
        }
        NvOsDebugPrintf("\nPerf test success with %d MB of data\n", InputSize[i]);
        TEST_ASSERT_EQUAL(e, NvSuccess, pTest ,pSuite, "\nPerformance test success\n");

        // free the buffers used
        if (pPlainText)
            NvOsFree(pPlainText);
        if (pEncryptBuffer)
            NvOsFree(pEncryptBuffer);
        if (pDecryptBuffer)
            NvOsFree(pDecryptBuffer);
        pPlainText     = NULL;
        pEncryptBuffer = NULL;
        pDecryptBuffer = NULL;
    }

fail:
    return e;
}

NvError se_init_reg(void)
{
    NvBDKTest_pSuite pSuite  = NULL;
    NvBDKTest_pTest pTest1 = NULL;
    NvBDKTest_pTest pTest2 = NULL;
    NvBDKTest_pTest pTest3 = NULL;
    NvBDKTest_pTest pTest4 = NULL;
    NvBDKTest_pTest pTest5 = NULL;
    NvBDKTest_pTest pTest6 = NULL;
    NvError e = NvSuccess;
    const char* pErrStr = 0;

    e = NvBDKTest_AddSuite("se", &pSuite);
    if (e != NvSuccess)
    {
        pErrStr = "Adding suite se failed.";
        goto fail;
    }

    e = NvBDKTest_AddTest(pSuite, &pTest1, "NvSeAesVerifyTest",
                        (NvBDKTest_TestFunc)NvSeAesVerifyTest, "basic",
                        NULL, NULL);
    if (e != NvSuccess)
    {
        pErrStr = "Adding test NvSeAesVerifyTest failed.";
        goto fail;
    }
    e = NvBDKTest_AddTest(pSuite, &pTest2, "NvSeShaVerifyTest",
                        (NvBDKTest_TestFunc)NvSeShaVerifyTest, "basic",
                        NULL, NULL);
    if (e != NvSuccess)
    {
        pErrStr = "Adding test NvSeShaVerifyTest failed.";
        goto fail;
    }

    e = NvBDKTest_AddTest(pSuite, &pTest3, "NvSeRsaVerifyTest",
                        (NvBDKTest_TestFunc)NvSeRsaVerifyTest, "basic",
                        NULL, NULL);
    if (e != NvSuccess)
    {
        pErrStr = "Adding test NvSeRsaVerifyTest failed.";
        goto fail;
    }

    e = NvBDKTest_AddTest(pSuite, &pTest4, "NvSeAesClearSBKTest",
                        (NvBDKTest_TestFunc)NvSeAesClearSBKTest, "basic",
                        NULL, NULL);
    if (e != NvSuccess)
    {
        pErrStr = "Adding test NvSeAesClearSBKTest failed.";
        goto fail;
    }

    e = NvBDKTest_AddTest(pSuite, &pTest5, "NvSeAesLocksskTest",
                        (NvBDKTest_TestFunc)NvSeAesLocksskTest, "basic",
                        NULL, NULL);
    if (e != NvSuccess)
    {
        pErrStr = "Adding test NvSeAesLocksskTest failed.";
        goto fail;
    }

    e = NvBDKTest_AddTest(pSuite, &pTest6, "NvSeRngVerifyTest",
                        (NvBDKTest_TestFunc)NvSeRngVerifyTest, "basic",
                        NULL, NULL);
    if (e != NvSuccess)
    {
        pErrStr = "Adding test NvSeRngVerifyTest failed.";
        goto fail;
    }

    e = NvBDKTest_AddTest(pSuite, &pTest6, "NvSeAesPerformanceTest",
                        (NvBDKTest_TestFunc)NvSeAesPerformanceTest, "perf",
                        NULL, NULL);
    if (e != NvSuccess)
    {
        pErrStr = "Adding test NvSeAesPerformanceTest failed.";
        goto fail;
    }

    goto clean;
fail:
    if(pErrStr)
        NvOsDebugPrintf("%s se_init_reg failed : NvError 0x%x\n",
                        pErrStr , e);
clean:
    return e;
}
