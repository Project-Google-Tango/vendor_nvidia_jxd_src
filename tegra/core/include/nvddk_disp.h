/*
 * Copyright (c) 2006 - 2012 NVIDIA Corporation.  All rights reserved.
 *
 * NVIDIA Corporation and its licensors retain all intellectual property
 * and proprietary rights in and to this software and related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA Corporation is strictly prohibited.
 */

/**
 * @file
 * <b> NVIDIA Driver Development Kit: Display Interface</b>
 *
 * @b Description: This file declares the NvDDK interface for display devices.
 */

/**
 * @defgroup nvbdk_ddk_disp Display Interface
 *
 * NvDdkDisp is the display interface for controlling and managing
 * display devices on handheld and embedded devices.
 *
 * The interface is part of the NVIDIA Driver Development Kit (NvDDK).
 *
 * This interface uses 3 fundamental objects:
 * - Displays
 * - Controllers
 * - Windows
 *
 * Each GPU-enabled device is connected to one or more display devices. A
 * display can be of various types, but is often an LCD, monitor, or a TV.
 *
 * Displays are connected to controllers that drive the image presented
 * on the display. Some displays have embedded controllers, so the image
 * presented on the display is updated via some other method such as a bus or
 * hardware serial interface connecting the display to the GPU-enabled device.
 *
 * More than one display can be connected to a single controller, as long as
 * there are one or more compatibile modes between the displays. The timing
 * constraints of most displays are such that it is unlikley to find a
 * a compatible set of timings for a singe mode that meets the requirements
 * of more than one display at the same time. Even though this occurs
 * infrequently, it does occur.
 *
 * The image presented on a display is generated by a controller. The
 * controller can generate this image from one or more windows. A window is
 * a rectangular object that gets its pixel data from a surface in memory.
 * A window may be color keyed, or blended with other windows when the windows
 * overlap. The windows can also be ordered above each other to provide the
 * appearance of depth on a display.
 *
 * @note All attributes are 32 bits. Attributes are commited to
 * hardware synchronously with the SetAttribute()/SetAttributes() functions.
 *
 * @ingroup nvddk_modules
 * @{
 */

#ifndef INCLUDED_NVDDK_DISP_H
#define INCLUDED_NVDDK_DISP_H

#include "nvcommon.h"
#include "nvcolor.h"
#include "nvrm_init.h"
#include "nvrm_surface.h"
#include "nvrm_channel.h"
#include "nvodm_disp.h"
#include "nvhdcp.h"

#if defined(__cplusplus)
extern "C"
{
#endif

/**
 * Opaque context to the NvDdkDisp interface.
 */
typedef struct NvDdkDispRec *NvDdkDispHandle;

/**
 * Opaque handle to a display controller.
 */
typedef struct NvDdkDispControllerRec *NvDdkDispControllerHandle;

/**
 * Opaque handle to a display.
 */
typedef struct NvDdkDispDisplayRec *NvDdkDispDisplayHandle;

/**
 * Opaque handle to a display window.
 */
typedef struct NvDdkDispWindowRec *NvDdkDispWindowHandle;

/** Wait flag for any operations that support blocking behavior. */
#define NVDDK_DISP_WAIT (0x10000000)

/**
 * Do not commit changes. Used for atomic updates of window attributes and
 * surfaces. Other functions may support this flag in the future. Changes
 * will be commited on the next function call without this flag (for the
 * same object type). Or changes may be commited with NvDdkDispFlush().
 */
#define NVDDK_DISP_DO_NOT_COMMIT (0x20000000)

/**
 * Output debug infomation for a particular function. See API descriptions
 * for support of this flag.
 */
#define NVDDK_DISP_DEBUG (0x40000000)

/** Maximum number of display controllers per system. */
#define NVDDK_DISP_MAX_CONTROLLERS 2

/** Maximum number of displays in the system. */
#define NVDDK_DISP_MAX_DISPLAYS 5

/** Maximum number of windows per controller. */
#define NVDDK_DISP_MAX_WINDOWS 3

/** Maximum number of modes per display. */
#define NVDDK_DISP_MAX_MODES 64

/**
 * Maximum number of surfaces per window: 1 for interleaved or RGB formats,
 * 2 or 3 for planar formats (Y, U, V or Y, UV).
 */
#define NVDDK_DISP_MAX_SURFACES 3

/**
 * Various errors can occur in hardware. This enumeration plus the
 * NvDdkDispSetErrorTrigger() API allows for notification of these errors.
 */
typedef enum
{
    /** Indicates no error, everything is fine. */
    NvDdkDispActiveError_None = 0,

    /**
     * Indicates the memory fetch has failed to reach the display hardware in
     * time.
     */
    NvDdkDispActiveError_Underflow = 0x1,

    /** Indicates an overflow error. */
    NvDdkDispActiveError_Overflow = 0x2,

    /**
     * Ignore -- Forces compilers to make 32-bit enums.
     */
    NvDdkDispActiveError_Force32 = 0x7FFFFFFF,
} NvDdkDispActiveError;

/**
 * Defines a 2-dimensional mode for a display device. Use the mode structure
 * from the display ODM Kit. See nvodm_disp.h for details.
 */
typedef NvOdmDispDeviceMode NvDdkDispMode;

/**
 * Put the ODM defines into the Display DDK's namespace.
 */
#define NVDDK_DISP_MODE_FLAG_NONE NVODM_DISP_MODE_FLAG_NONE
#define NVDDK_DISP_MODE_FLAG_PARTIAL NVODM_DISP_MODE_FLAG_PARTIAL
#define NVDDK_DISP_MODE_FLAG_INTERLACED NVODM_DISP_MODE_FLAG_INTERLACED
#define NVDDK_DISP_MODE_FLAG_HSYNC_NEGATIVE NVODM_DISP_MODE_FLAG_HSYNC_NEGATIVE
#define NVDDK_DISP_MODE_FLAG_VSYNC_NEGATIVE NVODM_DISP_MODE_FLAG_VSYNC_NEGATIVE
#define NVDDK_DISP_MODE_FLAG_NATIVE NVODM_DISP_MODE_FLAG_NATIVE
#define NVDDK_DISP_MODE_FLAG_USE_TEARING_EFFECT \
    NVODM_DISP_MODE_FLAG_USE_TEARING_EFFECT
#define NVDDK_DISP_MODE_FLAG_TYPE_CUSTOM NVODM_DISP_MODE_FLAG_TYPE_CUSTOM
#define NVDDK_DISP_MODE_FLAG_TYPE_VESA NVODM_DISP_MODE_FLAG_TYPE_VESA
#define NVDDK_DISP_MODE_FLAG_TYPE_DTD NVODM_DISP_MODE_FLAG_TYPE_DTD
#define NVDDK_DISP_MODE_FLAG_TYPE_HDMI NVODM_DISP_MODE_FLAG_TYPE_HDMI
#define NVDDK_DISP_MODE_FLAG_TYPE_3D NVODM_DISP_MODE_FLAG_TYPE_3D

/**
 * Authentication state for HDCP.
 */
typedef enum
{
    NvDdkDispHdcpState_Unauthenticated   = 0x0,
    NvDdkDispHdcpState_RepeaterVerif     = 0x1,
    NvDdkDispHdcpState_RepeaterOk        = 0x2,
    NvDdkDispHdcpState_LinkVerif         = 0x3,
    NvDdkDispHdcpState_Force32           = 0x7FFFFFFF,
} NvDdkDispHdcpState;

/**
 * High-Definition Content Proctection (HDCP) context information.
 */
typedef struct NvDdkDispHdcpContextRec
{
    /** Holds the display handle for the HDCP-enabled device. */
    NvDdkDispDisplayHandle hDisplay;

    /**
     * Holds a pointer to revoked key vectors; authentication will
     * be aborted if any Ksv is in this list.
     */
    NvU64 *RevokedKsvs;
    NvU32 nRevokedKsvs;

    /** Holds the current state of authentication. */
    NvDdkDispHdcpState State;

    /** Holds the upstream authentication data */
    NV_HDCP_PACKET pkt;

    /**
     * Holds the hot-plug de-asserted flag. This should be set to NV_TRUE
     * if the hot-plug signal toggled during the authentication.
     * The authentication will be aborted.
     */
    NvBool bHotplugDeasserted;
} NvDdkDispHdcpContext;

/**
 * CGMSA configuration for standard definition television.
 */
typedef struct NvDdkDispCGMSAContextRec
{
    /**
     * Payload for CGMS-A, which is sent to the television on
     * line 20 for NTSC and line 23 for PAL (WSS) and/or
     * line 21 (Closed Captioning).
     *
     * Line 21 sends the CGMS-A data via the closed captioning XDS packets and
     * must be sent every 10-30 seconds. See EIA/CEA-608-B. CGMS data is
     * considered high priority.
     *
     * Bits 0 and 1:
     * - {0,0} - Content may be copied without restriction.
     * - {0,1} - Unused.
     * - {1,0} - One generation may be copied.
     * - {1,1} - Content may not be copied
     *
     * Bits 2 and 3:
     * - {0,0} - PSP (pseduo-sync puluse) off.
     * - {0,1} - PSP on, split burst off.
     * - {1,0} - PSP on, 2 line split burst.
     * - {1,1} - PSP on, 4 line split burst.
     *
     * Bit 4: analog source bit.
     * Bits 5-7: should be zero.
     */
    NvU8 Payload;

    /**
     * Line selection for the current call to ::NvDdkDispSetContentProtection.
     *
     * - Bit 0: send data on line 20 for NTSC and line 23 for PAL.
     * - Bit 1: send data on line 21.
     */
    NvU8 LineSelect;
} NvDdkDispCGMSAContext;

/**
 * Macrovision configuration for standard definition television.
 */
typedef enum
{
    NvDdkDispMacrovisionBurst_None = 1,
    NvDdkDispMacrovisionBurst_2line,
    NvDdkDispMacrovisionBurst_4line,

    NvDdkDispMacrovisionBurst_Force32 = 0x7FFFFFFF,
} NvDdkDispMacrovisionBurst;

/**
 * Holds the Macrovision context.
 */
typedef struct NvDdkDispMacrovisionContextRec
{
    NvDdkDispMacrovisionBurst burst;
} NvDdkDispMacrovisionContext;

/**
 * Controller-specfic attributes.
 */
typedef enum
{
    /**
     * Background color indicates the color displayed by the controller
     * for any pixels not covered by a window. The value corresponding
     * to this attribute is a 32-bit A8R8G8B8 value, where A is in bits 31:24,
     * R in 23:16, G in 15:8, and B in bits 7:0. By default background color
     * is black (0x00000000).
     */
    NvDdkDispControllerAttribute_BackgroundColor = 0x1,

    /**
     * Smart Dimmer configuration. The Smart Dimmer is a technology that takes
     * advantage of the fact that preceived pixel brightness on an LCD depends
     * on both the pixel brightness and the backlight intensity, thusly the
     * backlight can be reduced and the pixel brightness can be increased to
     * save backlight power.
     *
     * Some loss of quality is to be expected, so there are several levels of
     * aggressiveness.
     *
     * Some Tegra chips do not support Smart Dimmer.
     */

    /**
     * (READ-ONLY) Capability bit for Smart Dimmer hardware.
     */
    NvDdkDispControllerAttribute_Supports_SmartDimmer,

    /**
     * Enable, OneShot or Disable the Smart Dimmer hardware.
     */
    NvDdkDispControllerAttribute_SmartDimmer_Enable,

    /**
     * Width of the histogram bins used in smart dimmer. Legal values are 0 - 4.
     *
     * <pre>
     *      Agreesiveness      Bin Width
     *            1                1
     *          2 ~ 4              2
     *            5                3
     * </pre>
     *
     * - 0 => Sets the value according to smart dimmer aggressiveness.
     * - 1 => (ONE in IAS) 1 level per bin. Bin span range 224 to 255.
     * - 2 => (TWO in IAS) 2 levels per bin, range 192 to 255.
     * - 3 => (FOUR in IAS) 4 levels per bin, range 128 to 255.
     * - 4 => (EIGHT in IAS) 8 levels per bin, range 0 to 255.
     */
    NvDdkDispControllerAttribute_SmartDimmer_BinWidth,

    /**
     * Smart dimmer hardware update delay. Legal values are 0 - 3.
     * - 0 : No delay
     * - 1 : New enhancement value delayed by 1 frame.
     * - 2 : New enhancement value delayed by 2 frames.
     * - 3 : New enhancement value delayed by 3 frames.
     */
    NvDdkDispControllerAttribute_SmartDimmer_HwUpdateDelay,

    /**
     * Smart dimmer aggressiveness. Legal values are 0 - 5. 5 is the most
     * aggressive (saves the most power with the most loss of quality). 0 is
     * the default.
     */
    NvDdkDispControllerAttribute_SmartDimmer_Aggressiveness,

    /**
     * Use video luminance control for the histogram data. Video luminance
     * uses a partial color space conversion as either ITU-R Bt-601 or
     * ITU-R Bt-709. See \c NvDdkDispControllerAttribute_SmartDimmer_Csc_Coeff_*
     * for details.
     *
     * By default, the histogram data is generated using Hue Saturation Value
     * (HSV) where luminance = MAX(R, G, B).
     */
    NvDdkDispControllerAttribute_SmartDimmer_Use_VideoLuminance,

    /**
     * Video luminance coefficients. Luminance is calcualted by the following
     * equation:
     *
     * <pre>
     *    luminance = (R * R_COEFF + G * G_COEFF + B * B_COEFF) >> 4
     * </pre>
     *
     * The suggested values:
     * <pre>
     * Color Space      R_COEFF     G_COEFF     B_COEFF
     * ITU-R Bt601      5           9           2
     * ITR-R Bt709      3           12          1
     * </pre>
     */
    NvDdkDispControllerAttribute_SmartDimmer_Csc_Coeff_R,
    NvDdkDispControllerAttribute_SmartDimmer_Csc_Coeff_G,
    NvDdkDispControllerAttribute_SmartDimmer_Csc_Coeff_B,

    /**
     * Manual K values. These are primarily used for debugging and verifying
     * hardware.
     */
    NvDdkDispControllerAttribute_SmartDimmer_Man_K_Enable,
    NvDdkDispControllerAttribute_SmartDimmer_Man_K_R,
    NvDdkDispControllerAttribute_SmartDimmer_Man_K_G,
    NvDdkDispControllerAttribute_SmartDimmer_Man_K_B,

    /**
     * Flicker control values. Limits changes of SD3 until consistent
     * change is seen, thereby limiting the flicker seen.
     */
    NvDdkDispControllerAttribute_SmartDimmer_FlickerTimeLimit,
    NvDdkDispControllerAttribute_SmartDimmer_FlickerThreshold,

    /**
     * BL control values. Allows gradual changes in brightness between
     * two SD states. This helps account for perception and CCFLs.
     */
    NvDdkDispControllerAttribute_SmartDimmer_BlStep,
    NvDdkDispControllerAttribute_SmartDimmer_BlTimeConstant,

    NvDdkDispControllerAttribute_Num,

    /**
     * Ignore -- Forces compilers to make 32-bit enums.
     */
    NvDdkDispControllerAttribute_Force32 = 0x7FFFFFFF
} NvDdkDispControllerAttribute;

/**
 * Physical display types.
 */
typedef enum
{
    /**
     * TFT LCD display is differentiated from a CLI LCD, in that it is
     * actively driven by timing signals from a controller external to
     * the display.
     */
    NvDdkDispDisplayType_TFTLCD = 0x1,

    /**
     * CLI LCD display has its own controller, and refreshes the contents
     * of the dispay from its local memory.
     */
    NvDdkDispDisplayType_CLILCD,

    /**
     * DSI panel. DSI panels follow a standardized interface as defined by
     * MIPI (www.mipi.org).
     */
    NvDdkDispDisplayType_DSI,

    /** Cathode Ray Tube Monitor. */
    NvDdkDispDisplayType_CRT,

    /** Television display. */
    NvDdkDispDisplayType_TV,

    /** HDMI removable display. */
    NvDdkDispDisplayType_HDMI,

    /** Ignore -- Forces compilers to make 32-bit enums. */
    NvDdkDispDisplayType_Force32 = 0x7FFFFFFF
} NvDdkDispDisplayType;

/**
 * Display usages.
 */
typedef enum
{
    /**
     * Main or primary display for the device. There is @b only one primary
     * display in the entire system.
     */
    NvDdkDispDisplayUsage_Primary = 0x1,

    /**
     * Secondary display for the device. There is @b only one secondary display
     * in the entire system.
     */
    NvDdkDispDisplayUsage_Secondary,

    /**
     * A removable display is one that is connected to the device temporairly
     * and can be disconnected at any time. The attributes of a removable
     * display may change when reconnected, as the actual display may change
     * between connections.
     */
    NvDdkDispDisplayUsage_Removable,

    /**
     * When the usage of the display is not known it is marked as unknown.
     */
    NvDdkDispDisplayUsage_Unknown,

    /**
     * Ignore -- Forces compilers to make 32-bit enums.
     */
    NvDdkDispDisplayUsage_Force32 = 0x7FFFFFFF
} NvDdkDispDisplayUsageType;

/**
 * Backlight control (for displays that have backlights).
 */
typedef enum
{
    /** Turns off the display backlight. */
    NvDdkDispBacklightControl_Off = 0x1,

    /** Turns on the display backlight. */
    NvDdkDispBacklightControl_On,

    /**
     * Turns on the display backlight and resets the strobe timeout that
     * turns off the backlight after the timeout exceeds the value specified
     * by the ::NvDdkDispDisplayAttribute_BacklightTimeout attribute.
     */
    NvDdkDispBacklightControl_OnStrobe,

    /**
     * Ignore -- Forces compilers to make 32-bit enums.
     */
    NvDdkDispBacklightControl_Force32 = 0x7FFFFFFF
} NvDdkDispBacklightControl;

/**
 * Defines audio frequencies for displays that have embedded audio.
 */
typedef enum
{
    NvDdkDispAudioFrequency_32000hz = 0x1,
    NvDdkDispAudioFrequency_44100hz,
    NvDdkDispAudioFrequency_48000hz,
    NvDdkDispAudioFrequency_00000hz,

    NvDdkDispAudioFrequency_Force32 = 0x7FFFFFFF,
} NvDdkDispAudioFrequency;

/**
 * Defines TV output types.
 */
typedef enum
{
    /** Specifies analog YUV video on the yellow RCA connector. */
    NvDdkDispTvOutput_Composite = 0x1,

    /**
     * Specifies video split over multiple components, usually RGB or YCbCr
     * over 3 RCA connectors.
     */
    NvDdkDispTvOutput_Component,

    /**
     * Specifies Y/C video (luma and chroma) over two wires on a single
     * connector (4 wires including ground).
     */
    NvDdkDispTvOutput_SVideo,

    /** Ignore -- Forces compilers to make 32-bit enums. */
    NvDdkDispTvOutput_Force32 = 0x7FFFFFFF,
} NvDdkDispTvOutput;

/**
 * Defines TV types.
 */
typedef enum
{
    /** Specifies television format for the United States and Japan. */
    NvDdkDispTvType_Ntsc = 0x1,

    /** Specifies television format for Europe. */
    NvDdkDispTvType_Pal,

    /** Specifies high definition analog television (EDTV and HDTV). */
    NvDdkDispTvType_Hdtv,

    /** Ignore -- Forces compilers to make 32-bit enums. */
    NvDdkDispTvType_Force32 = 0x7FFFFFFF,
} NvDdkDispTvType;

/**
 * Defines TV filter modes.
 */
typedef enum
{
    /** Specifies all filter weights set to 0. */
    NvDdkDispTvFilterMode_PointSample = 0x1,

    /** Specifies typical lowpass filter. */
    NvDdkDispTvFilterMode_LowPass1,

    /** Specifies heavier lowpass filter */
    NvDdkDispTvFilterMode_LowPass2,

    /**
     * Specifies custom filter. Currently, the custom filter values are hard
     * coded values in DDK.
     */
    NvDdkDispTvFilterMode_Custom,

    /** Ignore -- Forces compilers to make 32-bit enums. */
    NvDdkDispTvFilterMode_Force32 = 0x7FFFFFFF,
} NvDdkDispTvFilterMode;

/**
 * Defines analog TV (NTSC and PAL) screen formats. By default, the
 * TV screen format is \c NvDdkDispTvScreenFormat_Standard_4_3.
 */
typedef enum
{
    /** Specifies screen format to standard 4:3. */
    NvDdkDispTvScreenFormat_Standard_4_3 = 0x1,

    /** Specifies screen format to letterbox. */
    NvDdkDispTvScreenFormat_Letterbox_16_9,

    /** Specifies screen format to squeeze. */
    NvDdkDispTvScreenFormat_Squeeze,

    /** Ignore -- Forces compilers to make 32-bit enums. */
    NvDdkDispTvScreenFormat_Force32 = 0x7FFFFFFF,
} NvDdkDispTvScreenFormat;

/**
 * Content protection types.
 */
typedef enum
{
    /** No content protection. */
    NvDdkDispContentProtection_None = 0x1,

    /** High Definition Content Protection -- used with HDMI displays. */
    NvDdkDispContentProtection_HDCP,

    /** Content protection for standard television. */
    NvDdkDispContentProtection_Macrovision,

    /** Content protection for standard television. */
    NvDdkDispContentProtection_CGMSA,

    /** Ignore -- Forces compilers to make 32-bit enums. */
    NvDdkDispContentProtection_Force32 = 0x7FFFFFFF
} NvDdkDispContentProtection;

typedef enum
{
    /**
     * (READ-ONLY) Type of the display. Common displays are LCD, CTR, and
     * TV. The value corresponding to this attribute is a 32-bit enumerated
     * value of type ::NvDdkDispDisplayType.
     */
    NvDdkDispDisplayAttribute_Type = 0x1,

    /**
     * (READ-ONLY) The usage of the display indicates how the display is used
     * on the device. This attribute allows drivers to determine which
     * display to use. The value corresponding to this attribute is a 32-bit
     * enumerated value of type ::NvDdkDispDisplayUsageType.
     */
    NvDdkDispDisplayAttribute_Usage,

    /**
     * (READ-ONLY) Maximum horizontal resolution of the display, indicating
     * the width of the display in pixels. The value corresponding to this
     * attribute is a 32-bit unsigned integer.
     */
    NvDdkDispDisplayAttribute_MaxHorizontalResolution,

    /**
     * (READ-ONLY) Maximum vertical resolution of the display, indicating
     * the height of the display in pixels. The value corresponding to this
     * attribute is a 32-bit unsigned integer.
     */
    NvDdkDispDisplayAttribute_MaxVerticalResolution,

    /**
     * (READ-ONLY) Color precision indicates precision of colors represented
     * on the display in terms of bits. For example a RGB666 LCD would have
     * an 18-bit color precision. The value corresponding to this attribute is
     * a 32-bit unsigned integer in terms of color precision bits.
     */
    NvDdkDispDisplayAttribute_ColorPrecision,

    /**
     * (READ-ONLY) Capability bit for HDTV analog. The attribute
     * value is an NvBool.
     */
    NvDdkDispDisplayAttribute_SupportsHdtvAnalog,

    /**
     * Brightness. This is a signed Q16 which is added to the color channels
     * before gamma. Default is 0.
     */
    NvDdkDispDisplayAttribute_Brightness,

    /**
     * Gamma correction. The default value for gamma correction is 1.0
     * (i.e. 0x00010000).  This attribute sets the gamma value for
     * red/green/blue or YUV simultaneously. The value corresponding to this
     * attribute is a Q16 (signed 15.16 fixed point value).
     */
    NvDdkDispDisplayAttribute_Gamma,

    /**
     * Same as ::NvDdkDispDisplayAttribute_Gamma, but specified for each color
     * channel.
     */
    NvDdkDispDisplayAttribute_GammaRed,
    NvDdkDispDisplayAttribute_GammaGreen,
    NvDdkDispDisplayAttribute_GammaBlue,

    /**
     * Contrast: scale around mid-grey. Value is expressed as a signed Q15.16.
     * Default is 1.0. The range is from [-1.0,1.0]
     */
    NvDdkDispDisplayAttribute_Contrast,

    /**
     * Backlight control sets the state of the backlight. The attribute type
     * is one of ::NvDdkDispBacklightControl.
     */
    NvDdkDispDisplayAttribute_Backlight,

    /**
     * Backlight intensity sets the backlight brightness. 0 for off, 255
     * for full-bright.
     */
    NvDdkDispDisplayAttribute_BacklightIntensity,

    /**
     * Backlight timeout specified how long the backlight is on after
     * receiving an ::NvDdkDispDisplayAttribute_Backlight with the value
     * ::NvDdkDispBacklightControl_OnStrobe. The value corresponding to this
     * attribute is a 32-bit unsigned integer in terms of milliseconds.
     */
    NvDdkDispDisplayAttribute_BacklightTimeout,

    /**
     * Audio frequency for display types that have audio in the signal (HDMI).
     * One of ::NvDdkDispAudioFrequency. Default is 44.1 kHz.
     */
    NvDdkDispDisplayAttribute_AudioFrequency,

    /**
     * Partial mode line offset. Default is 0. Max is the mode height minus 1.
     */
    NvDdkDispDisplayAttribute_PartialModeLineOffset,

    /**
     * Automatic backlight control.
     * Automatically adjust display brightness based on ambient sensor data,
     * etc. Default is 0=Off. 1=On.
     */
    NvDdkDispDisplayAttribute_AutoBacklight,

    /**
     * TV-sepecific attributes.
     */

    /**
     * The television type; one of ::NvDdkDispTvType.
     */
    NvDdkDispDisplayAttribute_TV_Type,

    /**
     * The connector format for the television; one of ::NvDdkDispTvOutput.
     */
    NvDdkDispDisplayAttribute_TV_OutputFormat,

    /** Overscan compensation. This is a Q1.10 format number. Default
     * should be 1.0, or 1 UL << 10 (1024).
     */
    NvDdkDispDisplayAttribute_TV_Overscan,

    /** Overscan colors. This will be the border color after overscan
     * compensation. Default should be 16 for OverscanY.
     */
    NvDdkDispDisplayAttribute_TV_OverscanY,
    NvDdkDispDisplayAttribute_TV_OverscanCb, //!< Default should be 128.
    NvDdkDispDisplayAttribute_TV_OverscanCr, //!< Default should be 128.

    /**
     * Horizontal position after overscan compensation in Q1.15.16, -63 to 63.
     * Sign bit is 0 for positive, 1 for negative. Default value is 0.
     */
    NvDdkDispDisplayAttribute_TV_HorizontalPosition,

    /**
     * Vertical position after overscan compensation in Q1.15.16, -32 to 32.
     * Default value is 0.
     */
    NvDdkDispDisplayAttribute_TV_VerticalPosition,

    /**
     * TV DAC output amplitude. Adjust this to put the signals into spec since
     * the board layout may affect the signal, etc. The default value is 0xC5.
     * Attribute is 8 bits wide (0-0xFF).
     */
    NvDdkDispDisplayAttribute_TV_DAC_Amplitude,

    /**
     * TV filter mode; one of ::NvDdkDispTvFilterMode.
     */
    NvDdkDispDisplayAttribute_TV_FilterMode,

    /**
     * Analog TV (NTSC and PAL) screen format; one of
     * ::NvDdkDispTvScreenFormat.
     */
    NvDdkDispDisplayAttribute_TV_ScreenFormat,

    NvDdkDispDisplayAttribute_Dsi_Mode,

    NvDdkDispDisplayAttribute_Num,
    /**
     * Ignore -- Forces compilers to make 32-bit enums.
     */
    NvDdkDispDisplayAttribute_Force32 = 0x7FFFFFFF
} NvDdkDispDisplayAttribute;

/**
 * Mirror operations.
 */
typedef enum
{
    /** No mirroring. */
    NvDdkDispMirror_None = 0x1,

    /** Horizontal mirroring. */
    NvDdkDispMirror_Horizontal,

    /** Vertical mirroring. */
    NvDdkDispMirror_Vertical,

    /** Both horizontal and vertical mirroring. */
    NvDdkDispMirror_Both,

    /** Ignore -- Forces compilers to make 32-bit enums. */
    NvDdkDispMirror_Force32 = 0x7FFFFFFF
} NvDdkDispMirror;

/**
 * Window usages.
 */
typedef enum
{
    /**
     * A graphic window is often used for the GUI and RGB rendering in a
     * windowing system.
     */
    NvDdkDispWindowUsage_Graphic = 0x1,

    /**
     * The overlay window is often used for video, as it typically supports
     * YUV formatted surfaces, and better filtering when scaling.
     */
    NvDdkDispWindowUsage_Overlay,

    /**
     * Ignore -- Forces compilers to make 32-bit enums.
     */
    NvDdkDispWindowUsage_Force32 = 0x7FFFFFFF
} NvDdkDispWindowUsage;

/**
 * Window blending.
 */
typedef enum
{
    /**
     * No blending for this window; it simply covers every window with
     * greater depth and is covered by every window with smaller depth.
     */
    NvDdkDispBlendType_None = 0x1,

    /** Alpha blending with the window's background. */
    NvDdkDispBlendType_Alpha,

    /** Alpha blending with the overlapping window based on surface alpha. */
    NvDdkDispBlendType_PerPixelAlpha,

    /** Color keying with the window's background. */
    NvDdkDispBlendType_ColorKey,

    /** Ignore -- Forces compilers to make 32-bit enums. */
    NvDdkDispBlendType_Force32 = 0x7FFFFFFF
} NvDdkDispBlendType;

/**
 * Enumerates possible operations used to count the resulting pixel's
 * color (r) from the window's background's pixel's color (b) and
 * the corresponding window's pixel's color (w). Window's background
 * consists of display's background (which is @b always considered black)
 * and possibly windows with greater depth values, already blended somehow
 * with their backgrounds. The alpha blending value is denoted by (a).
 */
typedef enum
{
    /**
     * The formula is: <pre>   r = b*(1 - a) + w*a    </pre>
     * This is the most common and intuitive case.
     */
    NvDdkDispAlphaOperation_WeightedMean = 0x1,

    /**
     * The formula is: <pre>    r = b + w*a    </pre>
     * Pixels values which exceed their RGB or YUV limits are clamped.
     */
    NvDdkDispAlphaOperation_SimpleSum,

    /**
     * The formula is: <pre>    r = b*(1 - a) + w   </pre>
     */
    NvDdkDispAlphaOperation_PremultipliedWeight,

    /**
     * Ignore -- Forces compilers to make 32-bit enums.
     */
    NvDdkDispAlphaOperation_Force32 = 0x7FFFFFFF
} NvDdkDispAlphaOperation;

/**
 * Blending direction - alpha blending may be applied to the bottom surface
 * or the top surface.
 *
 * Premultipled alpha blending defaults to source alpha. Other alpha blending
 * defaults to destination.
 */
typedef enum
{
    /* use the default */
    NvDdkDispAlphaBlendDirection_Default = 0x1,

    /* the surface with the alpha pixels is on top of the dependent surface. */
    NvDdkDispAlphaBlendDirection_Source,

    /* the surface with the alpha pixels is under the dependent surface. */
    NvDdkDispAlphaBlendDirection_Destination,

    NvDdkDispAlphaBlendDirection_Force32 = 0x7FFFFFFF,
} NvDdkDispAlphaBlendDirection;

/**
 * Window attributes.
 */
typedef enum
{
    /**
     * (READ-ONLY) Window number indicates a unique numerical value for the
     * window. The window number is used as a tie-breaker in determining which
     * window appears above another when two windows are set to the
     * same ::NvDdkDispWindowAttribute_Depth. The window with the lower number
     * appears above windows with the same depth and higher window
     * numbers. The value corresponding to this attribure is a unsigned
     * 32-bit integer.
     */
    NvDdkDispWindowAttribute_Number = 0x1,

    /**
     * (READ-ONLY) Window usage described the intended use of the window.
     * The value corresponding to this type is a 32-bit enumerated value
     * of type ::NvDdkDispWindowUsage.
     */
    NvDdkDispWindowAttribute_Usage,

    /**
     * (READ-ONLY) Capability bit for color space conversion. The attribute
     * value is an NvBool.
     */
    NvDdkDispWindowAttribute_SupportsColorSpaceConversion,

    /**
     * (READ-ONLY) Capability bit for horizontal filtering. The attribute
     * value is an NvBool.
     */
    NvDdkDispWindowAttribute_SupportsHorizontalFiltering,

    /**
     * (READ-ONLY) Capability bit for vertical filtering. The attribute
     * value is an NvBool.
     */
    NvDdkDispWindowAttribute_SupportsVerticalFiltering,

    /**
     * (READ-ONLY) Capability bit for premultiplied alpha. The attribute
     * value is an NvBool.
     */
    NvDdkDispWindowAttribute_SupportsPremultipliedAlpha,

    /**
     * Depth indicates the Z-order of the window relative to other active
     * windows on the same controller. Lower values appear above higher
     * values. Window depth is used when alpha blending the contents of
     * multiple windows. The value corresponding to this attribute is an
     * unsigned 32-bit integer (0 is on top).
     */
    NvDdkDispWindowAttribute_Depth,

    /**
     * Rotation indicates the angle of clockwise rotation for the window.
     * The value corresponding to this attribute is an unsigned 32-bit integer,
     * where the value indicates the angle of rotation. Only 90 degree angles
     * are supported. The value should be one of 0, 90, 180, 270. Typical
     * windows only support 0 and 180 degrees of rotation.
     */
    NvDdkDispWindowAttribute_Rotation,

    /**
     * Mirroring indicates what mirroring is used, if any, for the window. This
     * operation is applied @b post rotation, if any. The value corresponding
     * to this attribute is a 32-bit enumerated value of type
     * ::NvDdkDispMirror.
     */
    NvDdkDispWindowAttribute_Mirror,

    /**
     * Source rectangle of visible pixels from the surface for display
     * in the window. If the source rectangle exceeds the dimensions of
     * the source surface, the values are clamped to that of the source
     * surface dimensions. The rectangle fields are in pixels.
     */
    NvDdkDispWindowAttribute_SourceRect_Left,
    NvDdkDispWindowAttribute_SourceRect_Top,
    NvDdkDispWindowAttribute_SourceRect_Right,
    NvDdkDispWindowAttribute_SourceRect_Bottom,

    /**
     * Window rectangle indicating where the window is positioned relative
     * to the mode on the controller.  If the destination rectangle exceeds
     * the dimensions of the mode, the values are clamped to that of the
     * mode. The combination of the source rectangle and the destination
     * rectangle determine what scaling is applied to the source surface.
     * The the width and height of the source and destination rectangles
     * are the same, no scaling is used.
     */
    NvDdkDispWindowAttribute_DestRect_Left,
    NvDdkDispWindowAttribute_DestRect_Top,
    NvDdkDispWindowAttribute_DestRect_Right,
    NvDdkDispWindowAttribute_DestRect_Bottom,

    /**
     * Window location X and Y are used to move the visible location
     * of the window relative to the mode on the controller. Changing the
     * location of the window has the side effect of updating the destination
     * rectangle of the window. This atribute should be used to reposition
     * a window without changing its dimensions.
     */
    NvDdkDispWindowAttribute_Location_X,
    NvDdkDispWindowAttribute_Location_Y,

    /**
     * This option allows filtering for the selected window. The value
     * corresponding to this attribute is a 32-bit enum of type NvBool.
     * By default this feature is disabled (i.e., NV_FALSE).
     *
     * This enables both horizontal and vertical filtering.
     */
    NvDdkDispWindowAttribute_Filtering,

    /**
     * Same as NvDdkDispWindowAttribute_Filtering, but just enables horizontal
     * filtering.
     */
    NvDdkDispWindowAttribute_Filtering_Horizontal,

    /**
     * Same as NvDdkDispWindowAttribute_Filtering, but just enables horizontal
     * filtering.
     */
    NvDdkDispWindowAttribute_Filtering_Vertical,

    /**
     * Allows digital vibrance in the window. If enabled, digital vibrance is
     * applied after H and V scaling and after color palette or color space
     * conversion logic but before color keying multiplexer.
     *
     * - After DV, new R = R + (2R - G - B) * FR, where FR is fraction
     * from 0 to 7/8
     * - After DV, new G = G + (2G - R - B) * FG, where FG is fraction
     * from 0 to 7/8
     * - After DV, new B = B + (2B - R - G) * FB, where FB is fraction
     * from 0 to 7/8
     *
     * The value corresponding to this attribute is a 32-bit unsigned integer,
     * where bits 2:0 define FR, bits 10:8 define FG and bits 18:16 define FB.
     * By default this feature is disabled (i.e. 0x00000000).
     */
    NvDdkDispWindowAttribute_DigitalVibrance,

    /**
     * Nice scaling is used to allow the implementation to adjust the
     * destination rectangle when scaling pixels from the source image
     * should the required scaling @b not be supported. This has the side
     * effect of causing the dest rectangle attributes to be adjusted. This
     * attribute should be used to simplify work for the caller in handling
     * errors that may occur from unsupported scaling ratios. The value
     * corresponding to this attribute is a 32-bit enum of type NvBool.
     * By default this feature is disabled (i.e., NV_FALSE).
     */
    NvDdkDispWindowAttribute_ScaleNicely,

    /**
     * Indicates the type of blending with this window's background.
     * Window's background consists of display's background (which is always
     * considered black) and possibly windows with greater depth values,
     * already blended somehow with their backgrounds. The value corresponding
     * to this attribute is a 32-bit enum of type ::NvDdkDispBlendType. By
     * default blending is disabled (i.e., ::NvDdkDispBlendType_None).
     */
    NvDdkDispWindowAttribute_BlendType,

    /**
     * If alpha blending is enabled, this attribute indicates the operation
     * used to count the resulting pixel's color from the window's
     * background's pixel's color and the corresponding window's pixel's
     * color. The value corresponding to this attribute is a 32-bit enum of
     * type ::NvDdkDispAlphaOperation. By default the operation is set to
     * weighted pixel colors mean (i.e.
     * ::NvDdkDispAlphaOperation_WeightedMean).
     */
    NvDdkDispWindowAttribute_AlphaOperation,

    /**
     * If blending is enabled, this attribute indicates the alpha blending
     * value used when counting the resulting pixel's color (the value
     * is used in alpha blending operations).
     * The value corresponding to this attribute is an 8-bit unsigned integer.
     * By default this attribute is set to 0xff.
     */
    NvDdkDispWindowAttribute_AlphaValue,

    /**
     * Choose which alpha blending direction to use, either source or
     * destination. Value is one of NvDdkDispAlphaBlendDirection.
     */
    NvDdkDispWindowAttribute_AlphaDirection,

    /**
     * If color keying is enabled, this attribute defines the color
     * key value for this window. The color format is a 32-bit A8R8G8B8 value,
     * where A is bits 31:24 through R in 23:16, G in 15:8, and B in bits 7:0
     * if the surface format is A8R8G8B8 or a YUV surface (planar or packed),
     * otherwise, the color key format matches the surface format. By default,
     * this is set to zero. This changes both the upper and lower color key
     * simultaneously (to the same value).
     */
    NvDdkDispWindowAttribute_ColorKey,

    /**
     * If color keying is enabled, these attributes indicate the range of
     * the color key used in this window. See
     * ::NvDdkDispWindowAttribute_ColorKey for format details.
     */
    NvDdkDispWindowAttribute_ColorKeyLower,
    NvDdkDispWindowAttribute_ColorKeyUpper,

    /**
     * YUV color space conversion is used when converting from a YUV formatted
     * surface a window is reading from, as it is passed to the display. This
     * attribute can be used to adjust the color conversion matrix, ultimately
     * effecting brightness and contrast of the YUV data.
     *
     * The YUV color space conversion formulae appears as follows:
     * <pre>
     *         R = C11*(Y + K) + C12*U + C13*V
     *         G = C11*(Y + K) + C22*U + C23*V
     *         B = C11*(Y + K) + C32*U + C33*V     </pre>
     *
     * Where the matrix typically appears as
     * <pre>
     *         C11, C12, C13            1.1644   0.0000   1.5960
     *         C11, C22, C23     =      1.1644  -0.3918  -0.8130
     *         C11, C32, C33            1.1644   2.0172   0.0000    </pre>
     * and K = -16.0000
     *
     *
     * The value corresponding to each of these fields are a Q16 (signed 15.16
     * fixed point value)
     */
    NvDdkDispWindowAttribute_ColorSpaceCoef_C11,
    NvDdkDispWindowAttribute_ColorSpaceCoef_C12,
    NvDdkDispWindowAttribute_ColorSpaceCoef_C13,
    NvDdkDispWindowAttribute_ColorSpaceCoef_C22,
    NvDdkDispWindowAttribute_ColorSpaceCoef_C23,
    NvDdkDispWindowAttribute_ColorSpaceCoef_C32,
    NvDdkDispWindowAttribute_ColorSpaceCoef_C33,
    NvDdkDispWindowAttribute_ColorSpaceCoef_K,

    NvDdkDispWindowAttribute_Num,
    /** Ignore -- Forces compilers to make 32-bit enums. */
    NvDdkDispWindowAttribute_Force32 = 0x7FFFFFFF
} NvDdkDispWindowAttribute;

/**
 * Opens the display DDK.
 *
 * @pre This must be called before any other NvDdkDisp methods can be used.
 *
 * This function detects the device and initializes all client specific data
 * for this instance of the API.
 *
 * @param hDevice Handle to the system device.
 * @param hDisp Handle to the display API returned as non-NULL on success.
 * @param flags 32-bit value containing one or more bit flags
 *      (reserved - set to zero).
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispOpen(
    NvRmDeviceHandle hDevice,
    NvDdkDispHandle *hDisp,
    NvU32 flags );

/**
 * Closes the display DDK.
 *
 * @pre This must be called when the client has completed using NvDdkDisp.
 *
 * Any resources allocated for this instance of the interface are released.
 *
 * @param hDisp Handle to the display API.
 * @param flags Reserved, must be 0x0.
 *
 */
void
NvDdkDispClose(
    NvDdkDispHandle hDisp,
    NvU32 flags );

/**
 * List the controllers on a device.
 *
 * This function is used to identify the controllers on a device.
 *
 * Two calls should be made:
 * -# On the first call, the method populates the number of controllers on the
 * device in \a pNum.  When this call is issued \a phController should be NULL.
 *
 * -# On the second call, the length of the \a phController array is indicated
 * by the value of \a *pNum.  When \a pNum is less than the number of
 * controllers the method populates the \a phController array with only the
 * first \a pNum controllers. When is more than the number of controllers, the
 * method populates the \a phController array with the number of controllers
 * and writes the number of controllers into \a pNum.
 *
 * @note The number of controllers can change between calls to this
 * function.
 *
 * Using ::NVDDK_DISP_MAX_CONTROLLERS instead of the first query call is okay.
 *
 * @param hDisp Handle to the display API.
 * @param pNum Unsigned integer value indicating the number of
 *      controllers in the array \a phController. This value is
 *      populated with the number of controllers on return.
 * @param phController A pointer to an array of controller handles populated
 *      on success.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispListControllers(
    NvDdkDispHandle hDisp,
    NvU32 *pNum,
    NvDdkDispControllerHandle *phController );

/**
 * Lists the displays for a controller.
 *
 * This function is used to identify the displays that can be attached to
 * a controller on the device.
 *
 * A display will be listed on each controller it can be attached to.
 * For example, an LCD that can be connected to either of 2 controllers will
 * be listed by both controllers.
 *
 * The first display listed on the controller is the primary or recomended
 * display for the controller.
 *
 * Two calls should be made:
 * -# On the first call, the function populates the number of displays on the
 * device in \a pNum. When this call is issued \a phDisplay should be NULL.
 * -# On the second call, the length of the \a phDisplay array is indicated by
 * the value of \a *pNum. When \a pNum is less than the number of displays the
 * function populates the \a phDisplay array with only the first \a pNum
 * displays. When is more than the number of displays, the method
 * populates the \a phDisplay array with the given number of displays and
 * writes the number of displays into \a pNum.
 *
 * @note The number of displays can change between calls to this
 * function.
 *
 * Using ::NVDDK_DISP_MAX_DISPLAYS instead of the first query call is okay.
 *
 * @param hController Handle to a controller on the device.
 * @param pNum Unsigned integer value indicating the number of
 *      displays in the array \a phDisplay. This value is
 *      populated with the number of displays on return.
 * @param phDisplay A pointer to an array of display handles, populated on
 *      success.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispListDisplays(
    NvDdkDispControllerHandle hController,
    NvU32 *pNum,
    NvDdkDispDisplayHandle *phDisplay );

/**
 * Gets a display by type.
 *
 * This function is used as a simpler method than ::NvDdkDispListDisplays
 * to query a specific display by its usage on a controller. By
 * providing the usage of the display, the handle to the display can
 * be returned.
 *
 * @note When there are more than one display of the same usage, the
 * first display of the usage that would appear in ::NvDdkDispListDisplays is
 * returned.
 *
 * @param hController Handle to a controller on the device.
 * @param usage Identifies the usage of display to query.
 * @param phDisplay A pointer to a display handle, populated on success.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispGetDisplayByUsage(NvDdkDispControllerHandle hController,
    NvDdkDispDisplayUsageType usage,
    NvDdkDispDisplayHandle *phDisplay);

/**
 * Gets a display by its GUID.
 *
 * Each display will have a GUID (a unique identifier) that is stored in the
 * ODM peripheral database. Applications wanting a specific display may
 * query the database to find the correct GUID, which is used to to get a
 * display handle.
 *
 * @param hController Handle to a controller on the device.
 * @param guid The GUID from the peripheral database.
 * @param phDisplay A pointer to a display handle, populated on success.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispGetDisplayByGuid( NvDdkDispControllerHandle hController,
    NvU64 guid,
    NvDdkDispDisplayHandle *phDisplay);

/**
 * Lists the windows on a controller.
 *
 * Two calls should be made to this function:
 * -# On the first call, the function populates the number of windows on the
 * device in \a pNum. When this call is issued \a phWindow should be NULL.
 * -# On the second call, the length of the \a phWindow array is indicated by
 * the value of \a *pNum. When \a pNum is less than the number of windows the
 * function populates the \a phWindow array with only the first \a pNum
 * windows. When is more than the number of controllers, the function
 * populates the \a phWindow array with the number of controllers and
 * writes the number of controllers into \a pNum.
 *
 * @note The number of windows can change between calls to this function.
 *
 * Using ::NVDDK_DISP_MAX_WINDOWS instead of the first query call is okay.
 *
 * @param hController Handle to a controller on the device.
 * @param pNum Unsigned integer value indicating the number of
 *      windowos in the array \a phWindow. This value is
 *      populated with the number of windows on return.
 * @param phWindow A pointer to an array of window handles, populated on
 *      success.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispListWindows(NvDdkDispControllerHandle hController,
    NvU32 *pNum,
    NvDdkDispWindowHandle *phWindow);

/**
 * Flushes pending changes to a controller, including all windows and attached
 * displays.
 *
 * @param hController Handle to a controller on the device.
 * @param flags Resvered; must be zero.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispFlush( NvDdkDispControllerHandle hController,
    NvU32 flags );

/**
 * Frees any nonessential caches for use in low-memory situations.
 *
 * @param hController Handle to a controller on the device.
 * @param flags One of \c NVDDK_DISP_CACHE_CLEAR_*, or zero.
 */
void
NvDdkDispCacheClear( NvDdkDispControllerHandle hController,
    NvU32 flags );
#define NVDDK_DISP_CACHE_CLEAR_ALL      (0x0)

/**
 * Lists the modes of display.
 *
 * Two calls should be made to this function:
 * -# On the first call, the function populates the number of modes, for the
 * display. When this call is issued \a pMode (and \a *pNum) should be NULL.
 * -# On the second call, the length of the \a pMode array is indicated by
 * the value of \a *pNum. When \a pNum is less than the number of modes the
 * function populates the \a pMode array with only the first \a pNum modes.
 * When is more than the number of modes, the function populates the
 * \a pMode array with the number of modes and writes the number of modes
 * into \a pNum.
 *
 * @note The number of modes can change between calls to this function.
 *
 * The first mode enumerated by this function is the recomended (default) mode
 * for the display.
 *
 * @param hDisplay Handle to a display.
 * @param pNum Unsigned integer value indicating the number of modes in
 *      the array \a pMode.
 * @param pMode A pointer to an array of mode structures, where the size of
 *      the array is determined by the value in \a pNum.
 * @param flags 32=bits of behavior control, defined as:
 *    - ::NVDDK_DISP_LISTMODES_ALL - retrieve all modes.
 *    - ::NVDDK_DISP_LISTMODES_FULL - only retrieve full screen (normal) modes.
 *    - ::NVDDK_DISP_LISTMODES_PARTIAL - only retrieve partial mode(s)
 *      OR with the following bit to avoid EDID reads:
 *    - ::NVDDK_DISP_LISTMODES_SKIP_EDID - skip EDID reads.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispListDisplayModes(
    NvDdkDispDisplayHandle hDisplay,
    NvU32 *pNum,
    NvDdkDispMode *pMode,
    NvU32 flags);

#define NVDDK_DISP_LISTMODES_ALL            (0x0)
#define NVDDK_DISP_LISTMODES_FULL           (0x1)
#define NVDDK_DISP_LISTMODES_PARTIAL        (0x2)
#define NVDDK_DISP_LISTMODES_INTERLACED     (0x4)
#define NVDDK_DISP_LISTMODES_SKIP_EDID      (0x8)
#define NVDDK_DISP_LISTMODES_EDID_ERROR     (0x10)
#define NVDDK_DISP_LISTMODES_RESERVED       (0x10000000)

/**
 * Attaches to a display controller.
 *
 * This function attaches a display to a controller. A display can only be
 * attached to a controller that does not have a mode set. Any controller
 * with an active mode will not accept attaching of the display.
 *
 * Attaching a display to a NULL controller results in detaching the display
 * from the controller it is currently attached to, if any. If the controller
 * no longer has any displays attached, this function has the side effect of
 * setting the controller to a NULL mode.
 *
 * Detaching a display from a controller is equivalent to turning off the
 * display. To keep the display active when detaching a display the caller
 * should set the NVDDK_DISP_ATTACH_LEAVEON flag to indicate that the display
 * should remain active. This flag is primarily useful for retaining image
 * data in panels which are refreshed from their own memory.
 *
 * @param hController Handle to a controller on the device.
 * @param hDisplay Handle to a display.
 * @param flags 32-bit value containing zero or more bit flags defined as:
 *    - ::NVDDK_DISP_ATTACHDISPLAY_LEAVEON - flag is used to keep a
 *          detached display active.
 *    - ::NVDDK_DISP_ATTACHDISPLAY_REATTACH - flag is used connect to a
 *          previously detached CLI LCD display.
 *    - 0 - default behavior is used (CLILCDs will be disabled on detach or
 *          reprogramming on attach).
 *
 * @retval NvError_DispAlreadyAttached If the display is already attached.
 * @retval NvError_DispTooManyDisplays If the controller has too many displays.
 */
NvError
NvDdkDispAttachDisplay(
    NvDdkDispControllerHandle hController,
    NvDdkDispDisplayHandle hDisplay,
    NvU32 flags);

#define NVDDK_DISP_ATTACHDISPLAY_LEAVEON     (0x1)
#define NVDDK_DISP_ATTACHDISPLAY_REATTACH    (0x2)

/**
 * Determines to which controller a display is attached.
 *
 * When attached, the handle of the controller the display is attached to
 * is returned. When the display is detached (i.e., not attached) NULL is
 * returned as the controller handle.
 *
 * Each display can only be connected to one controller at a time, but
 * a single controller may be connected to more than one display at a time.
 *
 * @param hDisplay Handle to the display.
 * @param phController A pointer to a controller handle.
 * @param flags Reserved; must be 0x0.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispIsDisplayAttached(
    NvDdkDispDisplayHandle hDisplay,
    NvDdkDispControllerHandle *phController,
    NvU32 flags);

/**
 * Updates the contents of a smart (has its own embedded memory) display.
 *
 * This behaves similarly as ::NvDdkDispFlipWindowSurface, except it can
 * optionally update part of a surface. The flags, fence, and stream are the
 * same as those of \c NvDdkDispFlipWindowSurface.
 *
 * @param hDisplay Handle to the display to update
 * @param hWindow Handle to the window to update
 * @param surf Handle to a surface(s) used as a source for the window.
 * @param count Number of surfaces for planar formats.
 * @param pSrc A pointer into the source surface.
 * @param pUpdate Rectangular region on the display to update from the
 *      source surface.
 * @param stream A pointer to a stream object that will receive the flip
 *      commands if the update surface is the same as the current surface (for
 *      "front-buffer" rendering use cases)
 * @param fence A pointer to a fence containing
 * @param flags 32-bit value containing zero or more bit flags:
 *      - ::NVDDK_DISP_WAIT
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispDisplayUpdate(
    NvDdkDispDisplayHandle hDisplay,
    NvDdkDispWindowHandle hWindow,
    NvRmSurface *surf,
    NvU32 count,
    NvPoint *pSrc,
    NvRect *pUpdate,
    NvRmStream *stream,
    NvRmFence *fence,
    NvU32 flags );

/**
 * Gets the best mode for the controller.
 *
 * With one or more displays attached to the same controller, determining
 * the mode which meets the constraints of the displays and the controller
 * is non-trivial. This function reviews the capabilities of attached displays
 * and the constraints of the controller to determining the best mode for the
 * controller.
 *
 * This function returns the best mode for the controller. It does not indicate
 * what mode is currently set on the controller, if any.
 * If there is no display connected to this controller, all fields of
 * \a *pMode are set to 0.
 *
 * @param hController Handle to a controller on the device.
 * @param pMode A pointer to structure containing the best mode for the
 *      controller.
 * @param flags Reserved; must be 0x0.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispGetBestMode(
    NvDdkDispControllerHandle hController,
    NvDdkDispMode *pMode,
    NvU32 flags);

/**
 * Gets the controller's current mode.
 *
 * @param hController Handle to a controller on the device.
 * @param pMode A pointer to structure containing the mode currently set on
 *      the controller on successful return. If the controller is working in
 *      the NULL mode, all fields of this structure are set to 0x0.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispGetMode(
    NvDdkDispControllerHandle hController,
    NvDdkDispMode *pMode);

/**
 * Sets the controller mode.
 *
 * To set the mode, one or more displays must be attached to the controller.
 *
 * When \a pMode is non-NULL it must specify a mode that is supported by
 * all displays attached to the controller. With more than one display
 * is connected to a controller it is recomended that NvDdkDispGetBestMode()
 * is used to identify the ideal mode for the combination of displays attached
 * to the controller. Any displays connected to the controller are
 * automatically turned on.
 *
 * When the state of the controller and attached displays already match
 * the requested mode, the function optimizes out reprogramming of the
 * devices. To override this the caller should set the
 * ::NVDDK_DISP_SETMODE_ALWAYS flag in the flags field.
 *
 * To copy out the state of the mode from the hardware if the hardware is
 * already initialized (from the boot loader, etc.), use
 * ::NVDDK_DISP_SETMODE_SHADOW.
 *
 * When \a pMode is NULL the controller is disabled, and any attached displays
 * are set to the off state.
 *
 * @param hController Handle to a controller on the device.
 * @param pMode A pointer to structure containing a mode to set on the
 *       controller. If NULL the controller is disabled.
 * @param flags 32-bit value containing zero or more bit flags defined as:
 *     - ::NVDDK_DISP_SETMODE_ALWAYS - always reprogram the hardware.
 *     - ::NVDDK_DISP_SETMODE_SHADOW - copy out state and do not touch
 *          hardware.
 *     - ::NVDDK_DISP_SETMODE_BEST - use the best mode for the display. This
 *           is an optimization to avoid querying the best mode. \a pMode
 *           should be 0x0.
 *     - ::NVDDK_DISP_WAIT
 *     - ::NVDDK_DISP_DEBUG - outputs some debug information
 *     - 0 - use defaults, which are \c SETMODE_ALWAYS and \c WAIT.
 *
 * @retval NvError_DispModeNotSupported if the mode is not supported
 * @retval NvError_DispNoDisplaysAttached if there are no attached displays
 */
NvError
NvDdkDispSetMode(
    NvDdkDispControllerHandle hController,
    NvDdkDispMode *pMode,
    NvU32 flags);

#define NVDDK_DISP_SETMODE_ALWAYS           (0x1)
#define NVDDK_DISP_SETMODE_SHADOW           (0x2)
#define NVDDK_DISP_SETMODE_BEST             (0x4)

/**
 * Sets the active window surface.
 *
 * This function sets the surface used as the source for a window. The change
 * takes effect on the next vertical blank. If the window is sourcing from
 * an existing surface, the window switches to the surface specified. If
 * the specified surface is NULL, the window is turned off.
 *
 * For planar formats, the first surface in the array must be the @b main
 * surface (Y in the case of planar yuv).
 *
 * @note Scaling the source surface size to the destination size
 * has some limitations. Downscaling beyond 2x is not recommended due to
 * power inefficiencies (also may be clocking issues). Upscaling is unlimited,
 * but quality will depend on the window hardware (which may not be the same).
 * Scaling surfaces with text also may not have good visual quality.
 *
 * @param hWindow Handle to the window.
 * @param surf Surface array used as a source for the window.
 * @param count Number of surfaces (for planar formats).
 * @param flags 32-bit value containing zero or more bit flags defined as:
 *    - ::NVDDK_DISP_WAIT
 *    - ::NVDDK_DISP_DO_NOT_COMMIT
 *    - ::NVDDK_DISP_SURFACE_LEAVEON: leave the controller running with the
 *          background color if all surfaces are null.
 *    - ::NVDDK_DISP_DEBUG
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError NvDdkDispSetWindowSurface(
    NvDdkDispWindowHandle hWindow,
    NvRmSurface *surf,
    NvU32 count,
    NvU32 flags);

#define NVDDK_DISP_SURFACE_LEAVEON  (0x1)

/**
 * Retrieves the surface that is currently attached to the given window.
 *
 * A count is given to select how many surfaces to get (for planar formats).
 * A null surface may be given to retrive the number of surfaces.
 *
 * @param hWindow Handle to the window.
 * @param surf A pointer to the surfaces for the window: the display's surface
 *      fields will be copied into the given surface(s).
 * @param count Number of surfaces to copy out.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispGetWindowSurface(
    NvDdkDispWindowHandle hWindow,
    NvRmSurface *surf,
    NvU32 *count );

/**
 * Performs a fast surface flip. The new surface must be the same size and
 * color depth as the previous surface.
 *
 * An optional stream pointer may be given. If non-null, the commands to flip
 * the surface will be pushed into the stream, otherwise, the flip will
 * happen immediately (writes to the hardware's active state).
 *
 * If \a fence is specified, the flip will happen immediately (the stream will
 * be flushed if 'stream' is non-null).
 *
 * @note \a fence may not be specified without a \a stream.
 *
 * If the controller is not active, then the surface will be bound to the
 * controller with NvDdkDispSetWindowSurface.
 *
 * Flags:
 *  - ::NVDDK_DISP_FLIP_WAIT_FENCE: \a fence will have a sync point ID and
 *      value to wait for before the flip. This is useful for synchronization
 *      with other hardware modules, such as 2D.
 *
 *  - ::NVDDK_DISP_FLIP_NO_VSYNC_FENCE: should be used with
 *      \c NVDDK_DISP_FLIP_WAIT_FENCE. This prevents the wait for vsync if a
 *      fence is given.
 *
 * @param hWindow Handle to the window.
 * @param surf Surface array used as a source for the window.
 * @param count Number of surfaces (for planar formats).
 * @param stream Command stream; see note above.
 * @param fence The sync point ID/value that indicate the flip has finished.
 * @param flags Reserved; must be zero.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispFlipWindowSurface(
    NvDdkDispWindowHandle hWindow,
    NvRmSurface *surf,
    NvU32 count,
    NvRmStream *stream,
    NvRmFence *fence,
    NvU32 flags );

#define NVDDK_DISP_FLIP_WAIT_FENCE      (0x1)
#define NVDDK_DISP_FLIP_NO_VSYNC_FENCE  (0x2)

/**
 * Queries a window for supported color formats.
 *
 * @param hWindow Handle to the window.
 * @param format The window format.
 */
NvBool
NvDdkDispWindowSupportsFormat(
    NvDdkDispWindowHandle hWindow,
    NvColorFormat format );

/**
 * Queries a window for supported surfaces (planar YUV, for instance).
 *
 * @param hWindow Handle to the window.
 * @param surfs Pointer to the surface(s)
 * @param num Number of surfaces
 */
NvBool
NvDdkDispWindowSupportsSurface(
    NvDdkDispWindowHandle hWindow,
    NvRmSurface *surfs,
    NvU32 num );

/**
 * Sets one controller attribute.
 *
 * @param hController Handle to a controller.
 * @param attribute The attribute ID indicating the attribute of the controller
 *      to set.
 * @param value The attribute value.
 * @param flags Reserved; must be zero.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispSetControllerAttribute(
    NvDdkDispControllerHandle hController,
    NvDdkDispControllerAttribute attribute,
    NvU32 value,
    NvU32 flags);

/**
 * Sets multiple controller attributes.
 *
 * If one or more of the attributes are incorrect, @b none of the attributes
 * are set.
 *
 * @param hController Handle to a controller.
 * @param pAttributes A pointer to an array of one or more enumerated values
 *      indicating the attribute of the controller to set.
 * @param pValues A pointer to an array of one or more values corresponding
 *      to the specific attributes being set on the controller.
 * @param nAttr The number of parameters to set.
 * @param flags Reserved; must be zero.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispSetControllerAttributes(
    NvDdkDispControllerHandle hController,
    NvDdkDispControllerAttribute *pAttributes,
    const NvU32 *pValues,
    NvU32 nAttr,
    NvU32 flags);

/**
 * Gets a controller attribute.
 *
 * This function queries one attribute on the controller.
 *
 * @param hController Handle to a controller.
 * @param attribute An enumerated value indicating the attribute of the
 *      controller to return.
 * @param pValue A pointer to a value corresponding to the specific attribute
 *      being queried on the controller.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispGetControllerAttribute(
    NvDdkDispControllerHandle hController,
    NvDdkDispControllerAttribute attribute,
    NvU32 *pValue );

/**
 * Sets one display attribute.
 *
 * @param hDisplay Handle to a display.
 * @param attribute The attribute ID of the display attribute to set.
 * @param value The value of the attribute.
 * @param flags Reserved; must be zero.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispSetDisplayAttribute(
    NvDdkDispDisplayHandle hDisplay,
    NvDdkDispDisplayAttribute attribute,
    NvU32 value,
    NvU32 flags);

/**
 * Sets multiple display attributes.
 *
 * Sets one or more display attributes atomically. If one or more of the
 * attributes are incorrect, @b none of the attributes are set.
 *
 * @param hDisplay Handle to a display.
 * @param pAttributes A pointer to an array of one or more enumerated values
 *      indicating the attribute of the display to set.
 * @param pValues A pointer to an array of one or more values corresponding
 *      to the specific attributes being set on the display.
 * @param nAttr The number of attributes.
 * @param flags Reserved; must be zero.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispSetDisplayAttributes(
    NvDdkDispDisplayHandle hDisplay,
    NvDdkDispDisplayAttribute *pAttributes,
    const NvU32 *pValues,
    NvU32 nAttr,
    NvU32 flags);

/**
 * Gets a single display attribute.
 *
 * This function queries one attribute on the display.
 *
 * @param hDisplay Handle to a display.
 * @param attribute An enumerated value indicating the attribute of the
 *      display to return.
 * @param pValue A pointer to a value corresponding to the specific attribute
 *      being queried on the display.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispGetDisplayAttribute(
    NvDdkDispDisplayHandle hDisplay,
    NvDdkDispDisplayAttribute attribute,
    NvU32 *pValue );

/**
 * Sets one window attribute.
 *
 * @param hWindow Handle to a window.
 * @param attribute The attribute ID for the window attribute to set.
 * @param value The attribute value.
 * @param flags 32-bit value containing zero or more bit flags defined as:
 *   - ::NVDDK_DISP_WAIT
 *   - ::NVDDK_DISP_DO_NOT_COMMIT
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispSetWindowAttribute(
    NvDdkDispWindowHandle hWindow,
    NvDdkDispWindowAttribute attribute,
    NvU32 value,
    NvU32 flags);

/**
 * Sets multiple window attributes.
 *
 * Sets one ore more window attributes atomically. If one or more of the
 * attributes are incorrect, @b none of the attributes are set.
 *
 * @param hWindow Handle to a window.
 * @param pAttributes A pointer to an array of one or more enumerated values
 *      indicating the attribute of the window to set.
 * @param pValues A pointer to an array of one or more values corresponding
 *      to the specific attributes being set on the window.
 * @param nAttr The number of attributes.
 * @param flags 32-bit value containing zero or more bit flags defined as:
 *   - ::NVDDK_DISP_WAIT
 *   - ::NVDDK_DISP_DO_NOT_COMMIT
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispSetWindowAttributes(
    NvDdkDispWindowHandle hWindow,
    NvDdkDispWindowAttribute *pAttributes,
    const NvU32 *pValues,
    NvU32 nAttr,
    NvU32 flags);

/**
 * Gets a single window attribute.
 *
 * @param hWindow Handle to a window.
 * @param attribute An enumerated value indicating the attribute of the
 *      window to return.
 * @param pValue A pointer to a value corresponding to the specific attribute
 *      being queried on the window.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispGetWindowAttribute(
    NvDdkDispWindowHandle hWindow,
    NvDdkDispWindowAttribute attribute,
    NvU32 *pValue );

/**
 * Suspends a controller.
 *
 * This function is used to suspend a controller and all displays
 * attached to the controller. By suspending a controller the
 * power consumed by the controller and attached displays are
 * minimized.
 *
 * Setting a controller to a NULL mode can have the same effect of
 * reducing power, except that the caller must remember the state
 * and reprogram the mode on recovery. By explicitly using suspend,
 * the caller can rely on the function to save and restore the correct
 * display state.
 *
 * A controller with no active mode can be suspended.
 *
 * @param hController Handle to a controller.
 * @param flags Reserved; must be 0x0.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError NvDdkDispControllerSuspend(
    NvDdkDispControllerHandle hController,
    NvU32 flags);

/**
 * Resumes the controller.
 *
 * This function is used to resume a controller and all displays
 * attached to the controller. By resuming a controller the
 * mode prior to suspending the controller is restored.
 *
 * A resumed controller with no active mode will not have an
 * active mode and will remain in a low power state.
 *
 * @param hController Handle to a controller.
 * @param flags Either zero, or one of the following:
 *   - ::NVDDK_DISP_WAIT
 *   - ::NVDDK_DISP_DEBUG
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispControllerResume(
    NvDdkDispControllerHandle hController,
    NvU32 flags);

/**
 * Configures the hardware cursor.
 *
 * Cursors are a 2-bit/pixel transparent image format. The only supported
 * dimensions are 32x32 and 64x64. Each 32-bit word stores 16 pixels, with
 * the following bit ordering (0 represents the left-most pixel, F
 * represents the right-most):
 * <pre>
 *         3
 *         1  "X subword"  |  "A subword"  0
 *         +----------------+----------------+
 *         |FEDCBA9876543210|FEDCBA9876543210|
 *         +----------------+----------------+    </pre>
 *
 * 32x32 cursors have two 16-pixel words followed by two padding words
 * per row, 64x64 cursors have four 16-pixel words with no padding. Each
 * pixel is composed of 2 bits, "A" and "X".  The meaning of these bits is
 * defined below:
 * <pre>
 *         +---+---+------------------------------+
 *         | A | X |  Description                 |
 *         +---+---+------------------------------+
 *         | 0 | 0 | Use Cursor Background Color  |
 *         +---+---+------------------------------+
 *         | 0 | 1 | Use Cursor Foreground Color  |
 *         +---+---+------------------------------+
 *         | 1 | 0 | Use Pixel Color              |
 *         +---+---+------------------------------+
 *         | 1 | 1 | Use Inverse Pixel Color      |
 *         +---+---+------------------------------+    </pre>
 *
 * The cursor must be positioned/enabled with NvDdkDispSetCursorPosition().
 *
 * @param hController The display controller for the cursor.
 * @param position A pointer to the cursor position top left corner.
 * @param size A pointer to either 32x32 or 64x64.
 * @param AndPlane A pointer to AND bits for the cursor surface.
 * @param XorPlane A pointer to XOR bits for the cursor surface.
 * @param fgColor 32-bit XRGB color used as the foreground color for the
 *      cursor.
 * @param bgColor 32-bit XRGB color used as the background color for the
 *      cursor.
 * @param flags Maybe be zero or ::NVDDK_DISP_WAIT.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispControllerSetCursor(
    NvDdkDispControllerHandle hController,
    NvPoint *position,
    NvSize *size,
    void *AndPlane,
    void *XorPlane,
    NvU32 fgColor,
    NvU32 bgColor,
    NvU32 flags );

/**
 * Sets the hardware cursor's position.
 *
 * @param hController The display controller for the cursor.
 * @param pPosition A pointer to the new position for the cursor.
 * @param flags Extra flags.
 *
 * Flag values:
 * - ::NVDDK_DISP_CURSOR_SHOW - enables the cursor, \a pPosition may not be
 *      null.
 * - ::NVDDK_DISP_CURSOR_HIDE - disables the cursor, \a pPosition may be null.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispControllerSetCursorPosition(
    NvDdkDispControllerHandle hController,
    NvPoint *pPosition,
    NvU32 flags);

#define NVDDK_DISP_CURSOR_SHOW    0x0
#define NVDDK_DISP_CURSOR_HIDE    0x1

/**
 * Enables (or disables) content protection for displays.
 *
 * @param hDisplay Handle to a display.
 * @param prot The protection type
 * @param info A pointer to content protection-specific structure, see
 *      ::NvDdkDispHdcpContext or ::NvDdkDispMacrovisionContext
 * @param size The size of the protection-specific structure.
 * @param flags 32-bit value for flags, currently reserved (must be 0).
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispSetContentProtection(
    NvDdkDispDisplayHandle hDisplay,
    NvDdkDispContentProtection prot,
    void *info,
    NvU32 size,
    NvU32 flags );

/**
 * Signals a semaphore when any error in the bitfied of errors specified occurs
 * on the specified controller. At most one semaphore may be registered at a
 * time. Attempting to enable the error trigger is not allowed.
 * The error trigger will be disabled when either \a hSem has been signaled, or
 * the client has disabled the error trigger by passing 0 and NULL for the
 * bitfield and the semaphore respectively.
 *
 * @param hController The display controller for the error configuration.
 * @param bitfield The ORing of bits from ::NvDdkDispActiveError.
 * @param hSem The semaphore to signal when the error occurs.
 * @param flags Reserved, must be zero.
 *
 * @retval NvSuccess If successful, or the appropriate error code.
 */
NvError
NvDdkDispSetErrorTrigger(
    NvDdkDispControllerHandle hController,
    NvU32 bitfield,
    NvOsSemaphoreHandle hSem,
    NvU32 flags );

/**
 * Retrieves the last active error(s) for a given controller. The return value
 * is an ORing from ::NvDdkDispActiveError.
 *
 * @param hController The controller with the errors (or not).
 */
NvU32
NvDdkDispGetLastActiveError(
    NvDdkDispControllerHandle hController );

/**************************\
 * TEST ONLY APIS FOLLOW  *
\**************************/
// Removing doxygen comments so these don't show up in documentation
/*
 * Enable CRC capture hardware.
 *
 * @param hController handle to the display controller
 * @param enable boolean enable/disable
 */
NvError
NvDdkDispTestCrcEnable(
    NvDdkDispControllerHandle hController,
    NvBool enable );

/*
 * Retrieve the last frame's CRC value.
 *
 * @param hController handle to the display controller
 */
NvU32
NvDdkDispTestCrc( NvDdkDispControllerHandle hController );

/**
 * Retrieves a unique ID that will be coupled to the hardware CRC values.
 */
NvU32
NvDdkDispTestHardwareId( NvDdkDispControllerHandle hController );

/**
 * Inject errors into the system.
 */
void
NvDdkDispTestInjectError( NvDdkDispControllerHandle hController, NvU32 error,
    NvU32 flags );
#define NVDDK_DISP_TEST_ERROR_UNDERFLOW     (0x1)
#define NVDDK_DISP_TEST_ERROR_OVERFLOW      (0x2)

#if defined(__cplusplus)
}
#endif
/** @} */

#endif // INCLUDED_NVDDK_DISP_H
