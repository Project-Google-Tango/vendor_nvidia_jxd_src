/*
 * Copyright (c) 2006 NVIDIA Corporation.  All rights reserved.
 *
 * NVIDIA Corporation and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA Corporation is strictly prohibited.
 */

#ifndef INCLUDED_NVASSERT_H
#define INCLUDED_NVASSERT_H

#include "nvcommon.h"

#if defined(__cplusplus)
extern "C"
{
#endif

/** NvOsBreakPoint - break into debugger.
 * @param  file is the file name (usually from the built-in __FILE__ macro)
 * in which the debug assertion message is to refer. If NULL, no debug assertion
 * message is printed.
 * @param line is the line number within 'file' at which the assertion occurred.
 * @param condition is the assertion condition that failed. If NULL, no condition
 * string will be displayed.
 */
void
NvOsBreakPoint(const char* file, NvU32 line, const char* condition);

/**
 * Macro to break into debugger without printing an assertion message.
 */
#define NV_OS_BREAK_POINT() NvOsBreakPoint(NULL, 0, NULL)


/**
 * Runtime condition check with break into debugger if the assert fails.
 * Compiles out in release builds.
 *
 * We provide two variants of assert: one that prints out the failing assert
 * condition (the "#x" string in the macro), and another that doesn't.  By
 * default, we print the condition string in x86 builds only.  The assumption
 * is that x86 systems have boatloads of memory and can afford to put all these
 * extra strings in the binary, whereas other systems are our target systems
 * and tend to have less memory available.  Also, we want to be careful about
 * anything that might make it take too long to transfer system images over to
 * the target system.
 *
 * We also allow individual developers to override this default behavior,
 * either globally or on a per-source-file basis.  To do this, set
 * NV_ASSERT_PROVIDE_CONDITION_STRING to either 0 or 1, either in your own
 * source code, in your own makefile, or by uncommenting the lines below.
 */

#if !defined(NV_ASSERT)
#if NV_DEBUG

// Uncomment me to override default assert behavior
//#define NV_ASSERT_PROVIDE_CONDITION_STRING 0
//#define NV_ASSERT_PROVIDE_CONDITION_STRING 1

// Default behavior: provide condition string in x86 builds only
#if !defined(NV_ASSERT_PROVIDE_CONDITION_STRING)
#if NVCPU_IS_X86
#define NV_ASSERT_PROVIDE_CONDITION_STRING 1
#else
#define NV_ASSERT_PROVIDE_CONDITION_STRING 0
#endif
#endif

// Hint to static analysis tools that further execution need not be considered.
#if defined(__COVERITY__)
#define NV_HINT_TERMINAL() __coverity_panic__()
#else
#define NV_HINT_TERMINAL() do {} while(0)
#endif

#if NV_ASSERT_PROVIDE_CONDITION_STRING
#define NV_ASSERT(x) \
    do { \
        if (!(x)) \
        { \
            /* print message and break into the debugger */ \
            NvOsBreakPoint(__FILE__, __LINE__, #x); \
            NV_HINT_TERMINAL(); \
        } \
    } while( 0 )
#else // NV_ASSERT_PROVIDE_CONDITION_STRING
#define NV_ASSERT(x) \
    do { \
        if (!(x)) \
        { \
            /* print message and break into the debugger */ \
            NvOsBreakPoint(__FILE__, __LINE__, NULL); \
            NV_HINT_TERMINAL(); \
        } \
    } while( 0 )
#endif // NV_ASSERT_PROVIDE_CONDITION_STRING

#else // NV_DEBUG
#define NV_ASSERT(x) do {} while(0)
#endif // NV_DEBUG
#endif //!defined(NV_ASSERT)

/**
 * NV_CT_ASSERT: compile-time assert for constant values.
 *
 * This works by declaring a function with an array parameter.  If the
 * assert condition is true, then the array size will be 1, otherwise
 * the array size will be -1, which will generate a compilation error.
 *
 * No code should be generated by this macro.
 *
 * Three levels of macros are needed to properly expand the line number.
 *
 * This macro was taken in spirit from:
 *     //sw/main/drivers/common/inc/nvctassert.h
 */
#ifdef __COUNTER__
    #define NV_CT_ASSERT(x)            NV_CT_ASSERT_I(x, __COUNTER__)
#else
    #define NV_CT_ASSERT(x)            NV_CT_ASSERT_I(x, __LINE__)
#endif
#define NV_CT_ASSERT_I(x, uniq)        NV_CT_ASSERT_II(x, uniq)
#define NV_CT_ASSERT_II(x, uniq) \
    void compile_time_assertion_failed_##uniq( \
        int _compile_time_assertion_failed_in_line_##uniq[(x) ? 1 : -1])

/**
 * NV_CT_ASSERTM: compile-time assert with custom message.
 *
 * This extends the NV_CT_ASSERT macro to include a custom string.
 * This is helpful when using the macro in a header file, as symbol
 * name duplicates will occur if the NV_CT_ASSERT macro is used on
 * the same line number in two different headers.
 */
#define NV_CT_ASSERTM( x, m )            NV_CT_ASSERTM_I( x, __LINE__, m )
#define NV_CT_ASSERTM_I( x, line, m )    NV_CT_ASSERTM_II( x, line, m )
#define NV_CT_ASSERTM_II( x, line, m )   NV_CT_ASSERT_II( x, line ## _ ## m )

/**
 * A macro to assert (rather than check) that something succeeded.  The use of
 * this macro is strongly discouraged in any production-worthy code.  It is,
 * however, a step up from ignoring the NvError return code of a function, and
 * it is trivial to use and harmless to your release builds.  If everyone uses
 * it, it also makes it easy to search the tree for missing error handling code.
 *
 * In this macro, we don't worry about the stack space wasted from multiple
 * NvError locals in a single function -- production-quality code shouldn't be
 * using this macro in the first place.
 */
#if NV_DEBUG
#define NV_ASSERT_SUCCESS(expr) \
    do \
    { \
        NvError AssertSuccessError = (expr); \
        NV_ASSERT(AssertSuccessError == NvSuccess); \
    } while (0)
#else
#define NV_ASSERT_SUCCESS(expr) \
    do \
    { \
        (void)(expr); \
    } while (0)
#endif

#if defined(__cplusplus)
}
#endif

#endif // INCLUDED_NVASSERT_H
