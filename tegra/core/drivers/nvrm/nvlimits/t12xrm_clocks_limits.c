/*
 * Copyright (c) 2011-2013 NVIDIA Corporation.  All Rights Reserved.
 *
 * NVIDIA Corporation and its licensors retain all intellectual property and
 * proprietary rights in and to this software and related documentation.  Any
 * use, reproduction, disclosure or distribution of this software and related
 * documentation without an express license agreement from NVIDIA Corporation
 * is strictly prohibited.
 */

#include "nvcommon.h"
#include "nvassert.h"
#include "nvrm_drf.h"
#include "nvrm_hwintf.h"
#include "nvrm_clocks.h"
#include "t12xrm_clocks_limits_private.h"
#include "t12x/project_relocation_table.h"
#include "ap15rm_private.h"
#include "t12x/arapb_misc.h"
#include "t12x/arfuse.h"
#include "t12x/arclk_rst.h"

/*
 * Core voltage levels SoC clock frequency limits were characterized at
 * for each process corner. Combined pointer table arranged in order of
 * process calibration settings
 */
static const NvU32 s_T12x_SS_ShmooVoltages[] = { NV_T12XSS_SHMOO_VOLTAGES };
static const NvU32 s_T12x_ST_ShmooVoltages[] = { NV_T12XST_SHMOO_VOLTAGES };
static const NvU32 s_T12x_FT_ShmooVoltages[] = { NV_T12XFT_SHMOO_VOLTAGES };
static const NvU32 s_T12x_FF_ShmooVoltages[] = { NV_T12XFF_SHMOO_VOLTAGES };
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T12x_SS_ShmooVoltages) == NV_ARRAY_SIZE(s_T12x_ST_ShmooVoltages));
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T12x_SS_ShmooVoltages) == NV_ARRAY_SIZE(s_T12x_FT_ShmooVoltages));
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T12x_SS_ShmooVoltages) == NV_ARRAY_SIZE(s_T12x_FF_ShmooVoltages));
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T12x_SS_ShmooVoltages) <= NVRM_VOLTAGE_STEPS);

static const NvU32* s_pT12x_ShmooVoltages[] =
{
    &s_T12x_SS_ShmooVoltages[0],    /* Calibration setting 0 - SS corner */
    &s_T12x_ST_ShmooVoltages[0],    /* Calibration setting 1 - ST corner */
    &s_T12x_FT_ShmooVoltages[0],    /* Calibration setting 2 - FT corner */
    &s_T12x_FF_ShmooVoltages[0]     /* Calibration setting 3 - FF corner */
};
NV_CT_ASSERT(NV_ARRAY_SIZE(s_pT12x_ShmooVoltages) == NV_T12X_PROCESS_CORNERS);

/*
 * Module clock frequency limits table generated by h/w characterization for
 * each process corner (each table entry includes h/w device id and applies
 * to all instances of the respective device). Combined pointer table arranged
 * in order of process calibration settings
 */
static const NvRmScaledClkLimits s_T12x_SS_ScaledClkLimits[] = { NV_T12XSS_SCALED_CLK_LIMITS };
static const NvRmScaledClkLimits s_T12x_ST_ScaledClkLimits[] = { NV_T12XST_SCALED_CLK_LIMITS };
static const NvRmScaledClkLimits s_T12x_FT_ScaledClkLimits[] = { NV_T12XFT_SCALED_CLK_LIMITS };
static const NvRmScaledClkLimits s_T12x_FF_ScaledClkLimits[] = { NV_T12XFF_SCALED_CLK_LIMITS };
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T12x_SS_ScaledClkLimits) == NV_ARRAY_SIZE(s_T12x_ST_ScaledClkLimits));
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T12x_SS_ScaledClkLimits) == NV_ARRAY_SIZE(s_T12x_FT_ScaledClkLimits));
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T12x_SS_ScaledClkLimits) == NV_ARRAY_SIZE(s_T12x_FF_ScaledClkLimits));

static const NvRmScaledClkLimits* s_pT12x_ScaledClkLimits[] =
{
    &s_T12x_SS_ScaledClkLimits[0],  /* Calibration setting 0 - SS corner */
    &s_T12x_ST_ScaledClkLimits[0],  /* Calibration setting 1 - ST corner */
    &s_T12x_FT_ScaledClkLimits[0],  /* Calibration setting 2 - FT corner */
    &s_T12x_FF_ScaledClkLimits[0]   /* Calibration setting 3 - FF corner */
};
NV_CT_ASSERT(NV_ARRAY_SIZE(s_pT12x_ScaledClkLimits) == NV_T12X_PROCESS_CORNERS);

/*
 * CPU voltage levels used for CPU frequency limits characterization and the
 * respective characterization results for all CPU process corners (arranged
 * in order of process calibration settings)
 */

static const NvU32 s_T12x_SS_CpuVoltages[] = { NV_T12XSS_CPU_VOLTAGES };
static const NvU32 s_T12x_ST_CpuVoltages[] = { NV_T12XST_CPU_VOLTAGES };
static const NvU32 s_T12x_FT_CpuVoltages[] = { NV_T12XFT_CPU_VOLTAGES };
static const NvU32 s_T12x_FF_CpuVoltages[] = { NV_T12XFF_CPU_VOLTAGES };
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T12x_SS_CpuVoltages) == NV_ARRAY_SIZE(s_T12x_ST_CpuVoltages));
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T12x_SS_CpuVoltages) == NV_ARRAY_SIZE(s_T12x_FT_CpuVoltages));
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T12x_SS_CpuVoltages) == NV_ARRAY_SIZE(s_T12x_FF_CpuVoltages));
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T12x_SS_CpuVoltages) <= NVRM_VOLTAGE_STEPS);

static const NvU32* s_pT12x_CpuVoltages[] =
{
    &s_T12x_SS_CpuVoltages[0],  /* Calibration setting 0 - SS CPU corner */
    &s_T12x_ST_CpuVoltages[0],  /* Calibration setting 1 - ST CPU corner */
    &s_T12x_FT_CpuVoltages[0],  /* Calibration setting 2 - FT CPU corner */
    &s_T12x_FF_CpuVoltages[0],  /* Calibration setting 3 - FF CPU corner */
};
NV_CT_ASSERT(NV_ARRAY_SIZE(s_pT12x_CpuVoltages) == NV_T12X_PROCESS_CORNERS);

static const NvRmScaledClkLimits s_T12x_ScaledCpuClkLimits[] =
{
    NV_T12XSS_SCALED_CPU_CLK_LIMITS,
    NV_T12XST_SCALED_CPU_CLK_LIMITS,
    NV_T12XFT_SCALED_CPU_CLK_LIMITS,
    NV_T12XFF_SCALED_CPU_CLK_LIMITS,
};
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T12x_ScaledCpuClkLimits) == NV_T12X_PROCESS_CORNERS);

/*
 * Maximum frequency limits table for clocks depended on SoC SKU;
 * ordered by SKU number
 */
static const struct
{
    NvRmSKUedLimits limits;
    NvU32 sku;
} s_T12x_SKUedLimits[] =
{
    NV_T12X_SKUED_LIMITS
};

/**
 * OSC Doubler tap delays for each supported frequency in order
 * of process calibration settings
 */
static const NvRmOscDoublerConfig s_T12x_OscDoublerConfigurations[] =
{
    NV_T12X_OSC_DOUBLER_CONFIGURATIONS
};

/**
 * EMC DQSIB offsets in order of process calibration settings
 */
static const NvU32 s_T12x_DqsibOffsets[] =
{
    NV_T12X_DQSIB_OFFSETS
};
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T12x_DqsibOffsets) == NV_T12X_PROCESS_CORNERS);
NV_CT_ASSERT(NV_T12X_PROCESS_CORNERS <= NVRM_PROCESS_CORNERS);

/*
 * Combined SoC characterization data record
 */
static NvRmSocShmoo s_T12x_SocShmoo = {0};
static NvRmCpuShmoo s_T12x_CpuShmoo = {0};

NvError NvRmPrivChipShmooDataInit(
    NvRmDeviceHandle hRmDevice,
    NvRmChipFlavor* pChipFlavor)
{
    NvU32 i;

    // Read chip ID
    NvRmChipId ChipId;
    NvU32 reg = NV_REGR(hRmDevice, NVRM_MODULE_ID(NvRmModuleID_Misc, 0),
        APB_MISC_GP_HIDREV_0);
    ChipId.Id = (NvU16)NV_DRF_VAL(APB_MISC_GP, HIDREV, CHIPID, reg );
    ChipId.Major = (NvU8)NV_DRF_VAL(APB_MISC_GP, HIDREV, MAJORREV, reg );
    ChipId.Minor = (NvU8)NV_DRF_VAL(APB_MISC_GP, HIDREV, MINORREV, reg );

    if (ChipId.Id == 0x40)
    {
        if (ChipId.Major != 0)
        {
            /* FIXME: get real sku and corners */
            pChipFlavor->sku = 0;
            pChipFlavor->corner = 0;
            pChipFlavor->CpuCorner = 0;
        }
        else
        {
            /* FPGA/Simulation */
            pChipFlavor->sku = 0;
            pChipFlavor->corner = 0;
            pChipFlavor->CpuCorner = 0;
        }
    }
    else
    {
        NV_ASSERT(!"Invalid chip ID");
        pChipFlavor->sku = 0;
        pChipFlavor->corner = 0;
        pChipFlavor->CpuCorner = 0;
        pChipFlavor->pSocShmoo = NULL;
        pChipFlavor->pCpuShmoo = NULL;
        return NvSuccess;
    }
    NV_ASSERT(pChipFlavor->corner < NV_T12X_PROCESS_CORNERS);
    NV_ASSERT(pChipFlavor->CpuCorner < NV_T12X_PROCESS_CORNERS);
    NvOsMemset((void*)&s_T12x_SocShmoo, 0, sizeof(s_T12x_SocShmoo));
    NvOsMemset((void*)&s_T12x_CpuShmoo, 0, sizeof(s_T12x_CpuShmoo));

    // Fill in SKUed limits for the chip at hand
    for (i = 0; i < NV_ARRAY_SIZE(s_T12x_SKUedLimits); i++)
    {
        if (s_T12x_SKUedLimits[i].sku == pChipFlavor->sku)
            break;
    }
    NV_ASSERT(i < NV_ARRAY_SIZE(s_T12x_SKUedLimits));
    s_T12x_SocShmoo.pSKUedLimits = &s_T12x_SKUedLimits[i].limits;

    // Fill in core rail characterization data for the chip at hand
    s_T12x_SocShmoo.ShmooVoltages = s_pT12x_ShmooVoltages[pChipFlavor->corner];
    for (i = 0; i < NV_ARRAY_SIZE(s_T12x_SS_ShmooVoltages); i++)
    {
        if (s_T12x_SocShmoo.ShmooVoltages[i] ==
            s_T12x_SocShmoo.pSKUedLimits->NominalCoreMv)
            break;
    }
    if(i >= NV_ARRAY_SIZE(s_T12x_SS_ShmooVoltages))
    {
        NV_ASSERT(!"Nominal voltage not found");
        i = NV_ARRAY_SIZE(s_T12x_SS_ShmooVoltages) - 1;  // use max shmoo volt
    }
    s_T12x_SocShmoo.ShmooVmaxIndex = i;

    s_T12x_SocShmoo.ScaledLimitsList =
        s_pT12x_ScaledClkLimits[pChipFlavor->corner];
    s_T12x_SocShmoo.ScaledLimitsListSize =
        NV_ARRAY_SIZE(s_T12x_SS_ScaledClkLimits);

    s_T12x_SocShmoo.OscDoublerCfgList =
        &s_T12x_OscDoublerConfigurations[0];
    s_T12x_SocShmoo.OscDoublerCfgListSize =
        NV_ARRAY_SIZE(s_T12x_OscDoublerConfigurations);

    NV_ASSERT(pChipFlavor->corner < NV_ARRAY_SIZE(s_T12x_DqsibOffsets));
    s_T12x_SocShmoo.DqsibOffset = s_T12x_DqsibOffsets[pChipFlavor->corner];

    s_T12x_SocShmoo.SvopLowVoltage = NV_T12X_SVOP_LOW_VOLTAGE;
    s_T12x_SocShmoo.SvopLowSetting = NV_T12X_SVOP_LOW_SETTING;
    s_T12x_SocShmoo.SvopHighSetting = NV_T12X_SVOP_HIGH_SETTING;

    pChipFlavor->pSocShmoo = &s_T12x_SocShmoo;

    // Fill in dedicated CPU rail characterization data for the chip at hand
    s_T12x_CpuShmoo.ShmooVoltages = s_pT12x_CpuVoltages[pChipFlavor->CpuCorner];
    s_T12x_CpuShmoo.pScaledCpuLimits =
        &s_T12x_ScaledCpuClkLimits[pChipFlavor->CpuCorner];
    s_T12x_CpuShmoo.ShmooVmaxIndex = (NV_ARRAY_SIZE(s_T12x_SS_CpuVoltages) -1);

    for (i = 0; i < s_T12x_CpuShmoo.ShmooVmaxIndex; i++)
    {
        if ((s_T12x_CpuShmoo.pScaledCpuLimits->MaxKHzList[i + 1] == 0) ||
            (s_T12x_CpuShmoo.pScaledCpuLimits->MaxKHzList[i] >=
             s_T12x_SocShmoo.pSKUedLimits->CpuMaxKHz))
            break;
    }
    s_T12x_CpuShmoo.ShmooVmaxIndex = i;
    NV_ASSERT(s_T12x_CpuShmoo.ShmooVoltages[i] <=
              s_T12x_SocShmoo.pSKUedLimits->NominalCpuMv);
    NV_ASSERT(s_T12x_CpuShmoo.pScaledCpuLimits->MaxKHzList[i] >=
              s_T12x_SocShmoo.pSKUedLimits->CpuMaxKHz);

    pChipFlavor->pCpuShmoo = &s_T12x_CpuShmoo;
    return NvSuccess;
}

