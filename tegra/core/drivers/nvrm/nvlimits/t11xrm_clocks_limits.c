/*
 * Copyright (c) 2011-2013, NVIDIA CORPORATION.  All rights reserved.
 *
 * NVIDIA CORPORATION and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA CORPORATION is strictly prohibited
 */

#include "nvcommon.h"
#include "nvassert.h"
#include "nvrm_drf.h"
#include "nvrm_hwintf.h"
#include "nvrm_clocks.h"
#include "t11xrm_clocks_limits_private.h"
#include "t11x/project_relocation_table.h"
#include "ap15rm_private.h"
#include "t11x/arapb_misc.h"
#include "t11x/arfuse.h"
#include "t11x/arclk_rst.h"

/*
 * Core voltage levels SoC clock frequency limits were characterized at
 * for each process corner. Combined pointer table arranged in order of
 * process calibration settings
 */
static const NvU32 s_T11x_SS_ShmooVoltages[] = { NV_T11XSS_SHMOO_VOLTAGES };
static const NvU32 s_T11x_ST_ShmooVoltages[] = { NV_T11XST_SHMOO_VOLTAGES };
static const NvU32 s_T11x_FT_ShmooVoltages[] = { NV_T11XFT_SHMOO_VOLTAGES };
static const NvU32 s_T11x_FF_ShmooVoltages[] = { NV_T11XFF_SHMOO_VOLTAGES };
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T11x_SS_ShmooVoltages) == NV_ARRAY_SIZE(s_T11x_ST_ShmooVoltages));
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T11x_SS_ShmooVoltages) == NV_ARRAY_SIZE(s_T11x_FT_ShmooVoltages));
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T11x_SS_ShmooVoltages) == NV_ARRAY_SIZE(s_T11x_FF_ShmooVoltages));
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T11x_SS_ShmooVoltages) <= NVRM_VOLTAGE_STEPS);

static const NvU32* s_pT11x_ShmooVoltages[] =
{
    &s_T11x_SS_ShmooVoltages[0],    /* Calibration setting 0 - SS corner */
    &s_T11x_ST_ShmooVoltages[0],    /* Calibration setting 1 - ST corner */
    &s_T11x_FT_ShmooVoltages[0],    /* Calibration setting 2 - FT corner */
    &s_T11x_FF_ShmooVoltages[0]     /* Calibration setting 3 - FF corner */
};
NV_CT_ASSERT(NV_ARRAY_SIZE(s_pT11x_ShmooVoltages) == NV_T11X_PROCESS_CORNERS);

/*
 * Module clock frequency limits table generated by h/w characterization for
 * each process corner (each table entry includes h/w device id and applies
 * to all instances of the respective device). Combined pointer table arranged
 * in order of process calibration settings
 */
static const NvRmScaledClkLimits s_T11x_SS_ScaledClkLimits[] = { NV_T11XSS_SCALED_CLK_LIMITS };
static const NvRmScaledClkLimits s_T11x_ST_ScaledClkLimits[] = { NV_T11XST_SCALED_CLK_LIMITS };
static const NvRmScaledClkLimits s_T11x_FT_ScaledClkLimits[] = { NV_T11XFT_SCALED_CLK_LIMITS };
static const NvRmScaledClkLimits s_T11x_FF_ScaledClkLimits[] = { NV_T11XFF_SCALED_CLK_LIMITS };
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T11x_SS_ScaledClkLimits) == NV_ARRAY_SIZE(s_T11x_ST_ScaledClkLimits));
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T11x_SS_ScaledClkLimits) == NV_ARRAY_SIZE(s_T11x_FT_ScaledClkLimits));
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T11x_SS_ScaledClkLimits) == NV_ARRAY_SIZE(s_T11x_FF_ScaledClkLimits));

static const NvRmScaledClkLimits* s_pT11x_ScaledClkLimits[] =
{
    &s_T11x_SS_ScaledClkLimits[0],  /* Calibration setting 0 - SS corner */
    &s_T11x_ST_ScaledClkLimits[0],  /* Calibration setting 1 - ST corner */
    &s_T11x_FT_ScaledClkLimits[0],  /* Calibration setting 2 - FT corner */
    &s_T11x_FF_ScaledClkLimits[0]   /* Calibration setting 3 - FF corner */
};
NV_CT_ASSERT(NV_ARRAY_SIZE(s_pT11x_ScaledClkLimits) == NV_T11X_PROCESS_CORNERS);

/*
 * CPU voltage levels used for CPU frequency limits characterization and the
 * respective characterization results for all CPU process corners (arranged
 * in order of process calibration settings)
 */

static const NvU32 s_T11x_SS_CpuVoltages[] = { NV_T11XSS_CPU_VOLTAGES };
static const NvU32 s_T11x_ST_CpuVoltages[] = { NV_T11XST_CPU_VOLTAGES };
static const NvU32 s_T11x_FT_CpuVoltages[] = { NV_T11XFT_CPU_VOLTAGES };
static const NvU32 s_T11x_FF_CpuVoltages[] = { NV_T11XFF_CPU_VOLTAGES };
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T11x_SS_CpuVoltages) == NV_ARRAY_SIZE(s_T11x_ST_CpuVoltages));
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T11x_SS_CpuVoltages) == NV_ARRAY_SIZE(s_T11x_FT_CpuVoltages));
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T11x_SS_CpuVoltages) == NV_ARRAY_SIZE(s_T11x_FF_CpuVoltages));
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T11x_SS_CpuVoltages) <= NVRM_VOLTAGE_STEPS);

static const NvU32* s_pT11x_CpuVoltages[] =
{
    &s_T11x_SS_CpuVoltages[0],  /* Calibration setting 0 - SS CPU corner */
    &s_T11x_ST_CpuVoltages[0],  /* Calibration setting 1 - ST CPU corner */
    &s_T11x_FT_CpuVoltages[0],  /* Calibration setting 2 - FT CPU corner */
    &s_T11x_FF_CpuVoltages[0],  /* Calibration setting 3 - FF CPU corner */
};
NV_CT_ASSERT(NV_ARRAY_SIZE(s_pT11x_CpuVoltages) == NV_T11X_PROCESS_CORNERS);

static const NvRmScaledClkLimits s_T11x_ScaledCpuClkLimits[] =
{
    NV_T11XSS_SCALED_CPU_CLK_LIMITS,
    NV_T11XST_SCALED_CPU_CLK_LIMITS,
    NV_T11XFT_SCALED_CPU_CLK_LIMITS,
    NV_T11XFF_SCALED_CPU_CLK_LIMITS,
};
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T11x_ScaledCpuClkLimits) == NV_T11X_PROCESS_CORNERS);

/*
 * Maximum frequency limits table for clocks depended on SoC SKU;
 * ordered by SKU number
 */
static const struct
{
    NvRmSKUedLimits limits;
    NvU32 sku;
} s_T11x_SKUedLimits[] =
{
    NV_T11X_SKUED_LIMITS
};

/**
 * OSC Doubler tap delays for each supported frequency in order
 * of process calibration settings
 */
static const NvRmOscDoublerConfig s_T11x_OscDoublerConfigurations[] =
{
    NV_T11X_OSC_DOUBLER_CONFIGURATIONS
};

/**
 * EMC DQSIB offsets in order of process calibration settings
 */
static const NvU32 s_T11x_DqsibOffsets[] =
{
    NV_T11X_DQSIB_OFFSETS
};
NV_CT_ASSERT(NV_ARRAY_SIZE(s_T11x_DqsibOffsets) == NV_T11X_PROCESS_CORNERS);
NV_CT_ASSERT(NV_T11X_PROCESS_CORNERS <= NVRM_PROCESS_CORNERS);

/*
 * Combined SoC characterization data record
 */
static NvRmSocShmoo s_T11x_SocShmoo = {0};
static NvRmCpuShmoo s_T11x_CpuShmoo = {0};

NvError NvRmPrivChipShmooDataInit(
    NvRmDeviceHandle hRmDevice,
    NvRmChipFlavor* pChipFlavor)
{
    NvU32 i;

    pChipFlavor->sku = 0;
    pChipFlavor->corner = 0;
    pChipFlavor->CpuCorner = 0;

    NV_ASSERT(pChipFlavor->corner < NV_T11X_PROCESS_CORNERS);
    NV_ASSERT(pChipFlavor->CpuCorner < NV_T11X_PROCESS_CORNERS);
    NvOsMemset((void*)&s_T11x_SocShmoo, 0, sizeof(s_T11x_SocShmoo));
    NvOsMemset((void*)&s_T11x_CpuShmoo, 0, sizeof(s_T11x_CpuShmoo));

    // Fill in SKUed limits for the chip at hand
    for (i = 0; i < NV_ARRAY_SIZE(s_T11x_SKUedLimits); i++)
    {
        if (s_T11x_SKUedLimits[i].sku == pChipFlavor->sku)
            break;
    }
    NV_ASSERT(i < NV_ARRAY_SIZE(s_T11x_SKUedLimits));
    s_T11x_SocShmoo.pSKUedLimits = &s_T11x_SKUedLimits[i].limits;

    // Fill in core rail characterization data for the chip at hand
    s_T11x_SocShmoo.ShmooVoltages = s_pT11x_ShmooVoltages[pChipFlavor->corner];
    for (i = 0; i < NV_ARRAY_SIZE(s_T11x_SS_ShmooVoltages); i++)
    {
        if (s_T11x_SocShmoo.ShmooVoltages[i] ==
            s_T11x_SocShmoo.pSKUedLimits->NominalCoreMv)
            break;
    }
    if(i >= NV_ARRAY_SIZE(s_T11x_SS_ShmooVoltages))
    {
        NV_ASSERT(!"Nominal voltage not found");
        i = NV_ARRAY_SIZE(s_T11x_SS_ShmooVoltages) - 1;  // use max shmoo volt
    }
    s_T11x_SocShmoo.ShmooVmaxIndex = i;

    s_T11x_SocShmoo.ScaledLimitsList =
        s_pT11x_ScaledClkLimits[pChipFlavor->corner];
    s_T11x_SocShmoo.ScaledLimitsListSize =
        NV_ARRAY_SIZE(s_T11x_SS_ScaledClkLimits);

    s_T11x_SocShmoo.OscDoublerCfgList =
        &s_T11x_OscDoublerConfigurations[0];
    s_T11x_SocShmoo.OscDoublerCfgListSize =
        NV_ARRAY_SIZE(s_T11x_OscDoublerConfigurations);

    NV_ASSERT(pChipFlavor->corner < NV_ARRAY_SIZE(s_T11x_DqsibOffsets));
    s_T11x_SocShmoo.DqsibOffset = s_T11x_DqsibOffsets[pChipFlavor->corner];

    s_T11x_SocShmoo.SvopLowVoltage = NV_T11X_SVOP_LOW_VOLTAGE;
    s_T11x_SocShmoo.SvopLowSetting = NV_T11X_SVOP_LOW_SETTING;
    s_T11x_SocShmoo.SvopHighSetting = NV_T11X_SVOP_HIGH_SETTING;

    pChipFlavor->pSocShmoo = &s_T11x_SocShmoo;

    // Fill in dedicated CPU rail characterization data for the chip at hand
    s_T11x_CpuShmoo.ShmooVoltages = s_pT11x_CpuVoltages[pChipFlavor->CpuCorner];
    s_T11x_CpuShmoo.pScaledCpuLimits =
        &s_T11x_ScaledCpuClkLimits[pChipFlavor->CpuCorner];
    s_T11x_CpuShmoo.ShmooVmaxIndex = (NV_ARRAY_SIZE(s_T11x_SS_CpuVoltages) -1);

    for (i = 0; i < s_T11x_CpuShmoo.ShmooVmaxIndex; i++)
    {
        if ((s_T11x_CpuShmoo.pScaledCpuLimits->MaxKHzList[i + 1] == 0) ||
            (s_T11x_CpuShmoo.pScaledCpuLimits->MaxKHzList[i] >=
             s_T11x_SocShmoo.pSKUedLimits->CpuMaxKHz))
            break;
    }
    s_T11x_CpuShmoo.ShmooVmaxIndex = i;
    NV_ASSERT(s_T11x_CpuShmoo.ShmooVoltages[i] <=
              s_T11x_SocShmoo.pSKUedLimits->NominalCpuMv);
    NV_ASSERT(s_T11x_CpuShmoo.pScaledCpuLimits->MaxKHzList[i] >=
              s_T11x_SocShmoo.pSKUedLimits->CpuMaxKHz);

    pChipFlavor->pCpuShmoo = &s_T11x_CpuShmoo;
    return NvSuccess;
}
