#!/usr/bin/env python
#
# Copyright (c) 2013-2014 NVIDIA Corporation.  All Rights Reserved.
#
# NVIDIA Corporation and its licensors retain all intellectual property
# and proprietary rights in and to this software, related documentation
# and any modifications thereto.  Any use, reproduction, disclosure or
# distribution of this software and related documentation without an express
# license agreement from NVIDIA Corporation is strictly prohibited.
#

from __future__ import print_function

import sys
import os
import getopt
import json
import collections
import copy

verbose = False
spec_file = "tnspec.json"
debug = False
product_id = ""
argv_copy = ""

def pr(out, *args, **opt):
    # 1 - stdout, 2 - stderr
    out -= 1
    std = [sys.stdout, sys.stderr]
    if opt.has_key('prefix'):
        print(opt['prefix'], end='', file=std[out])
    print(*args, file=std[out], end=opt.get('end','\n'))

def usage(out):
    pr(out, "tnspec <command> [<product id>]")
    pr(out, "       [-v|--verbose] [-s|--spec <spec file>]")
    pr(out, "")
    pr(out, "commands:")
    pr(out, "   nct  <product id> : generates a NCT file")
    pr(out, "   dtb  <product id> : returns corresponding DTB file name")
    pr(out, "   bct  <product id> : returns corresponding BCT file name")
    pr(out, "   cfg  <product id> : returns corresponding CFG file name")
    pr(out, "   sku  <product id> : returns corresponding chip SKU")
    pr(out, "   odm  <product id> : returns corresponding ODM")
    pr(out, "   info <prodcut id> : prints products information.")
    pr(out, "                       -v prints extra information.")
    pr(out, "   list : lists all products.")
    pr(out, "   help : prints this message.")
    pr(out, "")
    pr(out, "spec file:")
    pr(out, "   'tnspec.json' is used by default unless specified by -s or --spec")

def cmd_list(sd):
    specs = sd['specs']
    spec_names = sorted(specs.keys())
    for pid in spec_names:
        pr(1, pid)

def cmd_help(sd):
    usage(1)

def cmd_bct(sd):
    specs = sd['specs']
    if specs[product_id].has_key('bct'):
        pr(1, specs[product_id]['bct'])

def cmd_cfg(sd):
    specs = sd['specs']
    if specs[product_id].has_key('cfg'):
        pr(1, specs[product_id]['cfg'] )

def cmd_sku(sd):
    specs = sd['specs']
    if specs[product_id].has_key('sku'):
        pr(1, specs[product_id]['sku'] )

def cmd_odm(sd):
    specs = sd['specs']
    if specs[product_id].has_key('odm'):
        pr(1, specs[product_id]['odm'] )

def cmd_dtb(sd):
    specs = sd['specs']
    if specs[product_id].has_key('dtb'):
        pr(1, specs[product_id]['dtb'] )

def cmd_info(sd):
    spec = sd['specs'][product_id]
    pr(1, '[' + product_id + ']')
    if spec.has_key('desc'):
        pr(1, "Description: %s" % spec['desc']);
    pr(1, "")
    pr(1, "Proc ID: " + spec.get('proc', {}).get('id', '0'))
    pr(1, "PMU  ID: " + spec.get('pmu', {}).get('id',  '0'))
    pr(1, "Disp ID: " + spec.get('disp', {}).get('id', '0'))
    if verbose:
        pr(1, "== dumping all information ==")
        pr(1, json.dumps(spec).translate(None,'{"}'))

nct_tmpl_header = \
'''// Automatically generated by 'tnspec nct %s'.
// NCT-%s
<version:0x00010000>
<vid:0x955; pid:0x1001>
<revision:39>
<offset:0x4000>
//-----------------------------------------------
// 0x10 : 1byte  data, 0x1A : 1byte  data array
// 0x20 : 2bytes data, 0x2A : 2bytes data array
// 0x40 : 4bytes data, 0x4A : 4bytes data array
// 0x80 : string     , 0x8A : string array
//-----------------------------------------------
//'''
nct_tmpl_entry = "\n<name: %12s; idx:%2d; tag:%s; data:%s>"
nct_tmpl_entry_array = "\n<name: %12s; idx:%2d; tag:%s;%s>"

def cmd_nct(sd):
    nct_entries = \
    [
        { 'name': 'serial',
          'idx' : 0,
          'type': '0x80',
          'fn'  : nct_fn_serial },
        { 'name': 'wifi',
          'idx' : 1,
          'type': '0x1A',
          'fn'  : nct_fn_not_implemented },
        { 'name': 'bt',
          'idx' : 2,
          'type': '0x1A',
          'fn'  : nct_fn_not_implemented },
        { 'name': 'cm',
          'idx' : 3,
          'type': '0x20',
          'fn'  : nct_fn_id },
        { 'name': 'lbh',
          'idx' : 4,
          'type': '0x20',
          'fn'  : nct_fn_id },
        { 'name': 'factory_mode',
          'idx' : 5,
          'type': '0x40',
          'fn'  : nct_fn_id },
        { 'name': 'ramdump',
          'idx' : 6,
          'type': '0x40',
          'fn'  : nct_fn_id },
        # test is 7, but we don't use it
        { 'name': 'board_info',
          'idx' : 8,
          'type': '0x4A',
          'fn'  : nct_fn_board_info },
        { 'name': 'gps',
          'idx' : 9,
          'type': '0x20',
          'fn'  : nct_fn_id },
        { 'name': 'lcd',
          'idx' : 10,
          'type': '0x20',
          'fn'  : nct_fn_lcd },
        { 'name': 'accelerometer',
          'idx' : 11,
          'type': '0x20',
          'fn'  : nct_fn_id },
        { 'name': 'compass',
          'idx' : 12,
          'type': '0x20',
          'fn'  : nct_fn_id },
        { 'name': 'gyroscope',
          'idx' : 13,
          'type': '0x20',
          'fn'  : nct_fn_id },
        { 'name': 'light',
          'idx' : 14,
          'type': '0x20',
          'fn'  : nct_fn_id },
        { 'name': 'charger',
          'idx' : 15,
          'type': '0x20',
          'fn'  : nct_fn_id },
        { 'name': 'touch',
          'idx' : 16,
          'type': '0x20',
          'fn'  : nct_fn_id },
        { 'name': 'fuelgauge',
          'idx' : 17,
          'type': '0x1A',
          'fn'  : nct_fn_not_implemented },
        { 'name': 'emc_table',
          'idx' : range(18, 18+20),
          'type': '0x1A',
          'fn'  : nct_fn_not_implemented },
    ]

    nct_data = nct_tmpl_header % (product_id, product_id)
    for e in nct_entries:
        nct_data += e['fn'](sd, e)

    pr(1, nct_data)

def nct_fn_not_implemented(sd, e):
    return ""

def nct_fn_serial(sd, e):
    spec = sd['specs'][product_id]
    default_sn = "%sENG8888888" % sd['family'].upper()
    sn = spec.get('sn', default_sn)
    #TODO dynamically generate this
    return nct_tmpl_entry % (e['name'], e['idx'], e['type'], sn)

def nct_fn_board_info(sd, e):
    spec = sd['specs'][product_id]
    # if "skip_board_info" is set to true, we do not return board_info
    if spec.get('skip_board_info', False):
        return ""

    binfo = ';'.join([" data:%s"] * 9)
    binfo = binfo % (spec.get('proc',{}).get('id',  0),
                     spec.get('proc',{}).get('sku', 0),
                     spec.get('proc',{}).get('fab', 0),
                     spec.get('pmu', {}).get('id',  0),
                     spec.get('pmu', {}).get('sku', 0),
                     spec.get('pmu', {}).get('fab', 0),
                     spec.get('disp',{}).get('id',  0),
                     spec.get('disp',{}).get('sku', 0),
                     spec.get('disp',{}).get('fab', 0))
    # return something (0's) for board_info even if it's not in the spec file
    return nct_tmpl_entry_array % (e['name'], e['idx'], e['type'], binfo )

def nct_fn_id(sd, e):
    spec = sd['specs'][product_id]
    if not spec.has_key(e['name']):
        return ""
    return nct_tmpl_entry % (e['name'], e['idx'], e['type'], spec[e['name']])

def nct_fn_lcd(sd, e):
    spec = sd['specs'][product_id]
    if not spec.has_key('disp') or not spec['disp'].has_key('id'):
        return ""
    return nct_tmpl_entry % (e['name'], e['idx'], e['type'], spec['disp']['id'])

def merge_dict(d1, d2):
    for k,v2 in d2.items():
        v1 = d1.get(k) # returns None if v1 has no value for this key
        # use dict instead of collections.Mapping on earlier version of python
        if (isinstance(v1, collections.Mapping) and
            isinstance(v2, collections.Mapping)):
            merge_dict(v1, v2)
        else:
            d1[k] = v2

def flatten_base(specs, pid):
    spec = specs[pid]
    if not spec.has_key('base'):
        return spec
    base_name = spec.pop('base') # remove base key as well
    if not specs.has_key(base_name):
        pr(2, "Error: base '%s' in '%s' not found." % (base_name, pid))
        sys.exit(1)
    updated = copy.deepcopy(flatten_base(specs, base_name))
    merge_dict(updated, spec)
    specs[pid] = updated
    return updated

def flatten_spec(spec_data):
    if not spec_data.has_key('specs'):
        return
    for pid in spec_data['specs'].keys():
        x = flatten_base(spec_data['specs'], pid)

def read_spec():
    with open(spec_file) as spec:
        try:
            spec_data = json.load(spec)
        except ValueError as detail:
            pr(2, "Error in %s: " % spec_file, detail)
            sys.exit(1)
    return spec_data

def command_failed():
    # it's stderr by default
    if debug:
        pr(2, "Command failed: 'tnspec %s'" % ' '.join(argv_copy))

def main(cmds, options):
    commands = \
        {
            'nct':
                {
                    'need_pid' : True,
                    'fn' : cmd_nct
                },
            'dtb':
                {
                    'need_pid' : True,
                    'fn' : cmd_dtb
                },
            'bct':
                {
                    'need_pid' : True,
                    'fn' : cmd_bct
                },
            'cfg':
                {
                    'need_pid' : True,
                    'fn' : cmd_cfg
                },
            'sku':
                {
                    'need_pid' : True,
                    'fn' : cmd_sku
                },
            'odm':
                {
                    'need_pid' : True,
                    'fn' : cmd_odm
                },
            'info':
                {
                    'need_pid' : True,
                    'fn' : cmd_info
                },
            'list':
                {
                    'need_pid' : False,
                    'fn' : cmd_list
                },
            'help':
                {
                    'need_pid' : False,
                    'fn' : cmd_help
                }
        }
    global product_id, spec_file, debug, verbose

    try:
        opts, args = getopt.getopt(options, "dvs:", ["verbose","spec="])
    except:
        usage(2)
        sys.exit(1)

    for o, a in opts:
        if o in ("-v", "--verbose"):
            verbose = True
        elif o in ("-s", "--spec"):
            spec_file = a
        elif o == "-d":
            debug = True

    cmd = cmds[0]
    if not commands.has_key(cmd):
        command_failed()
        pr(2, "Error: Unrecognized command: " + cmd)
        usage(2)
        sys.exit(1)
    elif commands[cmd]['need_pid']:
        if len(cmds) < 2:
            command_failed()
            pr(2, "Error: missing product id.")
            pr(2, "Try 'tnspec list' to get product ids.")
            usage(2)
            sys.exit(1)
        else:
            product_id = cmds[1]

    # check if spec file exists
    if not os.path.exists(spec_file):
        command_failed()
        pr(2, "Error: tnspec file '%s' doesn't exist." % spec_file )
        if spec_file == "tnspec.json":
            pr(2, "-- You're using the default specfile - 'tnspec.json'.")
            pr(2, "   Make sure 'tnspec.json' is in your current directory or")
            pr(2, "   use -s|--spec to point to your spec file.")
        usage(2)
        sys.exit(1)

    # import spec file
    spec_data = read_spec()
    flatten_spec(spec_data)

    if (debug):
        pr(2, json.dumps(spec_data, sort_keys=False, indent=4, separators=(',', ': ')))

    # check if product id is valid
    if commands[cmd]['need_pid'] and not spec_data['specs'].has_key(product_id):
        command_failed()
        pr(2, "Error: product name %s is not valid." % product_id)
        pr(2, "       Try 'tnspec list' to list available products")
        sys.exit(1)

    commands[cmd]["fn"](spec_data)


if __name__ == "__main__":
    # split commands and args. find the first occurence of a string starting
    # with '-'
    argv_copy = cmds = sys.argv[1:]
    options = []

    for i in range(len(argv_copy)):
        if argv_copy[i][0] == '-':
            options = argv_copy[i:]
            cmds = argv_copy[:i]
            break

    if len(cmds) == 0:
        usage(2)
        sys.exit(1)

    main(cmds, options)
